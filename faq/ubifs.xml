<PAGE>
<VAR match="VAR_ORIGIN" replace="../" />
<VAR match="VAR_CVSID" replace="Last updated: 23 Apr 2008, dedekind"/>
<INCLUDE file="../inc/header.tmpl" />

<VAR match="VAR_SEL_FAQ" replace="selected" />
<VAR match="VAR_SEL_UBIFS" replace="selected" />
<PARSE file="../menu1.xml" />

<INCLUDE file="../inc/content.tmpl" />

<h1>UBIFS FAQ and HOWTO</h1>

<h2>Table of contents</h2>
<ol>
	<li><a href="ubifs.html#L_ubifs_mlc">May UBIFS be used on MLC NAND flash?</a></li>
	<li><a href="ubifs.html#L_mount_ubifs">How to mount UBIFS?</a></li>
	<li><a href="ubifs.html#L_find_lebsz">How to find out LEB size, sub-page size, etc?</a></li>
	<li><a href="ubifs.html#L_mkfubifs">How to create an UBIFS image?</a></li>
	<li><a href="ubifs.html#L_emptyflash">May an empty UBI volume be mounted?</a></li>
	<li><a href="ubifs.html#L_ubifs_nandsim">How to use UBIFS with nandsim?</a></li>
</ol>



<h2><a name="L_ubifs_mlc">May UBIFS be used on MLC NAND flash?</a></h2>

<p>Yes, it should run fine. Let's consider the specific aspects of MLC
NAND flashes:</p>

<ul>
	<li>MLC NAND flashes are more "faulty" than SLC, so they use stronger
	ECC codes which occupy whole OOB area; this is not a problem
	for UBI/UBIFS, because neither UBIFS nor UBI use OOB area;</li>

	<li>when the data is written to an eraseblock, it has to be written
	sequentially, from the beginning of the eraseblock to the end of it;
	this is also not a problem because it is exactly what UBI and UBIFS do
	(see also <a href="../faq/ubi.html#L_restrict">this</a> section);</li>

	<li>MLC flashes have rather short eraseblock life-cycle of just few
	thousand of erase cycles; and this is not be a problem, because UBI
	uses deterministic wear-leveling algorithm
	(see <a href="../faq/ubi.html#L_mlc">this</a> section).</li>
</ul>



<h2><a name="L_mount_ubifs">How to mount UBIFS?</a></h2>

<p>UBIFS mounts UBI volumes, not UBI devices, not MTD devices. There are no
block device nodes corresponding to UBI volumes and UBIFS uses device-less
mount, just like <code>procfs</code> or <code>sysfs</code>. The volume to
mount is specified using <code>ubiX_Y</code> or <code>ubiX:NAME</code>
syntax, where</p>

<ul>
	<li><code>X</code> - UBI device number;</li>
	<li><code>Y</code> - UBI volume number;</li>
	<li><code>NAME</code> - UBI volume name.</li>
</ul>

<p>For example,</p>

<pre>
$ mount -t ubifs ubi0_0 /mnt/ubifs
</pre>

<p>mounts volume 0 on UBI device 0 to <code>/mnt/ubifs</code>, and</p>

<pre>
$ mount -t ubifs ubi0:rootfs /mnt/ubifs
</pre>

<p>mounts "rootfs" volume of UBI device 0 to <code>/mnt/ubifs</code> ("rootfs"
is volume name). This method of specifying UBI volume is more preferable
because it does not depend on volume number.</p>

<p>Note, if <code>X</code> is not specified, UBIFS uses 0, i.e.,
"<code>ubi0:rootfs</code>" and "<code>ubi:rootfs</code>" are
equivalent.</p>

<p>Some environments like busybox are confused by the ":" delimiter (e.g.,
<code>ubi:rootfs</code>) and "!" may be used instead (e.g.,
<code>ubi!rootfs</code>).</p>

<p>The following is an example of the kernel boot arguments to attach
<code>mtd0</code> to UBI and mount volume "rootfs":</p>

<pre>
ubi.mtd=0 root=ubi0:rootfs rootfstype=ubifs
</pre>

<p>Please, see <a href="ubi.html#L_attachmtd">this</a> section for
information about how to create UBI devices and
<a href="ubi.html#L_mkvol">this</a> section for information about how to create
UBI volumes.</p>



<h2><a name="L_mkfubifs">How to create an UBIFS image?</a></h2>

<p>Creating UBIFS images might be a little trickier than creating JFFS2 images.
First of all, you have to understand that UBIFS works on top of UBI which works
on top or MTD which basically represents your raw flash. This means, that if
you need to create an image which would be flashed to the raw flash, you should
first create an UBIFS image, than UBI image. In other words, the process has 2
steps.</p>

<p>However, as you may know from <a href="../doc/ubi.html#L_volupdate">here</a>,
UBI allows to update volumes and there is an
<a href="../doc/ubi.html#L_usptools"><code>ubiupdatevol</code></a> utility
which may be used for this purposes. So you may update UBI volumes on your
running system as well. In this case, you only need UBIFS image, and you do not
have to make the UBI image, i.e., the process has only 1 step in this case.</p>

<p>So, there are 2 utilities:</p>
<ul>
	<li><a href="../doc/ubifs.html#L_usptools"><code>mkfs.ubifs</code></a>
	which creates UBIFS images;</li>
	<li><a href="../doc/ubi.html#L_usptools"><code>ubinize</code></a>
	which creates UBI images.</li>
</ul>

<p>And depending on the needs you use either <code>mkfs.ubifs</code> or
<code>mkfs.ubifs</code> plus <code>ubinize</code>. Choose the former if you are
going to upload the update UBIFS image on your target and then update the UBI
volume using <code>ubiupdatevol</code>. Choose the latter if you are going to
flash the image to raw flash, e.g., at the factory.</p>

<p>The UBI and UBIFS images depend on parameters of the flash they are going to
be used on. Namely, you have to know the following characteristics of the flash
before creating images:</p>

<ul>
	<li>flash size;</li>
	<li>physical eraseblock size;</li>
	<li>minimum flash input/output unit size;</li>
	<li>for NAND flashes, sub-page size;</li>
	<li>logical eraseblock size.</li>
</ul>

<p>And optionally, you should decide which compression algorithm you would want
to use for this file-system. UBIFS supports zlib and LZO (default) at the
moment. Generally, zlib compresses better, but it is slower on both compression
and decompression. So this is a trade-off between space savings and speed. The
best idea is to try both and choose the one which is more appropriate for you.
But if flash space is not a big issue, it is recommended to use LZO.
Alternatively, the compression may be switched off. See "<code>-x</code>"
option of the <code>mkfs.ubifs</code> utility.</p>

<p>There are other advanced file-system and UBI characteristics which may be
altered with the tools. Use them only if you understand what they do.</p>

<p>The below example demonstrates how to create an UBI/UBIFS image for a 256MiB
SLC OneNAND flash chip with 128KiB physical eraseblocks, 2048 bytes NAND pages, and
which supports 4 sub-pages (this means that it allows to do 4x512 bytes writes
to the same NAND page, which is quite typical for SLC flashes). The resulting
image will have one UBI volume storing UBIFS file-system.</p>

<pre>
$ mkfs.ubifs -r root-fs -m 2048 -e 129024 -c 2047 -o ubifs.img
$ ubinize -o ubi.img -m 2048 -p 128KiB -s 512 ubinize.cfg
</pre>

<p>where <code>ubinize.cfg</code> contains:</p>

<pre>
$ cat ubinize.cfg
[ubifs]
mode=ubi
image=ubifs.img
vol_id=0
vol_size=200MiB
vol_type=dynamic
vol_name=rootfs
vol_alignment=1
vol_flags=autoresize
</pre>

<p>Some comments about what the options mean:</p>

<ul>
	<li><code>-r root-fs</code>: tells <code>mkfs.ubifs</code> to create an
	UBIFS image which would have identical contents as the local
	<code>root-fs</code> directory has;</li>

	<li><code>-m 2048</code>: tells <code>mkfs.ubifs</code> that the minimum
	input/output unit size of the flash this UBIFS image is created for is
	2048 bytes;</li>

	<li><code>-e 129024</code>: logical eraseblock size of the UBI volume
	this image is created for;</li>

	<li><code>-c 2047</code>: specifies maximum file-system size in logical
	eraseblocks; this means that it will be possible to use the resulting
	file-system on volumes up to this size (less or equivalent); so in this
	particular case, the resulting FS may be put on volumes up to about
	251MiB (129024 multiplied by 2047);</li>

	<li><code>-p 128KiB</code>: tells <code>ubinize</code> that physical
	eraseblock size of the flash chip the UBI image is created for is
	128KiB (128 * 1024 bytes);</li>

	<li><code>-s 512</code>: tells <code>ubinize</code> that the flash
	supports sub-pages and sub-page size is 512 bytes; <code>ubinize</code>
	will take this into account and put the VID header to the same NAND
	page as the EC header.</li>
</ul>

<p>The <code>ubinize</code> utility requires volumes description file which has
standard <code>.ini</code> file syntax. One UBI image may contain many UBI
volumes with different characteristics and it is difficult to invent a nice
command-line interface for specifying those characteristics. This is why the
utility requires the volumes description file.</p>

<p>The example configuration file tells <code>ubinize</code> to create an UBI
image which has a singe 200MiB dynamic volume with ID 0, name "rootfs", and
alignment 1. The configuration file also sets the "autoresize" volume flag,
which means that the volume will be automatically enlarged by UBIFS to have
the maximum possible size when it runs for the first time. See
<a href="../doc/ubi.html#L_autoresize">here</a> for more information about what
is the auto-resize trick.</p>

<p>Run <code>ubinize -h</code> and <code>mkfs.ubifs -h</code> for more
information and for more possibilities to tweak images.</p>

<p>Here is one more example for a 32MiB NOR flash with 128KiB physical
eraseblock size.</p>

<pre>
$ mkfs.ubifs -r root-fs -m 1 -e 130944 -c 255 -o ubifs.img
$ ubinize -o ubi.img -m 1 -p 128KiB ubinize.cfg
</pre>

<p>where <code>ubinize.cfg</code> contains:</p>

<pre>
$ cat ubinize.cfg
[ubifs]
mode=ubi
image=ubifs.img
vol_id=0
vol_size=30MiB
vol_type=dynamic
vol_name=rootfs
vol_alignment=1
vol_flags=autoresize
</pre>

<p>And one more example for a 512MiB MLC NAND flash with 128KiB physical
eraseblock size, 2048 bytes NAND page size and no sub-page write
support.</p>

<pre>
$ mkfs.ubifs -r root-fs -m 2048 -e 126976 -c 4095 -o ubifs.img
$ ubinize -o ubi.img -m 2048 -p 128KiB ubinize.cfg
</pre>

<p>where <code>ubinize.cfg</code> contains:</p>

<pre>
$ cat ubinize.cfg
[ubifs]
mode=ubi
image=ubifs.img
vol_id=0
vol_size=450MiB
vol_type=dynamic
vol_name=rootfs
vol_alignment=1
vol_flags=autoresize
</pre>



<h2><a name="L_find_lebsz">How to find out LEB size, sub-page size, etc?</a></h2>

<p>When creating UBI/UBIFS images it is necessary to know:</p>
<ul>
	<li>physical eraseblock size;</li>
	<li>minimum input/output unit size;</li>
	<li>sub-page size;</li>
	<li>logical eraseblock size.</li>
</ul>

<p>Physical eraseblock (PEB) size should probably be found out in the flash
manual.</p>

<p>Minimum I/O unit size is NAND page size in case of NAND flash and should
also be found out in the flash manual (it is 512, 2048 or 4096 at some modern
NANDs). For NOR flashes it is 1, unless you have a (rare) ECC-NOR flash which
may have 16 byte minimal I/O unit size.</p>

<p>Sub-page size is relevant only for some NAND flashes which allow several
(usually 2 or 4) writes to the same NAND page. For example, many SLC NAND
flashes have this. UBI utilizes this feature if it is available to waste less
flash space. Typically, sub-page size if 256 in case of 512 bytes NAND page and
512 in case of 2048 bytes NAND pages. MLC NAND flashes typically have no
sub-pages.</p>

<p>Note, sub-page is an MTD term, but this is also referred to as "NOP" which
stands for "number of partial programs". So NOP1 NAND flashes have no sub-pages
(or you may treat this as sub-page size is equivalent to NAND page size),
NOP 2 NAND flashes have 2 sub-pages (half a NAND page each), NOP 4 flashes
have 4 sub-pages (quarter of a NAND page each).</p>

<p>Logical eraseblock (LEB) size is basically determined by the above 3
parameters. Here are the most typical configurations:</p>
<ul>
	<li>NOR flash with 1 byte min. I/O unit size: LEB size is PEB size
	minus 128;</li>
	<li>NAND flash with 512 byte NAND page and 265 byte sub-page: LEB size
	is PEB size minus 512;</li>
	<li>NAND flash with 2048 byte NAND page and 512 byte sub-page: LEB size
	is PEB size minus 2048;</li>
	<li>NAND flash with 2048 byte NAND page and no sub-page: LEB size
	is PEB size minus 4096.</li>
</ul>

<p>Please, refer <a href="../doc/ubi.html#L_overhead">this</a> section for
additional information.</p>

<p>Unfortunately, MTD does not expose information via sysfs and it is a bit
tricky to find the above characteristics out for an existing MTD device (one
would need to use an <code>ioctl</code>). Moreover, the sub-page size is not
exposed to the user-space at all (just because nobody implemented this).</p>

<p>The easiest way to find this out is to attach your MTD device to UBI and
glance to the syslog/dmesg output. The newest UBI prints something like
this:</p>

<pre>
UBI: physical eraseblock size:   131072 bytes (128 KiB)
UBI: logical eraseblock size:    129024 bytes
UBI: smallest flash I/O unit:    2048
UBI: sub-page size:              512
</pre>

<p>Note, if sup-page size was not printed, it does not exist. Older UBI
implementation do not print sub-page size, but they print VID header
offset, which is by default equivalent to sub-page size:</p>

<pre>
UBI: VID header offset:          512 (aligned 512)
</pre>



<h2><a name="L_emptyflash">Is it OK to mount empty UBI volumes?</a></h2>

<p>Yes, it is OK to mount empty UBI volumes, i.e. the volumes which
contain only 0xFF bytes. In this case UBIFS formats the media automatically
with default parameters (journal size, compression, etc). But generally, this
feature should have limited use, and a proper UBIFS image should
preferably be flashed created
(see <a href="ubifs.html#L_mkfubifs">this</a> section).</p>

<p>Note, UBI has similar property and it automatically formats the flash media
if it is empty (see <a href="../faq/ubi.html#L_format_mtd"> here</a>). So if
there is an <code>mtd0</code> M`TD device, the following will work:</p>

<pre>
# Wipe the MTD device out. Note, we could use flash_eraseall, but we do not
# want to loose erase counters
ubiformat /dev/mtd0

# Load UBI module
modprobe ubi

# Attach mtd0 to UBI - UBI will detect that the MTD device is
# empty and automatically format it. This command will also create
# UBI device 0 and udev should create /dev/ubi0 node
ubiattach /dev/ubi_ctrl -m 0

# Create an UBI volume - the created volume will be empty
ubimkvol /dev/ubi0 -N test_volume -s 10MiB

# Mount UBIFS - it will automatically format the empty volume
mount -t ubifs ubi0:test_volume /mnt/ubifs
</pre>

<p>It is also possible to wipe out an existing UBIFS volume represented
by <code>/dev/ubi0_0</code> using the following command:</p>

<pre>
ubiupdatevol /dev/ubi0_0 -t
</pre>



<h2><a name="L_ubifs_nandsim">How to use UBIFS with nandsim?</a></h2>

<p>The same way as with any MTD device. Here is an example of how to load
<code>nandsim</code>, create an UBI volume and mount it.</p>

<pre>
# Create an 256MiB emulated NAND flash
modprobe nandsim first_id_byte=0x20 second_id_byte=0xaa \
                 third_id_byte=0x00 fourth_id_byte=0x15

# MTD is not LDM-enabled and udev does not create device
# MTD device nodes automatically, so create /dev/mtd0
mknod /dev/mtd0 c 90 0

# Load UBI module and attach mtd0
modprobe ubi mtd=0

# Create a 200MiB UBI volume with name "ubifs-vol"
ubimkvol /dev/ubi0 -N ubifs-vol -s 200MiB

# Mount UBIFS
mount -t ubifs ubi0:ubifs-vol /mnt/ubifs
</pre>

<p>For more information about nandsim see
<a href="nand.html#L_nand_nandsim">here</a>.</p>


<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
