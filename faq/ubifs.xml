<PAGE>
<VAR match="VAR_ORIGIN" replace="../" />
<VAR match="VAR_CVSID" replace="Last updated: 27 Oct 2008, dedekind"/>
<INCLUDE file="../inc/header.tmpl" />

<VAR match="VAR_SEL_FAQ" replace="selected" />
<VAR match="VAR_SEL_UBIFS" replace="selected" />
<PARSE file="../menu1.xml" />

<INCLUDE file="../inc/content.tmpl" />

<h1>UBIFS FAQ and HOWTO</h1>

<h2>Table of contents</h2>
<ol>
	<li><a href="ubifs.html#L_enable_ubifs">How do I enable UBIFS?</a></li>
	<li><a href="ubifs.html#L_ubifs_mlc">May UBIFS be used on MLC NAND flash?</a></li>
	<li><a href="ubifs.html#L_mount_ubifs">How do I mount UBIFS?</a></li>
	<li><a href="ubifs.html#L_mkfubifs">How do I create an UBIFS image?</a></li>
	<li><a href="ubifs.html#L_emptyflash">May an empty UBI volume be mounted?</a></li>
	<li><a href="ubifs.html#L_max_leb_cnt">What is the purpose of -c (--max-leb-cnt) mkfs.ubifs option?</a></li>
	<li><a href="ubifs.html#L_why_ubiformat">Why do I have to use ubiformat?</a></li>
	<li><a href="ubifs.html#L_mkfs_ubifs_comp">How do I compile mkfs.ubifs?</a></li>
	<li><a href="ubifs.html#L_favor_lzo">What is "favor LZO" compression?</a></li>
	<li><a href="ubifs.html#L_loop_mount">Can UBIFS mount loop-back devices?</a></li>
	<li><a href="ubifs.html#L_atomic_change">How do I change a file atomically?</a></li>
	<li><a href="ubifs.html#L_atime">Does UBIFS support atime?</a></li>
	<li><a href="ubifs.html#L_nfs">Does UBIFS support NFS?</a></li>
	<li><a href="ubifs.html#L_slow_when_full">Does UBIFS become slower when it is full?</a></li>
	<li><a href="ubifs.html#L_df_report">Why <code>df</code> reports too few free space?</a></li>
	<li><a href="ubifs.html#L_comproff">How do I disable compression?</a></li>
	<li><a href="ubifs.html#L_ubifs_nandsim">How do I use UBIFS with nandsim?</a></li>
	<li><a href="ubifs.html#L_ubifs_extract">How do I extract files from an UBI/UBIFS image?</a></li>
	<li><a href="ubifs.html#L_powercut">Is UBIFS tolerant to power-cuts?</a></li>
	<li><a href="ubifs.html#L_smaller_jrn">I need more space - should I make UBIFS journal smaller?</a></li>
	<li><a href="ubifs.html#L_empty_file">Why is my file empty after an unclean reboot?</a></li>
	<li><a href="ubifs.html#L_end_hole">Why does my file have zeroes at the end after an unclean reboot?</a></li>
	<li><a href="ubifs.html#L_bgt_thread">What does the "ubifs_bgt0_0" thread do?</a></li>
	<li><a href="ubifs.html#L_sudden_ro">UBIFS suddenly became read-only - what is this?</a></li>
	<li><a href="ubifs.html#L_detect_ro">How do I detect if UBIFS became read-only?</a></li>
	<li><a href="ubifs.html#L_lebsz_mismatch">I get: "validate_sb: LEB size mismatch: 129024 in superblock, 126976 real"</a></li>
	<li><a href="ubifs.html#L_pdflush_blocked">I get: "INFO: task pdflush:110 blocked for more than 120 seconds"</a></li>
	<li><a href="ubifs.html#L_few_lebs">I get: "init_constants_early: too few LEBs (12), min. is 17"</a></li>
	<li><a href="ubifs.html#L_study_ubifs">I want to study UBIFS - any recommendations?</a></li>
	<li><a href="ubifs.html#L_how_debug">How do I debug UBIFS?</a></li>
</ol>



<h2><a name="L_enable_ubifs">How do I enable UBIFS?</a></h2>

<p>Since UBIFS works on top of UBI, you have to enable UBI first (see
<a href="ubi.html#L_enable_ubi">here</a>).</p>

<p>Then in the Linux configuration menu, go to "<b>File systems</b>" ->
"<b>Miscellaneous filesystems</b>", and mark the
"<b>UBIFS file system support</b>" check-box. UBIFS may be either compiled into
the kernel or be built as a kernel module.</p>



<h2><a name="L_ubifs_mlc">May UBIFS be used on MLC NAND flash?</a></h2>

<p>UBIFS authors never tested UBI/UBIFS on MLC flash devices. Let's consider
some specific aspects of MLC NAND flashes:</p>

<ul>
	<li>MLC NAND flashes are more "faulty" than SLC, so they use stronger
	ECC codes which occupy whole OOB area; this is not a problem
	for UBI/UBIFS, because neither UBIFS nor UBI use OOB area;</li>

	<li>when the data are written to an eraseblock, they have to be written
	sequentially, from the beginning of the eraseblock to the end of it;
	this is also not a problem because it is exactly what UBI and UBIFS do
	(see also <a href="ubi.html#L_restrict">this</a> section);</li>

	<li>MLC flashes have rather short eraseblock life-cycle of just few
	thousand of erase cycles; and this is not a problem, because UBI
	uses deterministic wear-leveling algorithm
	(see <a href="ubi.html#L_mlc">this</a> section);</li>

	<li>MLC flashes have so called "read-disturb" property, which means
	that NAND page read operation may introduce a permanent bit change; the
	ECC code would fix it, but more read operations may introduce more bit
	changes and soft ECC errors may turn into hard ECC errors; well, even
	SLC NAND flashes have this property, but the probability of bit changes
	is much lower in SLC NAND; however, this should not be a problem
	because UBI is doing scrubbing; in other words, once UBI notices that
	there is a correctable bit-flip in an eraseblock, it moves the contents
	of this physical eraseblock to a different physical eraseblocks, and
	re-maps corresponding logical eraseblocks to the new physical
	eraseblock; so UBI refreshes the data and gets rid of bit-flips, thus
	improving data integrity.</li>
</ul>

<p>However, there are 2 other aspects which may need closer attention. The
first one is the "paired pages" problem (e.g., see
<a href="http://www.celinux.org/elc08_presentations/ELC2008 Filesystem support on Multi Level Cell flash in open source.ppt">this</a>
Power Point presentation). Namely, MLC NAND pages are coupled in a sense
that if you cut power while writing to a page, you corrupt not only this page,
but also one of the previous pages which is paired with the current one. For
example, pages 0 and 3, 1 and 4, 2 and 5, 3 and 6 in and so on (in the same
eraseblock) may be paired (page distance is 4, but there may be other
distances). So if you write data to, say, page 3 and cut the power, you may
end up with corrupted data in page 0. UBIFS is not ready to handle this
problem at the moment and this needs some work.</p>

<p>The second aspect is the "program-disturb" MLC NAND property (see
<a href="http://www.klabs.org/richcontent/MemoryContent/nvmt_symp/nvmts_2002/docs/12/12_dan_p.pdf">here</a>),
which means that if you program an MLC NAND page, you may introduce a bit-change
in a different NAND page. Well, the bit change will be fixed by ECC, but with time
the changes may accumulate and become unfixable. Current UBI bit-flip handling
only partially helps here, because it is passive, which means that UBI notices
bit-flips only when performing users read requests, so if you never read the
MLC NAND area which accumulates bit-flips, UBI will never notice this. However,
it is not difficult to implement a kind of "flash crawler" which would read the
flash in background from time to time and make UBI notice and fix
bit-flips.</p>

<p>Nevertheless, UBIFS authors never worked with real raw MLC NAND flash, so we
might have missed or misinterpreted some MLC NAND aspects. Any feed-back is
appreciated.</p>



<h2><a name="L_mount_ubifs">How do I mount UBIFS?</a></h2>

<p>The modern way of mounting UBIFS is mounting UBI volume character device
nodes, e.g.:</p>

<pre>
$ mount -t ubifs /dev/ubi0_0 /mnt/ubifs
</pre>

<p>will mount UBIFS to UBI volume 0 on UBI device 0. This is the easiest way to
mount UBIFS, but it is supported only in kernels starting from version
<code>2.6.32</code>. The UBIFS back-port trees (see
<a href="../doc/ubifs.html#L_source">here</a>) also support this mounting
method.</p>

<p>The old method is to use device-less mount, just like <code>procfs</code> or
<code>sysfs</code>. The volume to mount is specified using <code>ubiX_Y</code>
or <code>ubiX:NAME</code> syntax, where</p>

<ul>
	<li><code>X</code> - UBI device number;</li>
	<li><code>Y</code> - UBI volume number;</li>
	<li><code>NAME</code> - UBI volume name.</li>
</ul>

<p>For example,</p>

<pre>
$ mount -t ubifs ubi1_0 /mnt/ubifs
</pre>

<p>mounts volume 0 on UBI device 1 to <code>/mnt/ubifs</code>, and</p>

<pre>
$ mount -t ubifs ubi0:rootfs /mnt/ubifs
</pre>

<p>mounts "rootfs" volume of UBI device 0 to <code>/mnt/ubifs</code> ("rootfs"
is volume name). This method of specifying UBI volume is more preferable
because it does not depend on volume number.</p>

<p>Note, if <code>X</code> is not specified, UBIFS assumes 0, i.e.,
"<code>ubi0:rootfs</code>" and "<code>ubi:rootfs</code>" are
equivalent.</p>

<p>Some environments like busybox are confused by the ":" delimiter (e.g.,
<code>ubi:rootfs</code>) and "!" may be used instead (e.g.,
<code>ubi!rootfs</code>).</p>

<p>In order to mount UBIFS as the root file system, you have to compile UBIFS
into the kernel (instead of compiling it as a kernel module) and specify proper
kernel boot arguments and make the kernel mount UBIFS on boot. You have to
provide the boot arguments to attach the UBI device (using the
<code>ubi.mtd=</code> argument, see <a href="ubi.html#L_attachmtd">here</a>).
Then you should tell the kernel the file system type by providing the
<code>rootfstype=</code> argument. And finally, you should specify which UBI
volume has to be mounted on boot using the <code>root=</code> argument.
The volume is specified the same way as described above (<code>ubiX_Y</code>
or <code>ubiX:NAME</code>).</p>

<p>The following is an example of the kernel boot arguments to attach
<code>mtd0</code> to UBI and mount UBI volume "rootfs":</p>

<pre>
ubi.mtd=0 root=ubi0:rootfs rootfstype=ubifs
</pre>

<p>Please, see <a href="ubi.html#L_attachmtd">this</a> section for
information about how to create UBI devices and
<a href="ubi.html#L_mkvol">this</a> section for information about how to create
UBI volumes.</p>



<h2><a name="L_mkfubifs">How do I create an UBIFS image?</a></h2>

<p>Creating UBIFS images might be a little trickier than creating JFFS2 images.
First of all, you have to understand that UBIFS works on top of UBI which works
on top or MTD which basically represents your raw flash. This means, that if
you need to create an image which should be flashed to the raw flash, you should
first create an UBIFS image, then UBI image. In other words, the process has 2
steps.</p>

<p>However, as described <a href="../doc/ubi.html#L_volupdate">here</a>,
UBI has a volume update facility and there is an
<a href="../doc/ubi.html#L_usptools"><code>ubiupdatevol</code></a> utility
for this. So you may update UBI volumes on your running system as well.
In this case you only need an UBIFS image, and you do not have to make the
UBI image, i.e., the process has only 1 step in this case.</p>

<p>Moreover, you may even build the image on your target system and write
it directly to your UBI volume - just specify the volume character device
as the output file to <code>mkfs.ubifs</code>.</p>

<p>So, there are 2 utilities:</p>
<ul>
	<li><a href="../doc/ubifs.html#L_usptools"><code>mkfs.ubifs</code></a>
	which creates UBIFS images;</li>
	<li><a href="../doc/ubi.html#L_usptools"><code>ubinize</code></a>
	which creates UBI images out of UBIFS images.</li>
</ul>

<p>And depending on the needs you use either <code>mkfs.ubifs</code> or
<code>mkfs.ubifs</code> plus <code>ubinize</code>. Choose the former if you are
going to upload the update UBIFS image on your target and then update the UBI
volume using <code>ubiupdatevol</code>. Choose the latter if you are going to
flash the image to raw flash, e.g., at the factory.</p>

<p>The UBI and UBIFS images depend on parameters of the flash they are going to
be used on. Namely, you have to know the following characteristics of the flash
before creating images:</p>

<ul>
	<li>MTD partition size;</li>
	<li>flash physical eraseblock size;</li>
	<li><a href="../doc/ubi.html#L_min_io_unit">minimum flash input/output
	unit</a> size;</li>
	<li>for NAND flashes - <a href="../doc/ubi.html#L_subpage">sub-page</a>
	size;</li>
	<li>logical eraseblock size.</li>
</ul>

<p>If you run Linux kernel version <code>2.6.30</code> or higher, or you
have the MTD sysfs support back-ported, then you may find all these parameters
by running the <a href="../doc/ubi.html#L_usptools"><code>mtdinfo</code></a>
tool with <code>-u</code> parameter. Of course, the tool has to be run on
the target system.</p>

<p>Please, refer <a href="ubi.html#L_find_min_io_size">this</a> for more
information about how to find these parameters.</p>

<p>And optionally, you should decide which compression algorithm you want
to use for the file-system. UBIFS supports zlib and LZO (default) at the
moment (see <a href="../doc/ubifs.html#L_compression">here</a>). There is also
<a href="ubifs.html#L_favor_lzo">favor LZO</a> <code>mkfs.ubifs</code>
compression method. Generally, zlib compresses better, but it is slower on both
compression and decompression. So this is a trade-off between space savings and
speed. The best idea is to try both and choose the one which is more appropriate
for you. <a href="../misc.html#L_ubifs_compr">Here</a> you may find compression
test results for ARM platform. Alternatively, the compression may be switched
off. See "<code>-x</code>" option of the <code>mkfs.ubifs</code> utility.</p>

<p>There are other advanced file-system and UBI characteristics which may be
altered with various options of the tools. Use them only if you understand what
they do.</p>

<p>The below example demonstrates how to create an UBI/UBIFS image for a 256MiB
SLC OneNAND flash chip with 128KiB physical eraseblocks, 2048-byte NAND pages,
and 512-byte sub-pages (this means that it allows to do 4x512 bytes
writes to the same NAND page, which is quite typical for SLC flashes). The
resulting image will have only one UBI volume storing UBIFS file-system.</p>

<pre>
$ mkfs.ubifs -q -r root-fs -m 2048 -e 129024 -c 2047 -o ubifs.img
$ ubinize -o ubi.img -m 2048 -p 128KiB -s 512 ubinize.cfg
</pre>

<p>where <code>ubinize.cfg</code> contains:</p>

<pre>
$ cat ubinize.cfg
[ubifs]
mode=ubi
image=ubifs.img
vol_id=0
vol_size=200MiB
vol_type=dynamic
vol_name=rootfs
vol_flags=autoresize
</pre>

<p>Some comments about what the options mean:</p>

<ul>
	<li><code>-r root-fs</code>: tells <code>mkfs.ubifs</code> to create an
	UBIFS image which would have identical contents as the local
	<code>root-fs</code> directory;</li>

	<li><code>-m 2048</code>: tells <code>mkfs.ubifs</code> that the minimum
	input/output unit size of the flash this UBIFS image is created for is
	2048 bytes (NAND page in this case);</li>

	<li><code>-e 129024</code>: logical eraseblock size of the UBI volume
	this image is created for;</li>

	<li><code>-c 2047</code>: specifies maximum file-system size in logical
	eraseblocks; this means that it will be possible to use the resulting
	file-system on volumes up to this size (less or equivalent); so in this
	particular case, the resulting FS may be put on volumes up to about
	251MiB (129024 multiplied by 2047); See
	<a href="ubifs.html#L_max_leb_cnt">this</a> section for more
	details.</li>

	<li><code>-p 128KiB</code>: tells <code>ubinize</code> that physical
	eraseblock size of the flash chip the UBI image is created for is
	128KiB (128 * 1024 bytes);</li>

	<li><code>-s 512</code>: tells <code>ubinize</code> that the flash
	supports sub-pages and sub-page size is 512 bytes; <code>ubinize</code>
	will take this into account and put the VID header to the same NAND
	page as the EC header.</li>
</ul>

<p>The <code>ubinize</code> utility requires volumes description file. Please,
refer <a href="ubi.html#L_ubi_mkimg">this</a> section for more
<code>ubinize</code> usage information.</p>

<p>In the example, the <code>ubinize.cfg</code> file tells <code>ubinize</code>
to create an UBI image which has a singe 200MiB dynamic volume with ID 0, and
name "rootfs". The configuration file also sets the "autoresize" volume flag,
which means that the volume will be automatically enlarged by UBI to have
the maximum possible size when it runs for the first time. See
<a href="../doc/ubi.html#L_autoresize">here</a> for more information about what
the auto-resize feature is. And because we specified "<code>-c 2047</code>"
<code>mkfs.ubifs</code> option, UBIFS will also automatically re-size on the
first mount. So the end result will be that you have one single volume of
maximum possible size, and UBIFS spans whole volume.</p>

<p>Please, run <code>ubinize -h</code> and <code>mkfs.ubifs -h</code> for more
information and for more possibilities to tweak the generated images.</p>

<p>Here is one more example for a 32MiB NOR flash with 128KiB physical
eraseblock size.</p>

<pre>
$ mkfs.ubifs -q -r root-fs -m 1 -e 130944 -c 255 -o ubifs.img
$ ubinize -o ubi.img -m 1 -p 128KiB ubinize.cfg
</pre>

<p>where <code>ubinize.cfg</code> contains:</p>

<pre>
$ cat ubinize.cfg
[ubifs]
mode=ubi
image=ubifs.img
vol_id=0
vol_size=30MiB
vol_type=dynamic
vol_name=rootfs
vol_alignment=1
vol_flags=autoresize
</pre>

<p>And one more example for a 512MiB MLC NAND flash with 128KiB physical
eraseblock size, 2048 bytes NAND page size and no sub-page write
support.</p>

<pre>
$ mkfs.ubifs -q -r root-fs -m 2048 -e 126976 -c 4095 -o ubifs.img
$ ubinize -o ubi.img -m 2048 -p 128KiB ubinize.cfg
</pre>

<p>where <code>ubinize.cfg</code> contains:</p>

<pre>
$ cat ubinize.cfg
[ubifs]
mode=ubi
image=ubifs.img
vol_id=0
vol_size=450MiB
vol_type=dynamic
vol_name=rootfs
vol_alignment=1
vol_flags=autoresize
</pre>

<p>To flash UBI images, please use the <code>ubiformat</code> utility
(see <a href="ubi.html#L_flash_img">here</a>) or use/implement a
<b>proper</b> custom flasher program.
(<a href="../doc/ubi.html#L_flasher_algo">here</a> you may find some
hints). Please, read
<a href="ubifs.html#L_why_ubiformat">this</a> section for more information
why you should use <code>ubiformat</code>.</p>



<h2><a name="L_emptyflash">Is it OK to mount empty UBI volumes?</a></h2>

<p>Yes, it is OK to mount empty UBI volumes, i.e. the volumes which
contain only 0xFF bytes. In this case UBIFS formats the media automatically
with default parameters (journal size, compression, etc). But generally, this
feature should have limited use (developing, debugging), and a proper UBIFS
image should preferably be created and flashed
(see <a href="ubifs.html#L_mkfubifs">this</a> section).</p>

<p>Note, UBI has similar property and it automatically formats the flash media
if it is empty (see <a href="ubi.html#L_format_mtd">here</a>). So if
there is an <code>mtd0</code> MTD device, the following will work:</p>

<pre>
# Wipe the MTD device out. Note, we could use flash_eraseall, but we do not
# want to lose erase counters
ubiformat /dev/mtd0

# Load UBI module
modprobe ubi

# Attach mtd0 to UBI - UBI will detect that the MTD device is
# empty and automatically format it. This command will also create
# UBI device 0 and udev should create /dev/ubi0 node
ubiattach /dev/ubi_ctrl -m 0

# Create an UBI volume - the created volume will be empty
ubimkvol /dev/ubi0 -N test_volume -s 10MiB

# Mount UBIFS - it will automatically format the empty volume
mount -t ubifs ubi0:test_volume /mnt/ubifs
</pre>

<p>It is also possible to wipe out an existing UBIFS volume represented
by <code>/dev/ubi0_0</code> using the following command:</p>

<pre>
ubiupdatevol /dev/ubi0_0 -t
</pre>



<h2><a name="L_max_leb_cnt">
	What is the purpose of -c (--max-leb-cnt) mkfs.ubifs option?
</a></h2>

<p>It is a form of specifying file-system size. But instead of specifying the
exact file-system size, this option defines the <i>maximum</i> file-system
size (more strictly, maximum UBI volume size). For example, if you use
<code>--max-leb-cnt=200</code> <code>mkfs.ubifs</code> option, than it will be
possible to put the resulting image to smaller UBI volume and mount it. But if
the image is put to a larger UBI volume, the file-system will anyway take only
first 200 LEBs, and the rest of the volume will be wasted.</p>

<p>Note, the <code>--max-leb-cnt</code> option does not affect the size of the
resulting image file, which depends only on the amount of data in the
file-system. <code>mkfs.ubifs</code> just writes the <code>--max-leb-cnt</code>
value to the file-system superblocks.</p>

<p>This feature is quite handy on NAND flashes, because they have random amount
of initial bad eraseblocks (marked as bad in production). This means, that
different devices may have slightly different volume sizes (especially if the
UBI <a href="../doc/ubi.html#L_autoresize">auto-resize</a> feature is used). So
you may specify the maximum possible volume size and this will guarantee that
the image will work on all devices, irrespectively on the amount of initial bad
eraseblocks.</p>

<p>Fundamentally, <code>mkfs.ubifs</code> has to know file-system size because
UBIFS maintains and stores per-LEB information (like amount of dirty and free
space in each LEB) in so-called LPT area on the media. So obviously, the size of
this area depends on the total amount of LEBs, i.e. on the volume size. Note,
various characteristics of the LPT B-tree depend on the LPT area size, e.g., we
use less bits in LPT tree keys of smaller LPT area. So do not use unnecessarily
large <code>--max-leb-cnt</code> value to achieve better performance.</p>



<h2><a name="L_loop_mount">Can UBIFS mount loop-back devices?</a></h2>

<p>Unfortunately not, because loop-back devices are block devices (backed by
regular files), while UBIFS works on top of UBI devices
(see <a href="../doc/ubifs.html#L_rednote">here</a>).</p>

<p>However, there is an unusual way to make UBIFS work with a file-backed
image using NAND simulator (see <a href="nand.html#L_nand_nandsim">here</a>).
If your image is not very big, then you can create a RAM-backed
<code>nandsim</code> MTD device, then copy your image to that emulated MTD
device. If the image is large and you do not have that much RAM, you can create
a file-backed <code>nandsim</code> MTD device using the <code>cache_file</code>
<code>nandsim</code> module option. Below is an example:</p>

<pre>
# Create a 1GiB emulated MTD device backed by regular file "my_image"
$ modprobe nandsim cache_file=my_image first_id_byte=0xec second_id_byte=0xd3 \
  third_id_byte=0x51 fourth_id_byte=0x95
</pre>

<p>See <a href="ubifs.html#L_ubifs_nandsim">here</a> for more instructions
about using UBIFS with nandsim.</p>



<h2><a name="L_favor_lzo">What is "favor LZO" compression?</a></h2>

<p>Starting from version <code>1.1</code>, the
<a href="../doc/ubifs.html#L_usptools"><code>mkfs.ubifs</code></a> utility
supports so-called "<i>favor LZO</i>" compression. This is not a new compression
algorithm, it is just a method of combining LZO and zlib compressors to balance
speed and compression ratio. A similar method exists in the
<code>mkfs.jffs2</code> utility, and we borrowed this idea from there.</p>

<p>As <a href="../doc/ubifs.html#L_compression">this</a> documentation section
highlights, zlib compressor provides better compression ratio comparing to
the LZO compressor, but it is considerably slower, especially on embedded
platforms which do not usually have powerful CPUs. The favor LZO compression
method makes it possible to use zlib compressor for data chunks which zlib may
compress much better than LZO, and to use LZO compressor for data chunks which
zlib compresses only slightly better than LZO. See
<a href="../misc.html#L_ubifs_compr">this</a> section for some favor LZO
experiment results on ARM platform.</p>

<p>Here is the favor LZO algorithm. Each 4KiB data chunk is compressed by both
zlib and LZO compressors. If zlib compresses at least 20% better than LZO, then
zlib is used for this data chunk. Otherwise, LZO is used. Very simple. The 20%
threshold is configurable via the "<code>-X</code> <code>mkfs.ubifs</code>
option, so you may make it 10% or anything else. Example:</p>

<pre>
$ mkfs.ubifs -q -r rootfs -m 2048 -e 129024 -c 2047 -x favor_lzo -X 5 -o ubifs.img
</pre>

<p>This command creates an UBIFS image containing the <code>rootfs</code>
directory, using favor LZO compression with threshold 5%. This means that if
a data chunk compresses at least 5% better with zlib, then
<code>mkfs.ubifs</code> uses zlib, otherwise it uses LZO.</p>

<p>So UBIFS images created with favor LZO compression will contain both LZO and
zlib-compressed data nodes. However, the default file-system compressor will be
LZO. This means, the kernel will use LZO compressor for all data. This is
because the favor LZO method is not implemented in-kernel, just because UBIFS
authors did not need it there. Of course you can mount the UBIFS images created
with the favor LZO compression method, and they will work fine. But if you write
a file to the UBIFS file-system, it will be compressed only by the LZO
compressor. So favor LZO is actually useful only for read-only files which are
not going to be over-written. However, it should be easy to implement favor LZO
in the kernel.</p>



<h2><a name="L_why_ubiformat">Why do I have to use ubiformat?</a></h2>

<p>The first obvious reason is that <code>ubiformat</code> preserves erase
counters, so you do not lose your wear-leveling information when flashing new
images.</p>

<p>The other reason is more subtle, and specific to NAND flashes which have
ECC calculation algorithm which produces ECC code not equivalent to all
<code>0xFF</code> bytes if the NAND page contains only <code>0xFF</code> bytes.
Consider an example.</p>

<ul>
	<li>We erase whole flash, so everything is <code>0xFF</code>'ed
	now.</li>

	<li>We write an UBI/UBIFS image to flash using
	<code>nandwrite</code>.</li>

	<li>Some eraseblocks in the UBIFS image may contain several empty NAND
	pages at the end, and UBIFS will write to them when it is run.</li>

	<li>The <code>nandwrite</code> utility writes whole image, and it
	explicitly writes <code>0xFF</code> bytes to those NAND pages.</li>

	<li>The ECC checksums are calculated for these <code>0xFF</code>'ed
	NAND pages and are stored in the OOB area. The ECC codes are not
	<code>0xFF</code>'ed. This is often the case for HW ECC calculation
	engines, and it is difficult to fix this. Normally, ECC codes should
	be <code>0xFF</code>'ed for such pages.</li>

	<li>When later UBIFS runs, it writes data to these NAND pages, which
	means that a new ECC code is calculated, and written on top of the
	existing one (unsuccessfully, of course). This may trigger an error
	straight away, but usually at this point no error is triggered.</li>

	<li>At some point UBIFS is trying to read from these pages, and gets
	and an ECC error (<code>-EBADMSG</code> = <code>-74</code>).</li>
</ul>

<p>In fewer words, <code>ubiformat</code> makes sure that every NAND page is
written once and only once after the erasure. If you use
<code>nandwrite</code>, some pages are written twice - once by
<code>nandwrite</code>, and once by UBIFS.</p>



<h2><a name="L_mkfs_ubifs_comp">How do I compile mkfs.ubifs?</a></h2>

<p>The <code>mkfs.ubifs</code> utility requires <i>zlib</i>, <i>lzo</i> and
<i>uuid</i> libraries. The former two are used for compressing the data, and the
latter one is used for generating <i>universally unique ID number</i> for the
file-system. In Fedora install <code>zlib-devel</code>, <code>lzo-devel</code>,
and <code>libuuid-devel</code>. Old Fedora distributions (Fedora 11 and
earlier) had the <i>uuid</i> library in the <code>e2fsprogs-devel</code>
package. In Debian install <code>zlib1g-dev</code>, <code>liblzo2-dev</code>
and <code>uuid-dev</code> packages.</p>

<p>Note, <a href="../faq/general.html#L_compile_mtd">this</a> section provides
information about other dependencies in the  <code>mtd-utils</code> tree.</p>



<h2><a name="L_atomic_change">How do I change a file atomically?</a></h2>

<p>Changing a file atomically means changing its contents in a way that unclean
reboots could not lead to any corruption or inconsistency in the file. The only
reliable way to do this in UBIFS (and in most of other file-systems, e.g. JFFS2
or ext3) is the following:</p>

<ul>
	<li>make a copy of the file;</li>
	<li>change the copy;</li>
	<li>synchronize the copy (see
	<a href="../doc/ubifs.html#L_writeback">here</a>);</li>
	<li>re-name the copy to the file (using the <code>rename()</code>
	<i>libc</i> function or the <code>mv</code> utility).</li>
</ul>

<p>Note, if a power-cut happens during the re-naming, the original file will be
intact because the re-name operation is atomic. This is a <code>POSIX</code>
requirement and UBIFS satisfies it.</p>

<p>Often applications do not do the third step - synchronizing the copy.
Although this is generally an application bug, the ext4 file-system
has a hack which makes sure the data of the copy hits the disk before the
re-name meta-data, which "fixes" buggy applications. However, UBIFS does not
have this feature, although we plan to implement it. Please, refer
<a href="../doc/ubifs.html#L_sync_exceptions">this</a> section.</p>



<h2><a name="L_atime">Does UBIFS support atime?</a></h2>

<p>No, it does not support atime. The authors think it is not very useful in
embedded world and did not implement this. Indeed most of the users do not
provably want the file-system doing inode updates every time they are read.</p>



<h2><a name="L_nfs">Does UBIFS support NFS?</a></h2>

<p>Not, it does not, which means you cannot export UBIFS file-system via NFS.
We did make an attempt to support NFS, but the support was not exactly correct
so it was dropped, and we have never find time to come back to that. Please,
refer <a href="http://marc.info/?l=linux-next&amp;m=121852228611051&amp;w=2">this tread</a>
for some more details. The original patch can also be found there.</p>



<h2><a name="L_slow_when_full">Does UBIFS become slower when it is full?</a></h2>

<p>Yes, UBIFS writes (but not reads) become slower when it is full or close to
be full. There are 2 main reasons for this:</p>

<ul>
	<li>Garbage Collection becomes slower, because the small pieces of
	dirty space are distributed all over the media, and UBIFS Garbage
	Collector has to move many eraseblocks to produce one free eraseblock;
	this is a fundamental reason and it exists in JFFS2 as well;</li>

	<li>The file-system becomes more synchronous; UBIFS buffers dirty data,
	but due to compression and some other factors like wasting small pieces
	of space at the end of eraseblocks, UBIFS does not exactly know how much
	space the buffered dirty data would take on the flash media, so it uses
	pessimistic calculations and assumes that the data are uncompressible.
	In many cases this is not true, but UBIFS has to assume
	worst-case scenario. So when all free space on the file-system is
	reserved for the buffered dirty data, but users want to write more,
	UBIFS forces write-back to actually write the buffered dirty data and
	see how much space will be available after that. Then UBIFS may allow
	new data to be written. Thus, it is obvious that the less free
	flash space is available, the less dirty data may be buffered, and
	the more synchronous the file-system becomes.</li>
</ul>

<li>Note, also slows down when it is close to being full, but UBIFS should be
better than JFFS2 in this respect (slow down less). This is because UBIFS
always chooses optimal LEBs to garbage-collect, while JFFS2 may choose random
eraseblocks.</li>



<h2><a name="L_df_report"> Why <code>df</code> reports too few free space?</a></h2>

<p>UBIFS flash space accounting is quite challenging and it is not always
possible to report accurate amount of free space. The <code>df</code> utility
usually reports <i>less</i> free space than users may actually write to the
file-system, but it <i>never</i> reports more space.</p>

<p>UBIFS cannot precisely predict how much data the user will
be able to write to the file-system. There are several reasons for this -
compression, write-back, space wastage at the end of logical eraseblocks,
garbage-collection, etc. Please, refer
<a href="../doc/ubifs.html#L_spaceacc">this</a> section for details.</p>

<p>Note, JFFS2 also has problems with free space predictions, but in average,
it reports much more accurate amount of free space. However, JFFS2 may lie and
report more free space than it actually has. For example, we experienced
situations when JFFS2 reported 8MiB free space, while we were able to write
only 2 MiB of data. This makes some user-space applications very unhappy.</p>

<p>UBIFS also lies, but it always report <i>less</i> space that user may
actually write. For example, it may report 2MiB of free space, but if you
start writing to it, may be able to write 4MiB there (even if you have
compression disabled).</p>

<p>Thus, the only way to find out <i>precise</i> amount of free space is to
fill up the file-system and see how much has been written. Try something like
this:</p>

<pre>
$ touch /mnt/ubifs/file
$ chattr -c /mnt/ubifs/file # Disable compression for this file
$ dd if=/dev/zero of=/mnt/ubifs/file bs=4096
</pre>

or

<pre>
# Presumably random data does not compress
dd if=/dev/urandom of=/mnt/ubifs/file bs=4096
</pre>

<p>and see the size of the file. And do not forget that some space is reserved
for the super-user (see <a href="../doc/ubifs.html#L_rootspace">here</a>), so
it is better to be the root.</p>

<p>UBIFS users should know that the more dirty cached FS data there are, the
less precise is the <code>df</code> report. Try to create a big file, and
look at the <code>df</code> report. Then synchronize the file-system (using the
<code>sync</code> command) and look at the <code>df</code> report again. You
should notice that <code>df</code> reports more free space after the
synchronization. Here is an example:</p>

<pre>
# Create a 64MiB uncompressible file
$ dd if=/dev/urandom of=/mnt/ubifs/file bs=8192 count=8192
$ df
Filesystem           1K-blocks      Used Available Use% Mounted on
ubi0:ubifs              117676     68880     43736  62% /mnt/ubifs

$ sync
$ df
Filesystem           1K-blocks      Used Available Use% Mounted on
ubi0:ubifs              117676     64304     48308  58% /mnt/ubifs
</pre>

<p>Notice that the amount of free space increased by 4%. However, that was an
uncompressible file. Here is a similar example, but which uses a file which
compresses well:</p>

<pre>
# Create a 64MiB file containing zeroes
$ dd if=/dev/zero of=/mnt/ubifs/file bs=8192 count=8192
$ df
Filesystem           1K-blocks      Used Available Use% Mounted on
ubi0:ubifs              117676     69312     43304  62% /mnt/ubifs

$ sync
$ df
Filesystem           1K-blocks      Used Available Use% Mounted on
ubi0:ubifs              117676      7052    105564   7% /mnt/ubifs
</pre>

<p>If instead of synchronizing the file-system you just watch how
the <code>df</code> report is changing, you will notice that the amount of free
space continuously grows until reaches its final value. This happens because the
kernel starts writing the dirty data back by time-out (5 sec by default) and
the amount of dirty data goes down, making the <code>df</code> report more
precise.</p>

<p>If you want to have as precise free space prediction as possible -
synchronize the file-system. This not only flushes dirty data to the media,
this also commits UBIFS journal, which improves free space prediction even
more. The other possibility is to mount UBIFS in synchronous mode using
<code>-o sync</code> mount option. However, it may perform not as well as in
asynchronous (default) mode.</p>

<p>It is also worth noting that the closer is UBIFS to being full, the less
accurate is free space reporting.</p>

<p>To conclude:</p>
<ul>
	<li>do not trust <code>df</code> free space reports;</li>
	<li><code>df</code> reports <i>less</i> free space in most cases;</li>
	<li>if <code>df</code> reports <code>X</code> bytes of free space, you
	are guaranteed to be able to write at least <code>X</code> bytes
	of data to a file, but usually more than <code>X</code> bytes;</li>
	<li>run <code>sync</code> to get the most accurate <code>df</code>
	report; alternatively, you may mount UBIFS in synchronous mode using
	<code>-o sync</code> mount option;</li>
	<li>read <a href="../doc/ubifs.html#L_spaceacc">this</a> section if you
	are curious why UBIFS has issues with <code>df</code>.</li>
</ul>



<h2><a name="L_comproff">How do I disable compression?</a></h2>

<p>UBIFS compression may be disabled for whole file system during the image
creation time using the "<code>-x none</code>" <a
href="ubifs.html#L_mkfubifs"><code>mkfs.ubifs</code></a> option. However,
if UBIFS compression is enabled, it may be disabled for individual files by
cleaning the inode <i>compression flag</i>:</p>

<pre>
$ chattr -c /mnt/ubifs/file
</pre>

<p>in <code>shell</code>, or</p>

<pre>
/* Get inode flags */
ioctl(fd, FS_IOC_GETFLAGS, &amp;flags);
/* Set "compression" flag */
flags &amp;= ~FS_COMPR_FL;
/* Change inode flags */
ioctl(fd, FS_IOC_SETFLAGS, &amp;flags);
</pre>

<p>in <code>C</code> programs. Similarly, if compression is disabled by
default, you may enable if for individual inodes by setting the compression
flag. Note, the code which uses the compression flag works fine on other Linux
file-systems, because the flag is just ignored in this case.</p>

<p>It might be a good idea to disable compression for say, <code>mp3</code> or
<code>jpeg</code> files which would anyway not compress and UBIFS would just
waste CPU time trying to compress them. The compression may also be disabled if
one wants faster file I/O, because UBIFS would not need to compress or
decompress the data on reads and write. However, I/O speed may actually become
slower if compression is disabled. Indeed, in case of a very fast CPU and very
slow flash compressed writes are faster, but this is usually not true for
embedded systems.</p>



<h2><a name="L_ubifs_nandsim">How do I use UBIFS with nandsim?</a></h2>

<p>The same way as with any MTD device. Here is an example of how to load
<code>nandsim</code>, create an UBI volume and mount it.</p>

<pre>
# Create an 256MiB emulated NAND flash with 2KiB NAND page size
# (you should see the new MTD device in /proc/mtd)
modprobe nandsim first_id_byte=0x20 second_id_byte=0xaa \
                 third_id_byte=0x00 fourth_id_byte=0x15

# MTD is not LDM-enabled and udev does not create device
# MTD device nodes automatically, so create /dev/mtd0
# (we assume that you do not have other MTD devices)
mknod /dev/mtd0 c 90 0

# Load UBI module and attach mtd0
modprobe ubi mtd=0

# Create a 200MiB UBI volume with name "ubifs-vol"
ubimkvol /dev/ubi0 -N ubifs-vol -s 200MiB

# Mount UBIFS
mount -t ubifs /dev/ubi0_0 /mnt/ubifs
</pre>

<p>For more information about nandsim see
<a href="nand.html#L_nand_nandsim">here</a>.</p>



<h2><a name="L_ubifs_extract">How do I extract files from an UBI/UBIFS image?</a></h2>

<p>Unfortunately, at the moment there are no user-space tools which can
unwrap UBI and UBIFS images. UBIFS cannot be loop-back mounted as well,
because it does not work with block devices.</p>

<p>However, there is a hacky way to unwrap UBI/UBIFS images. But you have
to make sure you have UBIFS support in your host machine. UBIFS is a relatively
new file system and is not supported by all Linux distributions. But at least
Fedora 11 does include it.</p>

<p>Let's consider a simple example. Suppose you have an <code>ubi.img</code>
file. This is an UBI image, which contains a single UBI volume, which in turn
contains UBIFS file-system. In other words, this is an image which was
created using the <code>mkfs.ubifs</code> and <code>ubinize</code> tools,
just like it is described in <a href="ubifs.html#L_mkfubifs">this</a>
section (the image is created for a 256MiB NAND flash with 2KiB NAND page
size and which supports sub-pages). Here is what you can do:</p>

<pre>
# Create an 256MiB emulated NAND flash with 2KiB NAND page size
# (you should see the new MTD device in /proc/mtd)
modprobe nandsim first_id_byte=0x20 second_id_byte=0xaa \
                 third_id_byte=0x00 fourth_id_byte=0x15

# MTD is not LDM-enabled and udev does not create device
# MTD device nodes automatically, so create /dev/mtd0
# (we assume that you do not have other MTD devices)
mknod /dev/mtd0 c 90 0

# Copy the contents of your image to the emulated MTD device
dd if=ubi.img of=/dev/mtd0 bs=2048

# Load UBI module and attach mtd0
modprobe ubi mtd=0

# Mount UBIFS
mount -t ubifs /dev/ubi0_0 /mnt/ubifs
</pre>

<p>Now you have the file-system in <code>/mnt/ubifs</code>. Use
the following to get rid of it:</p>

<pre>
umount /mnt/ubifs
rmmod ubifs ubi nandsim
</pre>



<h2><a name="L_powercut">Is UBIFS tolerant to power-cuts?</a></h2>

<p>Yes, both UBI (see <a href="ubi.html#L_crash_safe">here</a>) and UBIFS are
tolerant to power-cuts, and they were designed with this property in mind.</p>

<p>UBIFS has internal debugging infrastructure to emulate power failures and
the authors used it for extensive testing. It was tested for long time with
power-fail emulation (see <a href="ubifs.html#L_how_debug_test_modes">here</a>).
The advantage of the emulation is that it emulates power failures even at the
situations which happen not very often. For example, when the master node is
updated, or the log is changed. The probability to interrupt the system at
those moments is very low in real-life.</p>

<p>Real power-cut tests have also done on OneNAND flash. We used Power
Node devices which are controlled via serial line and may switch the power of
the connected device on and off. UBIFS survived more than 100000 power-cuts
while running stress tests.</p>

<p>We've also done real power-cut tests on Spansion NOR flash. Some problems
were found, but they were fixed and the board survived 10000 power-cuts after
this. Please, see related discussions at the
<a href="../mail.html">MTD mailing list</a>. The thread has
"<i>UBIFS Corrupt during power failure</i>" subject. The beginning of the thread
may be found
<a href="http://lists.infradead.org/pipermail/linux-mtd/2009-March/024953.html">here</a>,
then it continues
<a href="http://lists.infradead.org/pipermail/linux-mtd/2009-April/025229.html">here</a>,
and then continues
<a href="http://lists.infradead.org/pipermail/linux-mtd/2009-May/025609.html">here</a>,
and
<a href="http://lists.infradead.org/pipermail/linux-mtd/2009-June/025887.html">here</a>,
and
<a href="http://lists.infradead.org/pipermail/linux-mtd/2009-July/026259.html">here</a>.
</p>



<h2><a name="L_smaller_jrn">I need more space - should I make UBIFS journal smaller?</a></h2>

<p>UBIFS journal is very different to ext3 journal. In case of ext3, the
journal has fixed position on the block device. The data are first written
to the journal, and then copied to the file-system. This copying is done during
the commit. After the commit, new data may be written to the journal, and so
on. So in case of ext3 changing journal size would change file-system
capacity.</p>

<p>The situation is different in UBIFS. UBIFS journal is "wandering". It does
not have fixed position in the UBI volume. When the journal is full, UBIFS is
committing it which means it simply amends the FS index to refer the data which
is stored in the journal. Then different LEBs are picked for the new journal,
and so on. So the journal constantly migrates. The journal contains the same
information as other data LEBs, but this information is just not referred from
the index, it is not indexed. But there is flash space reserved for the
indexing information, and this space is used during commit.</p>

<p>In other words, if your file-system is full, the journal will also be full
and contain data. And the situation does not really change if you vary journal
size.</p>

<p>To put it simple, the amount of available space on UBIFS does not really
depend on the journal size. There is very weak dependency, though, because for
a bigger journal we need a bigger log, but it really does not make a
noticeable difference.</p>



<h2><a name="L_empty_file">Why is my file empty after an unclean reboot?</a></h2>

<p>Zero-length files are a special case of corruption which happens when
an application first truncates a file, then updates it. The truncation is
synchronous in UBIFS, so it is written to the media straight away. But
when the data are written, they go to the page cache, not to the flash media.
So when an unclean reboot happens, the file becomes empty (truncated) because
the data are lost.</p>

<p>Zero-length files also appear when an application creates a new file, then
writes to the file, and a power cut happens. The reason is similar - file
creation is a synchronous operation, data writing is not. </p>

<p>Well, the description is a bit simplified. Actually, when a file is
created or truncated, the creation/truncation UBIFS information is written to
the <a href="../doc/ubifs.html#L_writebuffer">write-buffer</a>, not straight to
the media. So if a power cut happens before the write-buffer is synchronized,
the file will disappear (creation case) or stay intact (truncation case). But
since the write-buffer is small and all UBIFS writes go there, it is usually
synchronized very soon. After this point the file is created/truncated for
real.</p>

<p>There are several ways to affect the situation.</p>

<ol>
	<li>Synchronize files using something like "<code>fsync()</code>" -
	<a href="../doc/ubifs.html#L_writeback">this</a> section contains all
	information about synchronization. But this does not guarantee
	that unclean reboots will not corrupt the file. Indeed, if an unclean
	reboot happens when only half of the data are written, the file will be
	corrupted/inconsistent. But this lessens the probability of
	corruptions.</li>

	<li>If you gave up fixing all your applications, you may mount UBIFS in
	synchronous mode - use "<code>-o sync</code>" mount option. But this
	makes UBIFS perform worse. And unfortunately, this also does not save
	you from all possible corruptions - you may still end up with holes
	(zeroes) at the end of files. See
	<a href="../doc/ubifs.html#L_sync_semantics">this</a> section for more
	information.</li>

	<li>You may use the well-known atomic file update technique - see
	<a href="ubifs.html#L_atomic_change">this</a> section.</li>

	<li>You may use the Linux write-back knobs to lessen the dirty
	write-back time-out - see <a href="ubifs.html#L_wb_knobs">this</a>
	section.</li>
</ol>

<p>The ext4 file-system helps buggy applications to lessen the probability of
getting zero-length files by implementing a special hack. Please, refer
<a href="../doc/ubifs.html#L_sync_exceptions">this</a> section for more
information. UBIFS does not provide a similar hack, although we are planning
to implement it.</p>



<h2><a name="L_end_hole">Why does my file have zeroes at the end after an unclean reboot?</a></h2>

<p>Power cuts often lead to holes at the end of files. Holes are areas of
the file which contain no data. For example, if you truncate a file to a larger
size and synchronize it - you end up with a hole. Holes are read as zeroes.
Often files with holes are referred to as sparse files. People sometimes
deliberately create sparse files in order to save space - this is sometimes
better than filling files with lots of zeroes.</p>

<p>Please, read more information about how unclean reboots result in holes
in <a href="../doc/ubifs.html#L_sync_semantics">this</a> section.</p>



<h2><a name="L_bgt_thread">What does the "ubifs_bgt0_0" thread do?</a></h2>

<p>The UBIFS background thread is created for every mounted file-system and
has "<i>ubifs_bgtX_Y</i>" name, where "<i>X</i>" is UBI device number and
"<i>Y</i>" is UBI volume ID. For example, "<code>ubifs_bgt1_2</code>" is UBIFS
background thread corresponding to the mounted volume 2 on UBI device 1.</p>

<p>The background thread exists for optimization. One of its functions is
background journal commit. It starts committing the journal in background when
it is about 80% full. The idea is to make sure the journal is committed or
almost committed by the time it becomes full, so writers would not have to wait
for commit and keep writing data. The UBIFS presentation slides and the UBIFS
white-paper contain more information about the journal and committing, see
<a href="../doc/ubifs.html#L_documentation">this</a> section.</p>

<p>The other function of the background thread is flushing write-buffers. Each
write-buffer has a timer, and when the timer expires, the background thread is
woken up and the write-buffer is flushed. Please, refer
<a href="../doc/ubifs.html#L_writebuffer">this</a> section for more information
about UBIFS write-buffers.</p>

<p>Another thing which the background thread could do is background garbage
collection, just like in JFFS2. However, this is not implemented and UBIFS does
not garbage-collect in background at the moment.</p>



<h2><a name="L_sudden_ro">UBIFS suddenly became read-only - what is this?</a></h2>

<p>Read-write UBIFS file-system may suddenly become read-only because of an
error. This is how UBIFS reacts on unexpected errors which it cannot properly
handle - it immediately switches to read-only mode in order to protect the data
from any possible further corruption.</p>

<p>If this happened, you should look at UBIFS-related <code>dmesg</code>
messages. UBIFS usually prints error messages before switching to read-only
mode. The messages may shed some light on what happened. Feel free to ask for
help from the <a href="../mail.html">MTD mailing list</a>. If you think this is
an UBIFS bug, please, send a
<a href="../doc/ubifs.html#L_how_send_bugreport">bug report</a>.</p>



<h2><a name="L_detect_ro">How do I detect if UBIFS became read-only?</a></h2>

<p>If you use up-to-date UBIFS which includes commit
<code>2fde99cb55fb9d9b88180512a5e8a5d939d27fec</code>
(<code>UBIFS: mark VFS SB RO too</code>), then you should be able to find this
out from <code>/proc/mounts</code>. You should also be able to use something
like <code>inotify</code> to catch events when UBIFS becomes R/O
(e.g., due to some errors).</p>



<h2><a name="L_lebsz_mismatch">
I see this UBIFS error: "validate_sb: LEB size mismatch: 129024 in superblock, 126976 real"
</a></h2>

<p>When you create an UBIFS image using the <code>mkfs.ubifs</code> utility,
you specify LEB size using the <code>-e</code> option. This is a very important
parameter and you should specify it correctly in order to have working UBIFS
image. Indeed, LEB size is the major UBIFS storage unit, e.g., UBIFS nodes
never cross LEB boundaries, garbage collection is performed on individual LEBs,
etc. See <a href="ubifs.html#L_mkfubifs">this</a> section for more
information.</p>

<p>The error message means that LEB size information which is stored in the
UBIFS superblock does not match the real LEB size, which UBIFS takes from UBI.
The superblock was created by the <code>mkfs.ubifs</code> utility, therefore
you failed to pass the correct LEB size to the utility. Fix this by passing
correct LEB size via the <code>-e</code> option.</p>



<h2><a name="L_pdflush_blocked">
I see this error: "INFO: task pdflush:110 blocked for more than 120 seconds"
</a></h2>

<p>If this happens with a NOR flash, then this is a known issue and is about
the UBI background thread doing a lot of erasures. When you attach to empty
flash to UBI, it will format the flash in background, in the context of the
UBI background thread (see <a href="ubi.html#L_bgt_thread">here</a>). Formatting
means that for each eraseblock it does the following:
<ul>
	<li>erases (very slow on NOR!)</li>
	<li>writes the UBI headers</li>
</ul>

Depending on your MTD/CFI chip driver the "MTD/CFI chip lock" may be held for
the time it needs to erase an eraseblock. User-space applications which
manipulate files on the UBIFS file-system may then also be blocked on the same
"MTD/CFI chip lock. This causes pdflush to block as well since it tries to
acquire the UBIFS journal mutex, which is already locked by the process which
is waiting on the "MTD/CFI chip lock". See
<a href="http://lists.infradead.org/pipermail/linux-mtd/2009-November/027993.html">this</a>
discussion for some more details.

The ways to solve this:
<ol>
	<li>Use <code>ubiformat</code> and format the NOR partition before
	attaching it to UBI. But this will not help in situations when you
	delete may files, and starts erasing many eraseblocks, so the "MTD/CFI
	chip lock" becomes very condtended.</li>
	<li>Use erase-suspend for writing (if your chip supports this).</li>
</ol>
</p>



<h2><a name="L_few_lebs">
I get: "init_constants_early: too few LEBs (12), min. is 17"
</a></h2>

<p>This error means that you are trying to mount too small UBI volume.
Probably because your flash is too small? Try to use JFFS2, then, because it
suits small flashes better since it has much lower space overhead. Indeed,
UBIFS stores much more indexing information on the flash media than JFFS2, so
it has much higher overhead. Also, UBI has some overhead (see
<a href="../doc/ubi.html#L_overhead">here</a>). Thus, if you have a small flash
device (e.g., about 64MiB), it makes sense to consider using JFFS2.</p>



<h2><a name="L_study_ubifs">I want to study UBIFS - any recommendations?</a></h2>

<p>Follow <a href="../doc/ubifs.html#L_documentation">these</a> instructions.</p>



<h2><a name="L_how_debug">How do I debug UBIFS?</a></h2>

<h3><a name="L_how_debug_fake_mtd">Use fake MTD device</a></h3>

It is often much easier to debug on a PC with a flash emulator, rather than
debugging on a real system. E.g., most of the UBIFS development was done on
a standard PC with the <code>nandsim</code> NAND simulator. Please, refer
<a href="ubi.html#L_how_debug_fake_mtd">here</a> for more information about
the available fake MTD devices.


<h3>Enable UBIFS debugging support</h3>

<p>Enable UBIFS debugging support in the configuration menu
(the "<b>UBIFS debugging support</b>" check-box). This will make sure that
assertions, debugging messages, self-checks and test modes are compiled-in.
The assertions will be enabled, but messages, self-checks and test modes
will be disabled by default. This option will also make many error messages
to be more verbose (e.g., include flash dumps). This option should not slow
down UBIFS, so it is recommended to always have it switched on, unless you
are very concerned about UBIFS code size.</p>


<h3>Debugging messages</h3>

<p>Sometimes it is necessary to make UBIFS print about what it is doing. You may
enable various UBIFS debugging messages using the <code>debug_msgs</code>
UBIFS module parameter, or using the <code>ubifs.debug_msgs</code> kernel boot
parameter if you have UBIFS compiled in. Alternatively, the same can be
achieved by changing the <code>/sys/module/ubifs/parameters/debug_tsts</code>
file.</p>

<p>The <code>debug_msgs</code> option is a bit-mask which controls which message
type has to be printed. You can combine the message types arbitrarily. The
following message types are supported:</p>


<table border="2" cellpadding="4" cellspacing="0">
<tr>
	<td><b>Message Type</b></td>
	<td><b>Value</b></td>
</tr>
<tr>
	<td>General messages</td>
	<td>1</td>
</tr>
<tr>
	<td>Journal messages</td>
	<td>2</td>
</tr>
<tr>
	<td>Mount messages</td>
	<td>4</td>
</tr>
<tr>
	<td>Commit messages</td>
	<td>8</td>
</tr>
<tr>
	<td>LEB search messages</td>
	<td>16</td>
</tr>
<tr>
	<td>Budgeting messages</td>
	<td>32</td>
</tr>
<tr>
	<td>Garbage collection messages</td>
	<td>64</td>
</tr>
<tr>
	<td>Tree Node Cache (TNC) messages</td>
	<td>128</td>
</tr>
<tr>
	<td>LEB properties (lprops) messages</td>
	<td>256</td>
</tr>
<tr>
	<td>Input/output messages</td>
	<td>512</td>
</tr>
<tr>
	<td>Log messages</td>
	<td>1024</td>
</tr>
<tr>
	<td>Scan messages</td>
	<td>2048</td>
</tr>
<tr>
	<td>Recovery messages</td>
	<td>4096</td>
</tr>
</table>

<p>E.g., "<code>echo 4097 > /sys/module/ubifs/parameters/debug_tsts</code>"
enables general and recovery messages.</p>

<p>UBIFS may print huge amount of debugging messages and slow down your system
considerably. You might also end up losing them if your ring buffer is not
large enough. <a href="ubi.html#L_how_debug_printks">This</a> section explains
how to make the ring buffer larger.</p>


<h3><a name="L_how_debug_self_checks">Extra self-checks</a></h3>

<p>UBIFS contains various internal self-check functions which are often
very useful for debugging or testing. However, the self-checks are very
expensive and slow down UBIFS a lot. We recommend to use them only while
hunting bugs or testing UBIFS changes.</p>

<p>Similarly to debugging messages, the self-checks can be switched on
using the <code>debug_chks</code> UBIFS module parameter or the
<code>/sys/module/ubifs/parameters/debug_chks</code> file. The
<code>debug_chks</code> option is a bit-mask which selects the check
types to be enabled.</p>

<table border="2" cellpadding="4" cellspacing="0">
<tr>
	<td><b>Check type</b></td>
	<td><b>Value</b></td>
</tr>
<tr>
	<td>General checks</td>
	<td>1</td>
</tr>
<tr>
	<td>Check Tree Node Cache (TNC)</td>
	<td>2</td>
</tr>
<tr>
	<td>Check indexing tree size</td>
	<td>4</td>
</tr>
<tr>
	<td>Check orphan area</td>
	<td>8</td>
</tr>
<tr>
	<td>Check old indexing tree</td>
	<td>16</td>
</tr>
<tr>
	<td>Check LEB properties (lprops)</td>
	<td>32</td>
</tr>
<tr>
	<td>Check leaf nodes and inodes</td>
	<td>64</td>
</tr>
</table>

<p>E.g., "<code>echo 3 > /sys/module/ubifs/parameters/debug_chks</code>" enables
general checks and TNC checks. But for testing, it is better to just enable
all checks: "<code>echo 127 > /sys/module/ubifs/parameters/debug_chks</code>".</p>


<h3><a name="L_how_debug_test_modes">Test modes</a></h3>

<p>UBIFS currently supports 2 test modes:</p>
<ul>
	<li>"Force in-the-gaps" forces the "in-the-gaps" garbage collection
	method to be used as much as possible. Normally, UBIFS uses this method
	extremely rarely, only as the last resort way to do garbage collection,
	which makes it difficult to test. This test mode changes this behavior.</li>

	<li>"Failure mode for recovery" test mode makes UBIFS emulate power cuts.
	When a power-cut is emulated, UBIFS switches to read-only mode, and then
	it is supposed to be unmounted and mounted again, which causes recovery.
	The main idea of this mode is to emulate power cuts in "interesting" places,
	e.g., when changing the log, or the orphans area. Indeed, real power-cuts
	testing mostly interrupts UBIFS when it is writing data to the journal.
	The testing mode makes it more probable to interrupt UBIFS in other places.
	And of course, the testing mode should be considered as supplementary to
	the real power cut testing.</li>
</ul>

<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
