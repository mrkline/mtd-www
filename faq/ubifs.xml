<PAGE>
<VAR match="VAR_ORIGIN" replace="../" />
<VAR match="VAR_CVSID" replace="Last updated: 04 Apr 2008, dedekind"/>
<INCLUDE file="../inc/header.tmpl" />

<VAR match="VAR_SEL_FAQ" replace="selected" />
<VAR match="VAR_SEL_UBIFS" replace="selected" />
<PARSE file="../menu1.xml" />

<INCLUDE file="../inc/content.tmpl" />

<h1>UBIFS FAQ and HOWTO</h1>

<h2>Table of contents</h2>
<ol>
	<li><a href="ubifs.html#L_ubifs_mlc">May UBIFS be used on MLC flash?</a></li>
	<li><a href="ubifs.html#L_mount_ubifs">How to mount UBIFS?</a></li>
	<li><a href="ubifs.html#L_mkfubifs">How to create an UBIFS image?</a></li>
	<li><a href="ubifs.html#L_emptyflash">May an empty UBI volume be mounted?</a></li>
	<li><a href="ubifs.html#L_ubifs_nandsim">How to use UBIFS with nandsim?</a></li>
</ol>



<a name="L_ubifs_mlc"><h2>May UBIFS be used on MLC flash?</h2></a>

<p>The authors did not test it, but they belive it should run fine.
Consider the main specific aspects of MLC flashes:</p>

<ul>
	<li>MLC flashes are more "faulty" then SLC, so they use stronger ECC
	codes which occupies whole OOB area - this is not a problem because
	neither UBIFS nor UBI use the OOB area;</li>

	<li>when the data is written to an eraseblock, it has to be written
	sequentially, from the beginning of the eraseblock to the end of it -
	this is not a problem because it is exactly what UBI/UBIFS do (see
	also <a href="../faq/ubi.html#L_restrict">this</a> section);</li>

	<li>MLC flashes have rather short eraseblock lifecycle of just few
	thousand of erase cycles - this is not be a problem, because UBI uses
	determenistic wear-leveling algorithm (see
	<a href="../faq/ubi.html#L_mlc">this</a> section).</li>
</ul>



<a name="L_mount_ubifs"><h2>How to mount UBIFS?</h2></a>

<p>UBIFS mounts UBI volumes, not UBI devices, not MTD devices. There are no
block device nodes corresponding to UBI volumes exist in <code>/dev</code>,
and UBIFS uses device-less mount, just like <code>procfs</code> or
<code>sysfs</code>. The volume to mount is specified using <code>ubiX_Y</code>
or <code>ubiX:NAME</code> syntax, where</p>

<ul>
	<li><code>X</code> - UBI device number;</li>
	<li><code>Y</code> - UBI volume number;</li>
	<li><code>NAME</code> - UBI volume name.</li>
</ul>

<p>For example,</p>

<pre>
$ mount -t ubifs ubi0_0 /mnt/ubifs
</pre>

<p>mounts volume 0 on UBI device 0 to <code>/mnt/ubifs</code>, and</p>

<pre>
$ mount -t ubifs ubi0:rootfs /mnt/ubifs
</pre>

<p>mounts "rootfs" volume of UBI device 0 to <code>/mnt/ubifs</code> ("rootfs" is
volume name. This method of specifying UBI volume is more preferable because
it does not depend on device/volume numbers, which may change.</p>

<p>Note, if <code>X</code> is not specified, UBIFS uses 0, i.e.,
"<code>ubi0:rootfs</code>" and "<code>ubi:rootfs</code>" are
equivalent.</p>

<p>Some environments like busybox are confused by the ":" delimiter (e.g.,
<code>ubi:rootfs</code>) and "!" may be used instead (e.g.,
<code>ubi!rootfs</code>).</p>

<p>The following is an example of the kernel boot arguments to attach
<code>mtd0</code> to UBI and mount volume "rootfs":</p>

<pre>
ubi.mtd=0 root=ubi0:rootfs rootfstype=ubifs
</pre>

<p>Please, refer <a href="ubi.html#L_attachmtd">this</a> section for
information about how to create UBI devices and
<a href="ubi.html#L_mkvol">this</a> section for information about how to create
UBI volumes.</p>



<a name="L_mkfubifs"><h2>How to create an UBIFS image?</h2></a>

<p>UBIFS images are created by the
<a href="../doc/ubifs.html#L_usptools"><code>mkfs.ubifs</code></a> utility.
The image is assumed to be written to UBI volumes, for example using
<a href="../doc/ubi.html#L_usptools"><code>ubiupdatevol</code></a>. But this
might be not enough for purposes like production at the factory, where you have
to have raw flash image. And there is
<a href="../doc/ubi.html#L_usptools"><code>ubinize</code></a> utility which may
produce raw flash images.</p>

<p>The below example demonstrates how to create an UBI/UBIFS image for a 256MiB
OneNAND flash chip with 128KiB physical eraseblocks, 2048 bytes NAND pages, and
which supports 4 sub-pages (this means that MTD allows to do 4x512 bytes writes
to the same NAND page, which is quite typical for SLC flashes). The resulting
image will have one UBI volume storing UBIFS file-system.</p>

<pre>
$ mkfs.ubifs -r root-fs -m 2048 -e 129024 -c 2047 -o ubifs.img
$ ubinize -o ubi.img -m 2048 -p 128KiB -s 512 ubinize.cfg
</pre>

<p>where <code>ubinize.cfg</code> contains:</p>

<pre>
$ cat ubinize.cfg
[ubifs]
mode=ubi
image=ubifs.img
vol_id=0
vol_size=200MiB
vol_type=dynamic
vol_name=rootfs
vol_alignment=1
vol_flags=autoresize
</pre>

<p>Some comments about what the options mean:</p>

<ul>
	<li><code>-r root-fs</code>: tells <code>mkfs.ubifs</code> to create an
	UBIFS image which would have identical contents as the local
	<code>root-fs</code> directory has;</li>

	<li><code>-m 2048</code>: tells <code>mkfs.ubifs</code> that the minimum
	input/output unit size of the flash this UBIFS image is created for is
	2048 bytes;</li>

	<li><code>-e 129024</code>: logical eraseblock size of the UBI volume
	this image is created for;</li>

	<li><code>-c 2047</code>: specifies maximum file-system size in logical
	eraseblocks; this means that it will be possible to use the resulting
	file-system on volumes up to this size (less or equivalent); so in this
	particular case, the resulting FS may be put on volumes up to about
	251MiB (129024 multiplied by 2047);</li>

	<li><code>-p 128KiB</code>: tells <code>ubinize</code> that physical
	eraseblock size of the flash chip the UBI image is created for is
	128KiB (128 * 1024 bytes);</li>

	<li><code>-s 512</code>: tells <code>ubinize</code> that the flash
	supports sub-pages and sub-page size is 512 bytes; <code>ubinize</code>
	will take this into account and put the VID header to the same NAND
	page as the EC header.</li>
</ul>

<p>The <code>ubinize</code> utility requires volumes description file which has
standard <code>.ini</code> file syntax. One UBI image may contain many UBI
volumes with different characteristics and it is difficult to invent a nice
command-line interface for specifying those characteristics, this is why the
utility requires the volumes description file.</p>

<p>The example configuration file tells <code>ubinize</code> to create an UBI
image which has a singe 200MiB dynamic volume with ID 0, name "rootfs", and
alignment 1. The configuration file also sets the "autoresize" volume flag,
which means that the volume will be automatically enlarged by UBIFS to have
the maximum possible size when it runs for the first time. See
<a href="../doc/ubi.html#L_autoresize">here</a> for more information about what
is the auto-resize trick.</p>

<p>Run <code>ubinize -h</code> and <code>mkfs.ubifs -h</code> for more
information and for more possibilities to tweak images.</p>


<a name="L_emptyflash"><h2>Is it OK to mount empty UBI volumes?</h2></a>

<p>Yes, it is OK to mount empty UBI volumes, which are volumes which
contain only 0xFF bytes. In this case UBIFS formats the media automatically
with default parameters (journal size, compression, etc). But generally, this
feature should be used while developing, and a proper UBI/UBIFS image should
preferrably be flashed in production
(see <a href="ubifs.html#L_mkfubifs">this</a> section).</p>

<p>Note, UBI has similar property and automatically formats the flash media if
it is empty. So if there is an <code>mtd0</code>  MTD device, the following
is possible:</p>

<pre>
# Wipe the MTD device out
flash_eraseall /dev/mtd0

# Load UBI module
modprobe ubi

# Attach mtd0 to UBI - UBI will detect that the MTD device is
# empty and automatically format it. This command will also create
# UBI device 0 and udev should create /dev/ubi0 node
ubiattach /dev/ubi_ctrl -m 0

# Create an UBI volume - the created volume will be empty
ubimkvol /dev/ubi0 -N test_volume -s 10MiB

# Mount UBIFS - it will automatically format the empty volume
mount -t ubifs ubi0:test_volume /mnt/ubifs
</pre>

<p>Note, it is also possible to wipe out an existing UBIFS volume represented
by <code>/dev/ubi0_0</code> using the following command:</p>

<pre>
ubiupdatevol /dev/ubi0_0 -t
</pre>



<a name="L_ubifs_nandsim"><h2>How to use UBIFS with nandsim?</h2></a>

<p>The same way as with any MTD device. Here is an example of how to load
<code>nandsim</code>, create an UBI volume and mount it.</p>

<pre>
# Create an 256MiB emulated NAND flash
modprobe nandsim first_id_byte=0x20 second_id_byte=0xaa \
                 third_id_byte=0x00 fourth_id_byte=0x15

# MTD is not LDM-enabled and udev does not create device
# MTD device nodes automatically, so create /dev/mtd0
mknod /dev/mtd0 c 90 0

# Load UBI module and attach mtd0
modprobe ubi mtd=0

# Create a 200MiB UBI volume with name "ubifs-vol"
ubimkvol /dev/ubi0 -N ubifs-vol -s 200MiB

# Mount UBIFS
mount -t ubifs ubi0:ubifs-vol /mnt/ubifs
</pre>

<p>For more information about nandsim see
<a href="nand.html#L_nand_nandsim">here</a>.</p>


<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
