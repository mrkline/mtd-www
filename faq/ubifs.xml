<PAGE>
<VAR match="VAR_ORIGIN" replace="../" />
<VAR match="VAR_CVSID" replace="Last updated: 29 May 2008, dedekind"/>
<INCLUDE file="../inc/header.tmpl" />

<VAR match="VAR_SEL_FAQ" replace="selected" />
<VAR match="VAR_SEL_UBIFS" replace="selected" />
<PARSE file="../menu1.xml" />

<INCLUDE file="../inc/content.tmpl" />

<h1>UBIFS FAQ and HOWTO</h1>

<h2>Table of contents</h2>
<ol>
	<li><a href="ubifs.html#L_ubifs_mlc">May UBIFS be used on MLC NAND flash?</a></li>
	<li><a href="ubifs.html#L_mount_ubifs">How to mount UBIFS?</a></li>
	<li><a href="ubifs.html#L_mkfubifs">How to create an UBIFS image?</a></li>
	<li><a href="ubifs.html#L_find_lebsz">How to find out LEB size?</a></li>
	<li><a href="ubifs.html#L_emptyflash">May an empty UBI volume be mounted?</a></li>
	<li><a href="ubifs.html#L_max_leb_cnt">What is the purpose of -c (--max-leb-cnt) mkfs.ubifs option?</a></li>
	<li><a href="ubifs.html#L_mkfs_ubifs_comp">How to compile mkfs.ubifs?</a></li>
	<li><a href="ubifs.html#L_loop_mount">Can UBIFS mount loop-back devices?</a></li>
	<li><a href="ubifs.html#L_atomic_change">How to change a file atomically?</a></li>
	<li><a href="ubifs.html#L_atime">Does UBIFS support atime?</a></li>
	<li><a href="ubifs.html#L_nfs">Does UBIFS support NFS?</a></li>
	<li><a href="ubifs.html#L_ubifs_nandsim">How to use UBIFS with nandsim?</a></li>
</ol>



<h2><a name="L_ubifs_mlc">May UBIFS be used on MLC NAND flash?</a></h2>

<p>Yes, it should run fine. Let's consider the specific aspects of MLC
NAND flashes:</p>

<ul>
	<li>MLC NAND flashes are more "faulty" than SLC, so they use stronger
	ECC codes which occupy whole OOB area; this is not a problem
	for UBI/UBIFS, because neither UBIFS nor UBI use OOB area;</li>

	<li>when the data is written to an eraseblock, it has to be written
	sequentially, from the beginning of the eraseblock to the end of it;
	this is also not a problem because it is exactly what UBI and UBIFS do
	(see also <a href="../faq/ubi.html#L_restrict">this</a> section);</li>

	<li>MLC flashes have rather short eraseblock life-cycle of just few
	thousand of erase cycles; and this is not be a problem, because UBI
	uses deterministic wear-leveling algorithm
	(see <a href="../faq/ubi.html#L_mlc">this</a> section).</li>
</ul>



<h2><a name="L_mount_ubifs">How to mount UBIFS?</a></h2>

<p>UBIFS mounts UBI volumes, not UBI devices, not MTD devices. There are no
block device nodes corresponding to UBI volumes and UBIFS uses device-less
mount, just like <code>procfs</code> or <code>sysfs</code>. The volume to
mount is specified using <code>ubiX_Y</code> or <code>ubiX:NAME</code>
syntax, where</p>

<ul>
	<li><code>X</code> - UBI device number;</li>
	<li><code>Y</code> - UBI volume number;</li>
	<li><code>NAME</code> - UBI volume name.</li>
</ul>

<p>For example,</p>

<pre>
$ mount -t ubifs ubi0_0 /mnt/ubifs
</pre>

<p>mounts volume 0 on UBI device 0 to <code>/mnt/ubifs</code>, and</p>

<pre>
$ mount -t ubifs ubi0:rootfs /mnt/ubifs
</pre>

<p>mounts "rootfs" volume of UBI device 0 to <code>/mnt/ubifs</code> ("rootfs"
is volume name). This method of specifying UBI volume is more preferable
because it does not depend on volume number.</p>

<p>Note, if <code>X</code> is not specified, UBIFS uses 0, i.e.,
"<code>ubi0:rootfs</code>" and "<code>ubi:rootfs</code>" are
equivalent.</p>

<p>Some environments like busybox are confused by the ":" delimiter (e.g.,
<code>ubi:rootfs</code>) and "!" may be used instead (e.g.,
<code>ubi!rootfs</code>).</p>

<p>The following is an example of the kernel boot arguments to attach
<code>mtd0</code> to UBI and mount volume "rootfs":</p>

<pre>
ubi.mtd=0 root=ubi0:rootfs rootfstype=ubifs
</pre>

<p>Please, see <a href="ubi.html#L_attachmtd">this</a> section for
information about how to create UBI devices and
<a href="ubi.html#L_mkvol">this</a> section for information about how to create
UBI volumes.</p>



<h2><a name="L_mkfubifs">How to create an UBIFS image?</a></h2>

<p>Creating UBIFS images might be a little trickier than creating JFFS2 images.
First of all, you have to understand that UBIFS works on top of UBI which works
on top or MTD which basically represents your raw flash. This means, that if
you need to create an image which would be flashed to the raw flash, you should
first create an UBIFS image, than UBI image. In other words, the process has 2
steps.</p>

<p>However, as described <a href="../doc/ubi.html#L_volupdate">here</a>,
UBI has a volume update facility and there is an
<a href="../doc/ubi.html#L_usptools"><code>ubiupdatevol</code></a> utility
which for this. So you may update UBI volumes straight form your
running system as well. In this case, you only need UBIFS image, and you do not
have to make the UBI image, i.e., the process has only 1 step in this case.</p>

<p>So, there are 2 utilities:</p>
<ul>
	<li><a href="../doc/ubifs.html#L_usptools"><code>mkfs.ubifs</code></a>
	which creates UBIFS images;</li>
	<li><a href="../doc/ubi.html#L_usptools"><code>ubinize</code></a>
	which creates UBI images.</li>
</ul>

<p>And depending on the needs you use either <code>mkfs.ubifs</code> or
<code>mkfs.ubifs</code> plus <code>ubinize</code>. Choose the former if you are
going to upload the update UBIFS image on your target and then update the UBI
volume using <code>ubiupdatevol</code>. Choose the latter if you are going to
flash the image to raw flash, e.g., at the factory.</p>

<p>The UBI and UBIFS images depend on parameters of the flash they are going to
be used on. Namely, you have to know the following characteristics of the flash
before creating images:</p>

<ul>
	<li>flash size;</li>
	<li>physical eraseblock size;</li>
	<li>minimum flash input/output unit size;</li>
	<li>for NAND flashes, sub-page size;</li>
	<li>logical eraseblock size.</li>
</ul>

<p><a href="../faq/ubi.html#L_find_min_io_size">This</a> and
<a href="ubifs.html#L_find_lebsz">this</a> sections explain the above
parameters and give some hints about how to find them out.</p>

<p>And optionally, you should decide which compression algorithm you would want
to use for this file-system. UBIFS supports zlib and LZO (default) at the
moment. Generally, zlib compresses better, but it is slower on both compression
and decompression. So this is a trade-off between space savings and speed. The
best idea is to try both and choose the one which is more appropriate for you.
But if flash space is not a big issue, it is recommended to use LZO.
Alternatively, the compression may be switched off. See "<code>-x</code>"
option of the <code>mkfs.ubifs</code> utility.</p>

<p>There are other advanced file-system and UBI characteristics which may be
altered with the tools. Use them only if you understand what they do.</p>

<p>The below example demonstrates how to create an UBI/UBIFS image for a 256MiB
SLC OneNAND flash chip with 128KiB physical eraseblocks, 2048 bytes NAND pages, and
which supports 4 sub-pages (this means that it allows to do 4x512 bytes writes
to the same NAND page, which is quite typical for SLC flashes). The resulting
image will have one UBI volume storing UBIFS file-system.</p>

<pre>
$ mkfs.ubifs -r root-fs -m 2048 -e 129024 -c 2047 -o ubifs.img
$ ubinize -o ubi.img -m 2048 -p 128KiB -s 512 ubinize.cfg
</pre>

<p>where <code>ubinize.cfg</code> contains:</p>

<pre>
$ cat ubinize.cfg
[ubifs]
mode=ubi
image=ubifs.img
vol_id=0
vol_size=200MiB
vol_type=dynamic
vol_name=rootfs
vol_flags=autoresize
</pre>

<p>Some comments about what the options mean:</p>

<ul>
	<li><code>-r root-fs</code>: tells <code>mkfs.ubifs</code> to create an
	UBIFS image which would have identical contents as the local
	<code>root-fs</code> directory has;</li>

	<li><code>-m 2048</code>: tells <code>mkfs.ubifs</code> that the minimum
	input/output unit size of the flash this UBIFS image is created for is
	2048 bytes;</li>

	<li><code>-e 129024</code>: logical eraseblock size of the UBI volume
	this image is created for;</li>

	<li><code>-c 2047</code>: specifies maximum file-system size in logical
	eraseblocks; this means that it will be possible to use the resulting
	file-system on volumes up to this size (less or equivalent); so in this
	particular case, the resulting FS may be put on volumes up to about
	251MiB (129024 multiplied by 2047);</li>

	<li><code>-p 128KiB</code>: tells <code>ubinize</code> that physical
	eraseblock size of the flash chip the UBI image is created for is
	128KiB (128 * 1024 bytes);</li>

	<li><code>-s 512</code>: tells <code>ubinize</code> that the flash
	supports sub-pages and sub-page size is 512 bytes; <code>ubinize</code>
	will take this into account and put the VID header to the same NAND
	page as the EC header.</li>
</ul>

<p>The <code>ubinize</code> utility requires volumes description file. Please,
refer <a href="../faq/ubi.html#L_ubi_mkimg">this</a> section for more
<code>ubinize</code> usage information.</p>

<p>In the example, the <code>ubinize.cfg</code> file tells <code>ubinize</code>
to create an UBI image which has a singe 200MiB dynamic volume with ID 0, and
name "rootfs". The configuration file also sets the "autoresize" volume flag,
which means that the volume will be automatically enlarged by UBIFS to have
the maximum possible size when it runs for the first time. See
<a href="../doc/ubi.html#L_autoresize">here</a> for more information about what
the auto-resize feature is.</p>

<p>Please, run <code>ubinize -h</code> and <code>mkfs.ubifs -h</code> for more
information and for more possibilities to tweak the generated images.</p>

<p>Here is one more example for a 32MiB NOR flash with 128KiB physical
eraseblock size.</p>

<pre>
$ mkfs.ubifs -r root-fs -m 1 -e 130944 -c 255 -o ubifs.img
$ ubinize -o ubi.img -m 1 -p 128KiB ubinize.cfg
</pre>

<p>where <code>ubinize.cfg</code> contains:</p>

<pre>
$ cat ubinize.cfg
[ubifs]
mode=ubi
image=ubifs.img
vol_id=0
vol_size=30MiB
vol_type=dynamic
vol_name=rootfs
vol_alignment=1
vol_flags=autoresize
</pre>

<p>And one more example for a 512MiB MLC NAND flash with 128KiB physical
eraseblock size, 2048 bytes NAND page size and no sub-page write
support.</p>

<pre>
$ mkfs.ubifs -r root-fs -m 2048 -e 126976 -c 4095 -o ubifs.img
$ ubinize -o ubi.img -m 2048 -p 128KiB ubinize.cfg
</pre>

<p>where <code>ubinize.cfg</code> contains:</p>

<pre>
$ cat ubinize.cfg
[ubifs]
mode=ubi
image=ubifs.img
vol_id=0
vol_size=450MiB
vol_type=dynamic
vol_name=rootfs
vol_alignment=1
vol_flags=autoresize
</pre>



<h2><a name="L_find_lebsz">How to find out LEB size?</a></h2>

<p>When creating UBIFS images it is necessary to know logical eraseblock
size which depends on the following flash chip parameters:</p>
<ul>
	<li>physical eraseblock size;</li>
	<li>minimum input/output unit size;</li>
	<li>sub-page size;</li>
</ul>

<p>Please, refer <a href="../faq/ubi.html#L_find_min_io_size">this</a> section
for more information about how to find those 3 parameters. Here are the most
typical configurations:</p>
<ul>
	<li>NOR flash with 1 byte min. I/O unit size: LEB size is PEB size
	minus 128;</li>
	<li>NAND flash with 512 byte NAND page and 265 byte sub-page: LEB size
	is PEB size minus 512;</li>
	<li>NAND flash with 2048 byte NAND page and 512 byte sub-page: LEB size
	is PEB size minus 2048;</li>
	<li>NAND flash with 2048 byte NAND page and no sub-page: LEB size
	is PEB size minus 4096.</li>
</ul>

<p>Please, also refer <a href="../doc/ubi.html#L_overhead">this</a> section for
additional information.</p>

<p>The easiest way to find out the LEB size is to attach the MTD device to UBI,
as it is suggested at the end of
<a href="../faq/ubi.html#L_find_min_io_size">this</a> section.</p>



<h2><a name="L_emptyflash">Is it OK to mount empty UBI volumes?</a></h2>

<p>Yes, it is OK to mount empty UBI volumes, i.e. the volumes which
contain only 0xFF bytes. In this case UBIFS formats the media automatically
with default parameters (journal size, compression, etc). But generally, this
feature should have limited use, and a proper UBIFS image should
preferably be flashed created
(see <a href="ubifs.html#L_mkfubifs">this</a> section).</p>

<p>Note, UBI has similar property and it automatically formats the flash media
if it is empty (see <a href="../faq/ubi.html#L_format_mtd">here</a>). So if
there is an <code>mtd0</code> MTD device, the following will work:</p>

<pre>
# Wipe the MTD device out. Note, we could use flash_eraseall, but we do not
# want to loose erase counters
ubiformat /dev/mtd0

# Load UBI module
modprobe ubi

# Attach mtd0 to UBI - UBI will detect that the MTD device is
# empty and automatically format it. This command will also create
# UBI device 0 and udev should create /dev/ubi0 node
ubiattach /dev/ubi_ctrl -m 0

# Create an UBI volume - the created volume will be empty
ubimkvol /dev/ubi0 -N test_volume -s 10MiB

# Mount UBIFS - it will automatically format the empty volume
mount -t ubifs ubi0:test_volume /mnt/ubifs
</pre>

<p>It is also possible to wipe out an existing UBIFS volume represented
by <code>/dev/ubi0_0</code> using the following command:</p>

<pre>
ubiupdatevol /dev/ubi0_0 -t
</pre>



<h2><a name="L_max_leb_cnt">
	What is the purpose of -c (--max-leb-cnt) mkfs.ubifs option?
</a></h2>

<p>It is a form of specifying file-system size. But instead of specifying the
exact file-system size, this option defines the <i>maximum</i> file-system
size (more strictly, maximum UBI volume size). For example, if you use
<code>--max-leb-cnt=200</code> <code>mkfs.ubifs</code> option, than it will be
possible to put the resulting image to smaller UBI volume and mount it. But if
the image is put to a larger UBI volume, the file-system will anyway take only
first 200 LEBs, and the rest of the volume will be wasted.</p>

<p>Note, the <code>--max-leb-cnt</code> option does not affect the size of the
resulting image file, which depends only on the amount of data in the
file-system. <code>mkfs.ubifs</code> just writes the <code>--max-leb-cnt</code>
value to the file-system superblocks.</p>

<p>This feature is quite handy on NAND flashes, because they have random amount
of initial bad eraseblocks (marked as bad in production). This means, that
different devices may have slightly different volume sizes (especially if the
UBI <a href="../doc/ubi.html#L_autoresize">auto-resize</a> feature is used). So
you may specify the maximum possible volume size and this will guarantee that
the image will work on all devices, irrespectively on the amount of initial bad
eraseblocks.</p>

<p>Fundamentally, <code>mkfs.ubifs</code> has to know file-system size because
UBIFS maintains and stores per-LEB information (like amount of dirty and free
space in each LEB) in so-called LPT area on the media. So obviously, the size of
this area depends on the total amount of LEBs, i.e. on the volume size. Note,
various characteristics of the LPT B-tree depend on the LPT area size, e.g., we
use less bits in LPT tree keys of smaller LPT area. So do not use unnecessarily
large <code>--max-leb-cnt</code> value to achieve better performance.</p>



<h2><a name="L_loop_mount">Can UBIFS mount loop-back devices?</a></h2>

<p>Unfortunately not, because loop-back devices are block devices (backed by
regular files), while UBIFS works on top of UBI devices
(see <a href="../doc/ubifs.html#L_rednote">here</a>).</p>

<p>However, there is a very hacky way to make UBIFS work with a file-backed
image using NAND simulator (see <a href="nand.html#L_nand_nandsim">here</a>).
Originally <code>nandsim</code> has been created to emulate NAND flashes in
RAM, but there is a
<a href="http://lists.infradead.org/pipermail/linux-mtd/2008-May/021810.html">patch</a>
which teaches <code>nandsim</code> to use a file instead of memory. Try
something like</p>

<pre>
# Create a 1GiB emulated MTD device backed by regular file "my_image"
$ modprobe nandsim cache_file=my_image first_id_byte=0xec second_id_byte=0xd3 third_id_byte=0x51 fourth_id_byte=0x95
</pre>

<p>See <a href="ubifs.html#L_ubifs_nandsim">here</a> for more instructions
about using UBIFS with nandsim.</p>

<p>But be warned that this patch has not been well tested, it is not in
mainline yet, and it has been created for development and debugging purposes,
but not for production use.</p>



<h2><a name="L_mkfs_ubifs_comp">How to compile mkfs.ubifs?</a></h2>

<p>The <code>mkfs.ubifs</code> utility requires <i>zlib</i>, <i>lzo</i> and
<i>uuid</i> libraries. The former two are used for compressing the data, and the
latter one is used for generating <i>universally unique ID number</i> for the
file-system. In Fedora install <code>zlib-devel</code>, <code>lzo-devel</code>,
and <code>e2fsprogs-devel</code> (<code>libuuid</code> is provided
there, strangely) packages, in Debian install <code>zlib1g-dev</code>,
<code>liblzo2-dev</code> and <code>uuid-dev</code> packages.</p>



<h2><a name="L_atomic_change">How to change a file atomically?</a></h2>

<p>Changing a file atomically means changing the contents in a way that unclean
reboots could not lead to any corruption or inconsistency in the file. The only
reliable way to do this in UBIFS (and in most of other file-systems, e.g. JFFS2
or ext3) is the following:</p>

<ul>
	<li>make a copy of the file;</li>
	<li>change the copy;</li>
	<li>synchronize the copy (see
	<a href="../doc/ubifs.html#L_writeback">here</a>);</li>
	<li>re-name the copy to the file (using the <code>rename()</code>
	<i>libc</i> function or <code>mv</code> utility).</li>
</ul>

<p>Note, if power-cut happens during re-naming, the original file will be
intact. This is <code>POSIX</code> requirement and UBIFS satisfies it.</p>



<h2><a name="L_atime">Does UBIFS support atime?</a></h2>

<p>No, it does not support atime. The authors think it is not very useful in
embedded and did not implement this. Indeed most of the users do not provably
want the file-system doing inode updates every time it is read.</p>



<h2><a name="L_nfs">Does UBIFS support NFS?</a></h2>

<p>No, UBIFS does not support NFS (Network File System) at the moment. This
means UBIFS directories cannot be exported via NFS. We are planning to add
NFS support at some point, this just has not been a priority.</p>



<h2><a name="L_ubifs_nandsim">How to use UBIFS with nandsim?</a></h2>

<p>The same way as with any MTD device. Here is an example of how to load
<code>nandsim</code>, create an UBI volume and mount it.</p>

<pre>
# Create an 256MiB emulated NAND flash
modprobe nandsim first_id_byte=0x20 second_id_byte=0xaa \
                 third_id_byte=0x00 fourth_id_byte=0x15

# MTD is not LDM-enabled and udev does not create device
# MTD device nodes automatically, so create /dev/mtd0
mknod /dev/mtd0 c 90 0

# Load UBI module and attach mtd0
modprobe ubi mtd=0

# Create a 200MiB UBI volume with name "ubifs-vol"
ubimkvol /dev/ubi0 -N ubifs-vol -s 200MiB

# Mount UBIFS
mount -t ubifs ubi0:ubifs-vol /mnt/ubifs
</pre>

<p>For more information about nandsim see
<a href="nand.html#L_nand_nandsim">here</a>.</p>


<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
