<PAGE>
<VAR match="VAR_ORIGIN" replace="../" />
<VAR match="VAR_CVSID" replace="Last updated: 23 Oct 2008, dedekind"/>
<INCLUDE file="../inc/header.tmpl" />

<VAR match="VAR_SEL_FAQ" replace="selected" />
<VAR match="VAR_SEL_UBIFS" replace="selected" />
<PARSE file="../menu1.xml" />

<INCLUDE file="../inc/content.tmpl" />

<h1>UBIFS FAQ and HOWTO</h1>

<h2>Table of contents</h2>
<ol>
	<li><a href="ubifs.html#L_ubifs_mlc">May UBIFS be used on MLC NAND flash?</a></li>
	<li><a href="ubifs.html#L_mount_ubifs">How to mount UBIFS?</a></li>
	<li><a href="ubifs.html#L_mkfubifs">How to create an UBIFS image?</a></li>
	<li><a href="ubifs.html#L_find_lebsz">How to find out LEB size?</a></li>
	<li><a href="ubifs.html#L_emptyflash">May an empty UBI volume be mounted?</a></li>
	<li><a href="ubifs.html#L_max_leb_cnt">What is the purpose of -c (--max-leb-cnt) mkfs.ubifs option?</a></li>
	<li><a href="ubifs.html#L_mkfs_ubifs_comp">How to compile mkfs.ubifs?</a></li>
	<li><a href="ubifs.html#L_loop_mount">Can UBIFS mount loop-back devices?</a></li>
	<li><a href="ubifs.html#L_atomic_change">How to change a file atomically?</a></li>
	<li><a href="ubifs.html#L_atime">Does UBIFS support atime?</a></li>
	<li><a href="ubifs.html#L_nfs">Does UBIFS support NFS?</a></li>
	<li><a href="ubifs.html#L_slow_when_full">Does UBIFS become slower when it is full?</a></li>
	<li><a href="ubifs.html#L_df_report">Why <code>df</code> reports too few free space?</a></li>
	<li><a href="ubifs.html#L_comproff">How to disable compression?</a></li>
	<li><a href="ubifs.html#L_ubifs_nandsim">How to use UBIFS with nandsim?</a></li>
	<li><a href="ubifs.html#L_powercut">Is UBIFS tolerant to power-cuts?</a></li>
	<li><a href="ubifs.html#L_smaller_jrn">I need more space - should I make UBIFS journal smaller?</a></li>
	<li><a href="ubifs.html#L_sudden_ro">UBIFS suddenly became read-only - what is this?</a></li>
	<li><a href="ubifs.html#L_study_ubifs">I want to study UBIFS - any recommendations?</a></li>
</ol>



<h2><a name="L_ubifs_mlc">May UBIFS be used on MLC NAND flash?</a></h2>

<p>Yes, it should run fine. Let's consider the specific aspects of MLC
NAND flashes:</p>

<ul>
	<li>MLC NAND flashes are more "faulty" than SLC, so they use stronger
	ECC codes which occupy whole OOB area; this is not a problem
	for UBI/UBIFS, because neither UBIFS nor UBI use OOB area;</li>

	<li>when the data is written to an eraseblock, it has to be written
	sequentially, from the beginning of the eraseblock to the end of it;
	this is also not a problem because it is exactly what UBI and UBIFS do
	(see also <a href="../faq/ubi.html#L_restrict">this</a> section);</li>

	<li>MLC flashes have rather short eraseblock life-cycle of just few
	thousand of erase cycles; and this is not be a problem, because UBI
	uses deterministic wear-leveling algorithm
	(see <a href="../faq/ubi.html#L_mlc">this</a> section).</li>
</ul>



<h2><a name="L_mount_ubifs">How to mount UBIFS?</a></h2>

<p>UBIFS mounts UBI volumes, not UBI devices, not MTD devices. There are no
block device nodes corresponding to UBI volumes and UBIFS uses device-less
mount, just like <code>procfs</code> or <code>sysfs</code>. The volume to
mount is specified using <code>ubiX_Y</code> or <code>ubiX:NAME</code>
syntax, where</p>

<ul>
	<li><code>X</code> - UBI device number;</li>
	<li><code>Y</code> - UBI volume number;</li>
	<li><code>NAME</code> - UBI volume name.</li>
</ul>

<p>For example,</p>

<pre>
$ mount -t ubifs ubi0_0 /mnt/ubifs
</pre>

<p>mounts volume 0 on UBI device 0 to <code>/mnt/ubifs</code>, and</p>

<pre>
$ mount -t ubifs ubi0:rootfs /mnt/ubifs
</pre>

<p>mounts "rootfs" volume of UBI device 0 to <code>/mnt/ubifs</code> ("rootfs"
is volume name). This method of specifying UBI volume is more preferable
because it does not depend on volume number.</p>

<p>Note, if <code>X</code> is not specified, UBIFS uses 0, i.e.,
"<code>ubi0:rootfs</code>" and "<code>ubi:rootfs</code>" are
equivalent.</p>

<p>Some environments like busybox are confused by the ":" delimiter (e.g.,
<code>ubi:rootfs</code>) and "!" may be used instead (e.g.,
<code>ubi!rootfs</code>).</p>

<p>The following is an example of the kernel boot arguments to attach
<code>mtd0</code> to UBI and mount volume "rootfs":</p>

<pre>
ubi.mtd=0 root=ubi0:rootfs rootfstype=ubifs
</pre>

<p>Please, see <a href="ubi.html#L_attachmtd">this</a> section for
information about how to create UBI devices and
<a href="ubi.html#L_mkvol">this</a> section for information about how to create
UBI volumes.</p>



<h2><a name="L_mkfubifs">How to create an UBIFS image?</a></h2>

<p>Creating UBIFS images might be a little trickier than creating JFFS2 images.
First of all, you have to understand that UBIFS works on top of UBI which works
on top or MTD which basically represents your raw flash. This means, that if
you need to create an image which would be flashed to the raw flash, you should
first create an UBIFS image, than UBI image. In other words, the process has 2
steps.</p>

<p>However, as described <a href="../doc/ubi.html#L_volupdate">here</a>,
UBI has a volume update facility and there is an
<a href="../doc/ubi.html#L_usptools"><code>ubiupdatevol</code></a> utility
which for this. So you may update UBI volumes straight form your
running system as well. In this case, you only need UBIFS image, and you do not
have to make the UBI image, i.e., the process has only 1 step in this case.</p>

<p>So, there are 2 utilities:</p>
<ul>
	<li><a href="../doc/ubifs.html#L_usptools"><code>mkfs.ubifs</code></a>
	which creates UBIFS images;</li>
	<li><a href="../doc/ubi.html#L_usptools"><code>ubinize</code></a>
	which creates UBI images.</li>
</ul>

<p>And depending on the needs you use either <code>mkfs.ubifs</code> or
<code>mkfs.ubifs</code> plus <code>ubinize</code>. Choose the former if you are
going to upload the update UBIFS image on your target and then update the UBI
volume using <code>ubiupdatevol</code>. Choose the latter if you are going to
flash the image to raw flash, e.g., at the factory.</p>

<p>The UBI and UBIFS images depend on parameters of the flash they are going to
be used on. Namely, you have to know the following characteristics of the flash
before creating images:</p>

<ul>
	<li>flash size;</li>
	<li>physical eraseblock size;</li>
	<li>minimum flash input/output unit size;</li>
	<li>for NAND flashes, sub-page size;</li>
	<li>logical eraseblock size.</li>
</ul>

<p><a href="../faq/ubi.html#L_find_min_io_size">This</a> and
<a href="ubifs.html#L_find_lebsz">this</a> sections explain the above
parameters and give some hints about how to find them out.</p>

<p>And optionally, you should decide which compression algorithm you would want
to use for this file-system. UBIFS supports zlib and LZO (default) at the
moment. Generally, zlib compresses better, but it is slower on both compression
and decompression. So this is a trade-off between space savings and speed. The
best idea is to try both and choose the one which is more appropriate for you.
But if flash space is not a big issue, it is recommended to use LZO.
Alternatively, the compression may be switched off. See "<code>-x</code>"
option of the <code>mkfs.ubifs</code> utility.</p>

<p>There are other advanced file-system and UBI characteristics which may be
altered with the tools. Use them only if you understand what they do.</p>

<p>The below example demonstrates how to create an UBI/UBIFS image for a 256MiB
SLC OneNAND flash chip with 128KiB physical eraseblocks, 2048 bytes NAND pages, and
which supports 4 sub-pages (this means that it allows to do 4x512 bytes writes
to the same NAND page, which is quite typical for SLC flashes). The resulting
image will have one UBI volume storing UBIFS file-system.</p>

<pre>
$ mkfs.ubifs -r root-fs -m 2048 -e 129024 -c 2047 -o ubifs.img
$ ubinize -o ubi.img -m 2048 -p 128KiB -s 512 ubinize.cfg
</pre>

<p>where <code>ubinize.cfg</code> contains:</p>

<pre>
$ cat ubinize.cfg
[ubifs]
mode=ubi
image=ubifs.img
vol_id=0
vol_size=200MiB
vol_type=dynamic
vol_name=rootfs
vol_flags=autoresize
</pre>

<p>Some comments about what the options mean:</p>

<ul>
	<li><code>-r root-fs</code>: tells <code>mkfs.ubifs</code> to create an
	UBIFS image which would have identical contents as the local
	<code>root-fs</code> directory has;</li>

	<li><code>-m 2048</code>: tells <code>mkfs.ubifs</code> that the minimum
	input/output unit size of the flash this UBIFS image is created for is
	2048 bytes;</li>

	<li><code>-e 129024</code>: logical eraseblock size of the UBI volume
	this image is created for;</li>

	<li><code>-c 2047</code>: specifies maximum file-system size in logical
	eraseblocks; this means that it will be possible to use the resulting
	file-system on volumes up to this size (less or equivalent); so in this
	particular case, the resulting FS may be put on volumes up to about
	251MiB (129024 multiplied by 2047);</li>

	<li><code>-p 128KiB</code>: tells <code>ubinize</code> that physical
	eraseblock size of the flash chip the UBI image is created for is
	128KiB (128 * 1024 bytes);</li>

	<li><code>-s 512</code>: tells <code>ubinize</code> that the flash
	supports sub-pages and sub-page size is 512 bytes; <code>ubinize</code>
	will take this into account and put the VID header to the same NAND
	page as the EC header.</li>
</ul>

<p>The <code>ubinize</code> utility requires volumes description file. Please,
refer <a href="../faq/ubi.html#L_ubi_mkimg">this</a> section for more
<code>ubinize</code> usage information.</p>

<p>In the example, the <code>ubinize.cfg</code> file tells <code>ubinize</code>
to create an UBI image which has a singe 200MiB dynamic volume with ID 0, and
name "rootfs". The configuration file also sets the "autoresize" volume flag,
which means that the volume will be automatically enlarged by UBIFS to have
the maximum possible size when it runs for the first time. See
<a href="../doc/ubi.html#L_autoresize">here</a> for more information about what
the auto-resize feature is.</p>

<p>Please, run <code>ubinize -h</code> and <code>mkfs.ubifs -h</code> for more
information and for more possibilities to tweak the generated images.</p>

<p>Here is one more example for a 32MiB NOR flash with 128KiB physical
eraseblock size.</p>

<pre>
$ mkfs.ubifs -r root-fs -m 1 -e 130944 -c 255 -o ubifs.img
$ ubinize -o ubi.img -m 1 -p 128KiB ubinize.cfg
</pre>

<p>where <code>ubinize.cfg</code> contains:</p>

<pre>
$ cat ubinize.cfg
[ubifs]
mode=ubi
image=ubifs.img
vol_id=0
vol_size=30MiB
vol_type=dynamic
vol_name=rootfs
vol_alignment=1
vol_flags=autoresize
</pre>

<p>And one more example for a 512MiB MLC NAND flash with 128KiB physical
eraseblock size, 2048 bytes NAND page size and no sub-page write
support.</p>

<pre>
$ mkfs.ubifs -r root-fs -m 2048 -e 126976 -c 4095 -o ubifs.img
$ ubinize -o ubi.img -m 2048 -p 128KiB ubinize.cfg
</pre>

<p>where <code>ubinize.cfg</code> contains:</p>

<pre>
$ cat ubinize.cfg
[ubifs]
mode=ubi
image=ubifs.img
vol_id=0
vol_size=450MiB
vol_type=dynamic
vol_name=rootfs
vol_alignment=1
vol_flags=autoresize
</pre>



<h2><a name="L_find_lebsz">How to find out LEB size?</a></h2>

<p>When creating UBIFS images it is necessary to know logical eraseblock
size which depends on the following flash chip parameters:</p>
<ul>
	<li>physical eraseblock size;</li>
	<li>minimum input/output unit size;</li>
	<li>sub-page size;</li>
</ul>

<p>Please, refer <a href="../faq/ubi.html#L_find_min_io_size">this</a> section
for more information about how to find those 3 parameters. Here are the most
typical configurations:</p>
<ul>
	<li>NOR flash with 1 byte min. I/O unit size: LEB size is PEB size
	minus 128;</li>
	<li>NAND flash with 512 byte NAND page and 265 byte sub-page: LEB size
	is PEB size minus 512;</li>
	<li>NAND flash with 2048 byte NAND page and 512 byte sub-page: LEB size
	is PEB size minus 2048;</li>
	<li>NAND flash with 2048 byte NAND page and no sub-page: LEB size
	is PEB size minus 4096.</li>
</ul>

<p>Please, also refer <a href="../doc/ubi.html#L_overhead">this</a> section for
additional information.</p>

<p>The easiest way to find out the LEB size is to attach the MTD device to UBI,
as it is suggested at the end of
<a href="../faq/ubi.html#L_find_min_io_size">this</a> section.</p>



<h2><a name="L_emptyflash">Is it OK to mount empty UBI volumes?</a></h2>

<p>Yes, it is OK to mount empty UBI volumes, i.e. the volumes which
contain only 0xFF bytes. In this case UBIFS formats the media automatically
with default parameters (journal size, compression, etc). But generally, this
feature should have limited use, and a proper UBIFS image should
preferably be flashed created
(see <a href="ubifs.html#L_mkfubifs">this</a> section).</p>

<p>Note, UBI has similar property and it automatically formats the flash media
if it is empty (see <a href="../faq/ubi.html#L_format_mtd">here</a>). So if
there is an <code>mtd0</code> MTD device, the following will work:</p>

<pre>
# Wipe the MTD device out. Note, we could use flash_eraseall, but we do not
# want to loose erase counters
ubiformat /dev/mtd0

# Load UBI module
modprobe ubi

# Attach mtd0 to UBI - UBI will detect that the MTD device is
# empty and automatically format it. This command will also create
# UBI device 0 and udev should create /dev/ubi0 node
ubiattach /dev/ubi_ctrl -m 0

# Create an UBI volume - the created volume will be empty
ubimkvol /dev/ubi0 -N test_volume -s 10MiB

# Mount UBIFS - it will automatically format the empty volume
mount -t ubifs ubi0:test_volume /mnt/ubifs
</pre>

<p>It is also possible to wipe out an existing UBIFS volume represented
by <code>/dev/ubi0_0</code> using the following command:</p>

<pre>
ubiupdatevol /dev/ubi0_0 -t
</pre>



<h2><a name="L_max_leb_cnt">
	What is the purpose of -c (--max-leb-cnt) mkfs.ubifs option?
</a></h2>

<p>It is a form of specifying file-system size. But instead of specifying the
exact file-system size, this option defines the <i>maximum</i> file-system
size (more strictly, maximum UBI volume size). For example, if you use
<code>--max-leb-cnt=200</code> <code>mkfs.ubifs</code> option, than it will be
possible to put the resulting image to smaller UBI volume and mount it. But if
the image is put to a larger UBI volume, the file-system will anyway take only
first 200 LEBs, and the rest of the volume will be wasted.</p>

<p>Note, the <code>--max-leb-cnt</code> option does not affect the size of the
resulting image file, which depends only on the amount of data in the
file-system. <code>mkfs.ubifs</code> just writes the <code>--max-leb-cnt</code>
value to the file-system superblocks.</p>

<p>This feature is quite handy on NAND flashes, because they have random amount
of initial bad eraseblocks (marked as bad in production). This means, that
different devices may have slightly different volume sizes (especially if the
UBI <a href="../doc/ubi.html#L_autoresize">auto-resize</a> feature is used). So
you may specify the maximum possible volume size and this will guarantee that
the image will work on all devices, irrespectively on the amount of initial bad
eraseblocks.</p>

<p>Fundamentally, <code>mkfs.ubifs</code> has to know file-system size because
UBIFS maintains and stores per-LEB information (like amount of dirty and free
space in each LEB) in so-called LPT area on the media. So obviously, the size of
this area depends on the total amount of LEBs, i.e. on the volume size. Note,
various characteristics of the LPT B-tree depend on the LPT area size, e.g., we
use less bits in LPT tree keys of smaller LPT area. So do not use unnecessarily
large <code>--max-leb-cnt</code> value to achieve better performance.</p>



<h2><a name="L_loop_mount">Can UBIFS mount loop-back devices?</a></h2>

<p>Unfortunately not, because loop-back devices are block devices (backed by
regular files), while UBIFS works on top of UBI devices
(see <a href="../doc/ubifs.html#L_rednote">here</a>).</p>

<p>However, there is a very hacky way to make UBIFS work with a file-backed
image using NAND simulator (see <a href="nand.html#L_nand_nandsim">here</a>).
Originally <code>nandsim</code> has been created to emulate NAND flashes in
RAM, but there is a
<a href="http://lists.infradead.org/pipermail/linux-mtd/2008-May/021810.html">patch</a>
which teaches <code>nandsim</code> to use a file instead of memory. Try
something like</p>

<pre>
# Create a 1GiB emulated MTD device backed by regular file "my_image"
$ modprobe nandsim cache_file=my_image first_id_byte=0xec second_id_byte=0xd3 third_id_byte=0x51 fourth_id_byte=0x95
</pre>

<p>See <a href="ubifs.html#L_ubifs_nandsim">here</a> for more instructions
about using UBIFS with nandsim.</p>

<p>But be warned that this patch has not been well tested, it is not in
mainline yet, and it has been created for development and debugging purposes,
but not for production use.</p>



<h2><a name="L_mkfs_ubifs_comp">How to compile mkfs.ubifs?</a></h2>

<p>The <code>mkfs.ubifs</code> utility requires <i>zlib</i>, <i>lzo</i> and
<i>uuid</i> libraries. The former two are used for compressing the data, and the
latter one is used for generating <i>universally unique ID number</i> for the
file-system. In Fedora install <code>zlib-devel</code>, <code>lzo-devel</code>,
and <code>e2fsprogs-devel</code> (<code>libuuid</code> is provided
there, strangely) packages, in Debian install <code>zlib1g-dev</code>,
<code>liblzo2-dev</code> and <code>uuid-dev</code> packages.</p>



<h2><a name="L_atomic_change">How to change a file atomically?</a></h2>

<p>Changing a file atomically means changing the contents in a way that unclean
reboots could not lead to any corruption or inconsistency in the file. The only
reliable way to do this in UBIFS (and in most of other file-systems, e.g. JFFS2
or ext3) is the following:</p>

<ul>
	<li>make a copy of the file;</li>
	<li>change the copy;</li>
	<li>synchronize the copy (see
	<a href="../doc/ubifs.html#L_writeback">here</a>);</li>
	<li>re-name the copy to the file (using the <code>rename()</code>
	<i>libc</i> function or <code>mv</code> utility).</li>
</ul>

<p>Note, if power-cut happens during re-naming, the original file will be
intact. This is <code>POSIX</code> requirement and UBIFS satisfies it.</p>



<h2><a name="L_atime">Does UBIFS support atime?</a></h2>

<p>No, it does not support atime. The authors think it is not very useful in
embedded world and did not implement this. Indeed most of the users do not
provably want the file-system doing inode updates every time it is read.</p>



<h2><a name="L_nfs">Does UBIFS support NFS?</a></h2>

<p>Not so far, but it is planned to be implemented.</p>



<h2><a name="L_slow_when_full">Does UBIFS become slower when it is full?</a></h2>

<p>Yes, UBIFS writes (but not reads) become slower when it is full or close to
be full. There are 2 main reasons for this:</p>

<ul>
	<li>Garbage Collection becomes slower, because the small pieces of
	dirty space are distributed all over the media, and UBIFS Garbage
	Collector has to move many eraseblocks to produce one free eraseblock;
	this is a fundamental reason and it exists in JFFS2 as well;</li>

	<li>The file-system becomes more synchronous; UBIFS buffers dirty data,
	but due to compression and some other factors like wasting small pieces
	of space at the end of eraseblocks, UBIFS does not exactly know how much
	space the buffered dirty data would take on the flash media, so it uses
	pessimistic calculations and assumes that the data is uncompressible.
	In many cases this is not true, but UBIFS has to assume
	worst-case scenario. So when all free space on the file-system is
	reserved for the buffered dirty data, but users want to write more,
	UBIFS forces write-back to actually write the buffered dirty data and
	see how much space will be available after that. Then UBIFS may allow
	new data to be written. Thus, it is obvious that the less free
	flash space is available, the less dirty data may be buffered, and
	the more synchronous the file-system becomes.</li>
</ul>



<h2><a name="L_df_report"> Why <code>df</code> reports too few free space?</a></h2>

<p>UBIFS flash space accounting is quite challenging and it is not always
possible to report accurate amount of free space. The <code>df</code> utility
usually reports <i>less</i> free space than users may actually write to the
file-system, but it <i>never</i> reports more space.</p>

<p>UBIFS cannot precisely predict how much data the user will
be able to write to the file-system. There are several reasons for this -
compression, write-back, space wastage at the end of logical eraseblocks,
garbage-collection, etc. Please, refer
<a href="../doc/ubifs.html#L_spaceacc">this</a> section for details.</p>

<p>Note, JFFS2 also has problems with free space predictions, but in average,
it reports much more accurate amount of free space. However, JFFS2 may lie and
report more free space than it actually has. For example, we experienced
situations when JFFS2 reported 8MiB free space, while we were able to write
only 2 MiB of data. This makes some user-space applications very unhappy.</p>

<p>UBIFS also lies, but it always report <i>less</i> space that user may
actually write. For example, it may report 2MiB of free space, but if you
start writing to it, may be able to write 4MiB there (even if you have
compression disabled).</p>

<p>Thus, the only way to find out <i>precise</i> amount of free space is to
fill up the file-system and see how much has been written. Try something like
this:</p>

<pre>
$ touch /mnt/ubifs/file
$ chattr -c /mnt/ubifs/file # Disable compression for this file
$ dd if=/dev/zero of=/mnt/ubifs/file bs=4096
</pre>

or

<pre>
# Presumably random data does not compress
dd if=/dev/urandom of=/mnt/ubifs/file bs=4096
</pre>

<p>and see the size of the file.</p>

<p>UBIFS users should know that the more dirty cached FS data is there, the
less precise is the <code>df</code> report. Try to create a big file, and
look at the <code>df</code> report. Then synchronize the file-system (using the
<code>sync</code> command) and look at the <code>df</code> report again. You
should notice that <code>df</code> reports more free space after the
synchronization. Here is an example:</p>

<pre>
# Create a 64MiB uncompressible file
$ dd if=/dev/urandom of=/mnt/ubifs/file bs=8192 count=8192
$ df
Filesystem           1K-blocks      Used Available Use% Mounted on
ubi0:ubifs              117676     68880     43736  62% /mnt/ubifs

$ sync
$ df
Filesystem           1K-blocks      Used Available Use% Mounted on
ubi0:ubifs              117676     64304     48308  58% /mnt/ubifs
</pre>

<p>Notice that the amount of free space increased by 4%. However, that was an
uncompressible file. Here is a similar example, but which uses a file which
compresses well:</p>

<pre>
# Create a 64MiB file containing zeroes
$ dd if=/dev/zero of=/mnt/ubifs/file bs=8192 count=8192
$ df
Filesystem           1K-blocks      Used Available Use% Mounted on
ubi0:ubifs              117676     69312     43304  62% /mnt/ubifs

$ sync
$ df
Filesystem           1K-blocks      Used Available Use% Mounted on
ubi0:ubifs              117676      7052    105564   7% /mnt/ubifs
</pre>

<p>If instead of synchronizing the file-system you just watch how
the <code>df</code> report is changing, you will notice that the amount of free
space continuously grows until reaches its final value. This happens because the
kernel starts writing the dirty data back by time-out (5 sec by default) and
the amount of dirty data goes down, making the <code>df</code> report more
precize.</p>

<p>If you want to have as precise free space prediction as possible -
synchronize the file-system. This not only flushes dirty data to the media,
this also commits UBIFS journal, which improves free space prediction even
more. The other possibility is to mount UBIFS in synchronous mode using
<code>-o sync</code> mount option. However, it may perform not as well as in
asynchronous (default) mode.</p>

<p>It is also worth noting that the closer is UBIFS to being full, the less
accurate is free space reporting.</p>

<p>To conclude:</p>
<ul>
	<li>do not trust <code>df</code> free space reports;</li>
	<li><code>df</code> reports <i>less</i> free space in most cases;</li>
	<li>if <code>df</code> reports <code>X</code> bytes of free space, you
	are guaranteed to be able to write at least <code>X</code> bytes
	of data to a file, but usually more than <code>X</code> bytes;</li>
	<li>run <code>sync</code> to get the most accurate <code>df</code>
	report; alternatively, you may mount UBIFS in synchronous mode using
	<code>-o sync</code> mount option;</li>
	<li>read <a href="../doc/ubifs.html#L_spaceacc">this</a> section if you
	are curious why UBIFS has issues with <code>df</code>.</li>
</ul>



<h2><a name="L_comproff">How to disable compression?</a></h2>

<p>UBIFS compression may be disabled for whole file system during the image
creation time using the "<code>-x none</code>" <a
href="ubifs.html#L_mkfubifs"><code>mkfs.ubifs</code></a> option. However,
if UBIFS compression is enabled, it may be disabled for individual files by
cleaning the inode <i>compression flag</i>:</p>

<pre>
$ chattr -c /mnt/ubifs/file
</pre>

<p>in <code>shell</code>, or</p>

<pre>
/* Get inode flags */
ioctl(fd, FS_IOC_GETFLAGS, &amp;flags);
/* Set "compression" flag */
flags &amp;= ~FS_COMPR_FL;
/* Change inode flags */
ioctl(fd, FS_IOC_SETFLAGS, &amp;flags);
</pre>

<p>in <code>C</code> programs. Similarly, if compression is disabled by
default, you may enable if for individual inodes by setting the compression
flag. Note, the code which uses the compression flag works fine on other Linux
file-systems, because the flag is just ignored in this case.</p>

<p>It might be a good idea to disable compression for say, <code>mp3</code> or
<code>jpeg</code> files which would anyway not compress and UBIFS would just
waste CPU time trying to compress them. The compression may also be disabled if
one wants faster file I/O, because UBIFS would not need to compress or
decompress the data on reads and write. However, I/O speed may actually become
slower if compression is disabled. Indeed, in case of a very fast CPU and very
slow flash compressed writes are faster, but this is usually not true for
embedded systems.</p>



<h2><a name="L_ubifs_nandsim">How to use UBIFS with nandsim?</a></h2>

<p>The same way as with any MTD device. Here is an example of how to load
<code>nandsim</code>, create an UBI volume and mount it.</p>

<pre>
# Create an 256MiB emulated NAND flash
modprobe nandsim first_id_byte=0x20 second_id_byte=0xaa \
                 third_id_byte=0x00 fourth_id_byte=0x15

# MTD is not LDM-enabled and udev does not create device
# MTD device nodes automatically, so create /dev/mtd0
mknod /dev/mtd0 c 90 0

# Load UBI module and attach mtd0
modprobe ubi mtd=0

# Create a 200MiB UBI volume with name "ubifs-vol"
ubimkvol /dev/ubi0 -N ubifs-vol -s 200MiB

# Mount UBIFS
mount -t ubifs ubi0:ubifs-vol /mnt/ubifs
</pre>

<p>For more information about nandsim see
<a href="nand.html#L_nand_nandsim">here</a>.</p>



<h2><a name="L_powercut">Is UBIFS tolerant to power-cuts?</a></h2>

<p>Yes, both UBI (see <a href="ubi.html#L_crash_safe">here</a>) and UBIFS are
tolerant to power-cuts, and they were designed with this property in mind.</p>

<p>UBIFS has internal debugging infrastructure to emulate power failures and
the authors used it for extensive testing. It was tested for long time with
power-fail emulation. The advantage of the emulation is that it emulates power
failures even at the situations which happen not very often. For example, when the
master node is updated, or the log is changed. The probability to interrupt the
system at those moments is very low in real-life.</p>

<p>Real power-cut tests have also been done on OneNAND flash. We used Power
Node devices which are controlled via serial line and may switch the power of
the connected device on and off. UBIFS survived more than 20000 power-cuts
while running stress tests.</p>



<h2><a name="L_smaller_jrn">I need more space - should I make UBIFS journal smaller?</a></h2>

<p>UBIFS journal is very different to ext3 journal. In case of ext3, the
journal has fixed position on the block device. The data is first written
to the journal, and then copied to the file-system. This copying is done during
the commit. After the commit, new data may be written to the journal, and so
on. So in case of ext3 changing journal size would change file-system
capacity.</p>

<p>The situation is different in UBIFS. UBIFS journal is "wandering". It does
not have fixed position in the UBI volume. When the journal is full, UBIFS is
committing it which means it simply amends the FS index to refer the data which
is stored in the journal. Then different LEBs are picked for the new journal,
and so on. So the journal constantly migrates. The journal contains the same
information as other data LEBs, but this information is just not referred from
the index, it is not indexed. But there is flash space reserved for the
indexing information, and this space is used during commit.</p>

<p>In other words, if your file-system is full, the journal will also be full
and contain data. And the situation does not really change if you vary journal
size.</p>

<p>To put it simple, the amount of available space on UBIFS does not really
depend on the journal size. There is very weak dependency, though, because for
bigger journal we need bigger log, but it is really something which does not
make any noticeable difference.</p>



<h2><a name="L_sudden_ro">UBIFS suddenly became read-only - what is this?</a></h2>

<p>Read-write UBIFS file-system may suddenly become read-only because of an
error. This is how UBIFS reacts on unexpected errors which it cannot properly
handle - it immediately switches to read-only mode in order to protect the data
from any possible further corruption.</p>

<p>If this happened, you should look at UBIFS-related <code>dmesg</code>
messages. UBIFS usually prints error messages before switching to read-only
mode. The messages may shed some light on what happened. Feel free to ask for
help from the <a href="../mail.html">MTD mailing list</a>. If you think this is
an UBIFS bug, please, send a
<a href="../doc/ubifs.html#L_how_send_bugreport">bug report</a>.</p>



<h2><a name="L_study_ubifs">I want to study UBIFS - any recommendations?</a></h2>

<p>Follow <a href="../doc/ubifs.html#L_documentation">these</a> instructions.</p>


<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
