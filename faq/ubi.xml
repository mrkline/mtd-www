<PAGE>
<VAR match="VAR_ORIGIN" replace="../" />
<VAR match="VAR_CVSID" replace="$Id: jffs2.xml,v 1.8 2006/03/31 14:38:41 jwboyer Exp $"/>
<INCLUDE file="../inc/header.tmpl" />

<VAR match="VAR_SEL_FAQ" replace="selected" />
<VAR match="VAR_SEL_UBI" replace="selected" />
<PARSE file="../menu1.xml" />

<INCLUDE file="../inc/content.tmpl" />


<A name="UBI_src">
<H2>How can I find UBI source?</H2>
</A>

<P>UBI is not yet in mainline kernel, and is currently accessible via git.
Please, read <A href="doc/git.html">MTD git page</A> for more information about
how to fetch GIT MTD trees. The UBI GIT repository is currently accessible via
SSL protocol at <CODE>ssh://git.infradead.org/home/git/ubi-2.6.git</CODE>. So,
the command to fetch the UBI git tree is:</P>

<PRE>
$ git-clone --reference linux-2.6 ssh://git.infradead.org/home/git/ubi-2.6.git
</PRE>

<P>The UBI git-tree mostly corresponds to 2.6.17 Linux kernel. You may extract
UBI patch and apply it to vanilla 2.6.17 Linux kernel or to another kernel
using the following command:</P>

<PRE>
$ git-diff 62ed948cb1405fe95d61d8c6445c102e0c9da0a6 > ubi-git.diff
</PRE>


<H2>What is "physical eraseblock" and "logical eraseblock"?</H2>

<P>These are terms used in UBI: UBI volumes consist of logical eraseblocks,
while the underlying MTD device consists of physical eraseblocks.</P>

<UL>
	<LI><B>Physical eraseblocks</B> are eraseblocks of the MTD device which
	is used by UBI as the back-end storage (i.e., physical eraseblocks are
	basically sectors of the flash device.</LI>

	<LI><B>Logical eraseblocks</B> are eraseblocks the UBI volume. Logical
	eraseblocks are less in size then physical eraseblocks because UBI
	stores its own headers at the beginning of each physical eraseblock.
	For example, in case of NOR flash, logical eraseblock is 64 bytes smaller
	then the physical eraseblock (note, how much UBI headers take depends
	on the MTD device type).</LI>
</UL>


<H2>What for does UBI need headers in physical eraseblocks?</H2>

<P>The headers are needed to keep track of erase counters and
physical-to-logical eraseblock associations. There are two UBI headers stored
in physical eraseblocks:</P>

<UL>
	<LI><B>erase counter header</B> (or <B>EC header</B>) which is mostly
	needed to store physical eraseblock's erase counter;</LI>

	<LI><B>volume identifier header</B> (or <B>VID header</B>) which stores
	volume ID and logical eraseblock number this physical eraseblock
	belongs to.</LI>
</UL>

<P>Note, there are also some other data stored in EC and VID headers, see
<CODE>mtd/ubi-header.h</CODE> file for more details.</P>

<P>The EC header is written to the physical eraseblock as soon as it is erased,
so each physical eraseblock in UBI has the EC header.</P>

<P>The VID header is written to the physical eraseblock only when UBI associates
it with a logical eraseblock, so each physical eraseblock which belongs to a
logical eraseblock in UBI has both EC and VID headers.</P>

<P>Both UBI headers are protected by CRC-32 checksums.</P>


<H2>How does UBI ensure wear-leveling?</H2>

<P>UBI keeps a small header at the beginning of each physical eraseblock which
contains the erase counter (the header is called <B>erase counter header</B>
or <B>EC header</B>). After each physical eraseblock erasure, the erase
counter is incremented.</P>

<P>Wear-leveling is ensured by the following two basic mechanisms.</P>
<UL>
	<LI><B>Data movement:</B>UBI moves data from less worn-out physical
	eraseblocks (low erase counter) to more worn-out physical eraseblocks
	(high erase counter) from time to time This ensures that static data
	is not stored in the same set of physical eraseblocks too long, and
	wear is evenly distributed over all physical eraseblocks.</LI>

	<LI><B>Picking appropriate eraseblocks:</B> when a free physical
	eraseblock is needed, UBI picks either a more worn-out physical
	eraseblock, or a less worn-out physical eraseblock, depending
	on the data which is going to be stored on this physical
	eraseblock. If this is long-term, static data, UBI picks a less
	worn-out physical eraseblock, if this is short-term,
	temporary data, UBI picks a more worn-out one, or, if data type
	is unknown, UBI picks a middle one. It's up to users to inform
	UBI whether the data they are writing to the volume is
	short-term, long-term or unknown.</LI>
</UL>

<P>The wear-leveling in UBI is ensured by the so-called <B>WL unit</B>. The idea
of the wear-levelling algorithm is fairly simple: there are two trees in the WL
unit - <I>free</I> and <I>used</I>. Both trees are Red-Black trees and are
indexed by the erase counter. Each physical eraseblock in UBI has a
corresponding small in-RAM data structure, and these data structures are the
elements of these Red-Black trees.</P>

<P>The <I>free</I> tree contains free physical eraseblocks (to be more precise,
the corresponding mentioned small data structures), the <I>used</I> tree contains
used physical eraseblocks. When the WL unit is asked to provide a free physical
eraseblock, it picks it from the <I>free</I> tree (taking into account the data
type hint), moves it to the <I>used</I> tree, and returns this physical
eraseblock number to the caller. When user returns a physical eraseblock to the
WL unit, it is removed from the <I>used</I> tree, scheduled for erasure, and
inserted back to the <I>free</I> tree. Note, the physical eraseblock erasure
is done in background, not synchronously, so it mostly does not block user
tasks.</P>

<P>The WL unit constantly looks at the difference between the lowest erase
counter in the <I>free</I> tree and the highest erase counter in the <I>used</I>
tree. If this difference exceeds certain threshold, the WL unit moves data from
the least worn-out physical eraseblock to a highly worn-out one. The movement is
done in background, in context of the UBI background thread, so it is completely
transparent to UBI users and consumes CPU and flash I/O bandwidth on competitive
basis.</P>

<P>Of course, as always, the implementation is more complex because of
different corner cases and optimizations. See <CODE>wl.c</CODE> and
<CODE>wl.h</CODE> files for more details.</P>

<P>Note, in this (first) implementation the UBI WL unit memory consumption
linearly depends on the total number of physical eraseblocks on the underlying
MTD device - there is a 32-byte in-RAM structure for each non-bad physical
eraseblock. In other words, the scalability is is not ideal. But as UBI is
highly modular inside (there is quite narrow interface between the WL unit and
the rest of UBI exists), on can implement the WL unit other way and improve
scalability, or just change the working algorithm.</P>



<H2>How to debug UBI?</H2>

<H3>Use fake MTD device</H3>

<P>When debugging UBI you don't have to use a real embedded platform and real
flash. You may use a PC with a mtd device emulator and run UBI on top of this
emulated MTD device.</P>

<P>There are 3 MTD device emulators:</P>
<UL>
	<LI><B>mtdram</B> which simulates NOR flash in RAM;</LI>
	<LI><B>nandsim</B> which simulates NAND flash in RAM;</LI>
	<LI><B>block2mtd</B> which simulates NOR flash on top of a block device;</LI>
</UL>

<P>So, for example, to get a 32MiB fake NOR flash, run
"<CODE>modprobe mtdram total_size=32768</CODE>"
or if you need a 64MiB fake NAND flash, run
"<CODE>modprobe nandsim second_id_byte=0x36</CODE>".</P>

<P>Note, nandsim's module parameters are rather obfuscated, they mean NAND ID
bytes, which identify flash geometry. Basically, you have to look at nand_bbt.c
and pick your NAND IDs. Somebody definitely should make it more user-friendly.</P>

<P>To ensure you have fake MTD devices, run "<CODE>cat /proc/mtd</CODE>". You
have to see something like</P>
<PRE>
dev:    size   erasesize  name
mtd0: 02000000 00020000 "mtdram test device"
mtd1: 04000000 00004000 "NAND simulator partition"
</PRE>

<P>Now you should load the UBI module:
"<CODE>modprobe ubi mtd_devs=0,1</CODE>",
which will attach both mtd0 and mtd1 devices to UBI, and you'll end up with 2
UBI devices.</P>

<P>Should all go smoothly, you have to see corresponding UBI entries in your
sysfs:</P>
<PRE>
# ls /sys/class/ubi/
debug  ubi0  ubi1  version
</PRE>

<P>Now you may start hacking/debugging UBI even without an embedded platform
and without a real flash device.</P>


<H3>Enable debugging messages</H3>

<P>UBI makes it possible to enable debugging messages which greatly help when
hunting bugs. As UBI internally consists of several separate software units,
debugging messages may be toggled for different units separately. So, if you
suspect a certain UBI unit, enable the corresponding debugging messages.</P>

<P>UBI supports so called "dynamic debugging", which may be enabled in the
Linux configuration menu (re-compilation is required). If it is enabled, you'll
have <CODE>class/ubi/debug/</CODE> directory in your sysfs tree, and
you'll be able to enable/disable debugging by writing ASCII 0 or 1 to files in
this directory. For example
<PRE>
echo 1 > /sys/class/ubi/debug/debug_wl
</PRE>
enables debugging messages from the UBI wear-leveling unit. The cost of dynamic
debugging is larger and a bit slower code.</P>

<H3>Enable assertions and paranoid checks</H3>

<P>UBI code includes assertions and so-called "paranoid checks" which are
designated to facilitate bug hunting. You may consider to enable them to catch
problems on earlier stages.</P>

<P>Both paranoid checks and assertions may be enabled under "UBI debugging"
Linux configuration menu option (re-compilation is required). Paranoid checks
may be enabled/disabled separately for each UBI unit.</P>

<P>Note, some paranoid checks make UBI considerably slower, especially the
I/O unit paranoid checks.</P>

<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
