<PAGE>
<VAR match="VAR_ORIGIN" replace="../" />
<VAR match="VAR_CVSID" replace="$Id: jffs2.xml,v 1.8 2006/03/31 14:38:41 jwboyer Exp $"/>
<INCLUDE file="../inc/header.tmpl" />

<VAR match="VAR_SEL_FAQ" replace="selected" />
<VAR match="VAR_SEL_UBI" replace="selected" />
<PARSE file="../menu1.xml" />

<INCLUDE file="../inc/content.tmpl" />



<H2>Table of contents</H2>
<OL>
	<LI><A HREF="ubi.html#L_abbrev">Abbreviations</A></LI>
	<LI><A HREF="ubi.html#L_enable_ubi">How to enable UBI?</A></LI>
	<LI><A HREF="ubi.html#L_run_ubi">How to run UBI on top of my MTD device?</A></LI>
	<LI><A HREF="ubi.html#L_run_jffs2">Can I run JFFS2 on top of UBI volumes?</A></LI>
	<LI><A HREF="ubi.html#L_bootloader">Should my boot-loader know UBI format?</A></LI>
	<LI><A HREF="ubi.html#L_ext2_over_ubi">Can I run file systems like ext2 on top of UBI?</A></LI>
	<LI><A HREF="ubi.html#L_format_mtd">Do I have to format my empty flash before running UBI on top of it?</A></LI>
	<LI><A HREF="ubi.html#L_leb_and_peb">What is "physical eraseblock" and "logical eraseblock"?</A></LI>
	<LI><A HREF="ubi.html#L_restrict">Can I randomly write to logical eraseblocks?</A></LI>
	<LI><A HREF="ubi.html#L_volume_update">What is volume update?</A></LI>
	<LI><A HREF="ubi.html#L_why_headers">What for does UBI need headers in physical eraseblocks?</A></LI>
	<LI><A HREF="ubi.html#L_why_2_hdrs">Why does UBI need two headers, not just one?</A></LI>
	<LI><A HREF="ubi.html#L_why_no_oob">Why UBI does not use OOB area of NAND flashes?</A></LI>
	<LI><A HREF="ubi.html#L_hdrsize">How much flash space do UBI headers consume?</A></LI>
	<LI><A HREF="ubi.html#L_volume_table">What is volume table?</A></LI>
	<LI><A HREF="ubi.html#L_crash_safe">Is UBI tolerant of power failures?</A></LI>
	<LI><A HREF="ubi.html#L_how_debug">How to debug UBI?</A></LI>
	<LI><A HREF="ubi.html#L_how_send_bugreport">How to send a bugreport?</A></LI>
</OL>



<A NAME="L_abbrev">
<H3>Abbreviations</H3>
</A>

<P>The following is a list of abbreviations used in this FAQ:</P>
<UL>
	<LI><I>EC header</I> - erase counter header (see <A HREF="ubi.html#L_why_headers">here</A>);</LI>
	<LI><I>LEB</I> - logical eraseblock (see <A HREF="ubi.html#L_leb_and_peb">here</A>);</LI>
	<LI><I>PEB</I> - physical eraseblock (see <A HREF="ubi.html#L_leb_and_peb">here</A>);</LI>
	<LI><I>VID header</I> - volume identifier header (see <A HREF="ubi.html#L_why_headers">here</A>);</LI>
</UL>



<A NAME="L_enable_ubi">
<H2>How to enable UBI?</H2>
</A>

<P>In the linux configuration menu, go to "<B>Device Drivers</B>" ->
"<B>Memory Technology Devices (MTD)</B>" -> "<B>UBI - Unsorted block images</B>",
and mark the "<B>Enable UBI</B>" check-box. UBI may be either compiled into the
kernel or built as a kernel module.</P>



<A NAME="L_run_ubi">
<H2>How to run UBI on top of my MTD device?</H2>
</A>

<H3>A kernel module</H3>

<P>Suppose you have an <CODE>mtd3</CODE> device and want to run UBI on top of
it. The following command loads the UBI kernel module and attaches
<CODE>mtd3</CODE> to it:</P>

<PRE>
$ modprobe ubi mtd=3
</PRE>

<P>If, say, you have two MTD devices, <CODE>mtd2</CODE> and <CODE>mtd5</CODE>,
and you want to have two UBI devices on top of them, use the following
command:</P>

<PRE>
$ modprobe ubi mtd=2 mtd=5
</PRE>

<P>and so on.</P>

<P>If the default positions of UBI headers and data are not appropriate for
you, for example because you can optimize UBI headers overhead, VID and data
positions may also be specified (advanced users only), e.g.:</P>

<PRE>
$ modprobe ubi mtd=2,256,512 mtd=5,1024,2048
</PRE>

<P>To read more about the module parameters, try</P>

<PRE>
$ modinfo ubi
</PRE>

<P>Note, the "<CODE>mtd=2 mtd=5</CODE>" options above assume that two
independent UBI devices will be created, not one UBI device on top
of a concatenation of <CODE>mtd2</CODE> and <CODE>mtd5</CODE>. If you wish to
have a single UBI device, you should first use the MTD concatenation
(<CODE>mtdconcat</CODE>) layer to create a single "concatenated" MTD device,
and then feed it to UBI.</P>

<H3>Compiled into the kernel</H3>

<P>This case is very similar to the above one but an "<CODE>ubi.mtd=</CODE>"
option should be used instead of the "<CODE>mtd=</CODE>" option and it should
be passed via the kernel boot command line instead of the module parameters.</P>

<P>Note, to make sure that UBI was successfully initialized and attached your
MTD device(s), check that UBI-related files are present in the
<CODE>/sys/class/ubi</CODE> sysfs directory, or UBI character devices are
mentioned in the <CODE>/proc/devices</CODE> procfs file.</P>



<A NAME="L_run_jffs2">
<H2>Can I run JFFS2 on top of UBI volumes?</H2>
</A>

<P>Yes, you can. UBI can emulate MTD devices for UBI volumes and JFFS2 can be
mounted on these emulated MTD devices. You just have to enable the
"Emulate MTD devices" configuration menu check-box.</P>



<A NAME="L_bootloader">
<H2>Should my boot-loader know UBI format?</H2>
</A>

<P>It may, but do not have to. You may put your kernel image at a fixed MTD
partition at the beginning of the flash chip and feed the rest of the flash to
UBI. The point is that you do not have to give UBI whole flash chip, you just
give it some MTD partition.</P>



<A NAME="L_ext2_over_ubi">
<H2>Can I run file systems like ext2 on top of UBI?</H2>
</A>

<P>UBI is not a block device emulation layer, it is not an FTL, so the answer
is - no.</P>

<P>UBI pretty much looks like raw flash: it consists of (logical)
eraseblocks, it has <I>read eraseblock</I>, <I>write eraseblock</I>, and
<I>erase eraseblock</I> commands. UBI just hides the eraseblock wear and
bad eraseblock problems and adds some "advanced" capabilities like dynamic
volumes, etc. But still, UBI has nothing to do with block devices, while
ext2 and other "conventional" file systems are designed for block devices.</P>

<P>It is fairly easy to create a block device emulation layer with block size
equivalent to the eraseblock size albeit this barely makes sense (imagine
performance and space overhead when you have a block device with 128KiB block
size). But it is not so trivial to implement a decent block emulation (aka FTL).
</P>

<P>The merit of UBI is that it makes it much easier to implement further layers
like FTL or a file systems by means of stacking them on top of UBI. Indeed, UBI
takes care about many flash chip complexities and makes it possible to
concentrate on, say, good garbage collection algorithm, rather then, say, on
wear-leveling issues.</P>



<A NAME="L_format_mtd">
<H2>Do I have to format my empty flash before running UBI on top of it?</H2>
</A>

<P>No, you don't have to. Although UBI stores some internal information,
you may feed it an empty MTD device and UBI will format it automatically.
The resulting MTD device will have all the internal data in place and no
user volumes.</P>

<P>Note, "empty flash" means that it has to contain only <CODE>0xFF</CODE>
bytes, i.e., to be fully erased. You may use the <CODE>flash_eraseall</CODE>
MTD utility to wipe out MTD devices.</P>



<A NAME="L_leb_and_peb">
<H2>What is "physical eraseblock" and "logical eraseblock"?</H2>
</A>

<P>These are terms used in UBI: UBI volumes consist of
<B>logical eraseblocks</B> (<B>LEB</B>), while the underlying MTD device
consists of <B>physical eraseblocks</B> (<B>PEB</B>).</P>
<UL>
	<LI><B>Physical eraseblocks</B> are eraseblocks of the MTD device which
	is used by UBI as the back-end storage.</LI>

	<LI><B>Logical eraseblocks</B> are eraseblocks the UBI volumes. LEBs
	are a bit smaller in size then PEBs because UBI stores its own headers
	at the beginning of each PEB. For example, in case of NOR flash, LEB is
	128 bytes smaller then PEB (note, UBI headers size depends on the MTD
	device type, see <A HREF="ubi.html#L_hdrsize">here</A>).</LI>
</UL>



<A NAME="L_restrict">
<H2>Can I randomly write to logical eraseblocks?</H2>
</A>

<P>Not really, there are some restrictions.</P>

<OL>
	<LI>Many flashes have minimal input-output unit size, so write offsets
	and lengths have to be aligned.</LI>

	<LI>Logical eraseblocks have to be written sequentially from the
	beginning to the end. This is needed because UBI calculates data CRC
	when moving logical eraseblocks to other physical eraseblocks. So a
	write operation to before the furthest data offset causes a CRC error.</LI>

	<LI>Many NAND flashes require NAND pages to be written consecutively from
	the beginning to the end.</LI>
</OL>



<A NAME="L_volume_update">
<H2>What is volume update?</H2>
</A>

<P>The <B>volume update</B> operation is a way to change the contents of UBI
volumes. UBI does not allow to directly write and erase eraseblocks of
UBI volumes from user-space (even for dynamic volumes). Instead, only entire
volume contents may be changed at one go, by means of the volume update
operation. Both dynamic and static volumes may be updated.</P>

<P>The volume update operation is "atomic", which means that the volume update
operation has to finish. If the operation was not finished, the volume will
not be usable - any further read operation will fail with <CODE>EUCLEAN</CODE>
error.</P>

<P>The volume update operation does not preserve previous volume contents.
Instead, it wipes-out the whole volume as soon as an update operation
starts. But it guarantees that the update either successfully finishes or the
volume goes into the "damaged" state.</P>



<A NAME="L_why_headers">
<H2>What for does UBI need headers in physical eraseblocks?</H2>
</A>

<P>The headers are needed to keep track of erase counters and
physical-to-logical eraseblock associations. There are two UBI headers stored
in each PEB:</P>
<UL>
	<LI><B>erase counter header</B> (or <B>EC header</B>) which is mostly
	needed to store the erase counter of the PEB;</LI>

	<LI><B>volume identifier header</B> (or <B>VID header</B>) which stores
	volume ID and LEB number this PEB belongs to.</LI>
</UL>

<P>Note, there are also some other data stored in EC and VID headers, see
<CODE>mtd/ubi-header.h</CODE> for more details.</P>



<A NAME="L_why_2_hdrs">
<H2>Why does UBI need two headers, not just one?</H2>
</A>

<P>UBI maintains two per-eraseblock headers because it needs to write different
information on flash at different moments of time:</P>
<UL>
	<LI>after a PEB is erased, the EC header is written straight away,
	which minimizes the probability of losing the erase counter due to an
	unclean reboot;</LI>

	<LI>when UBI associates a PEB with to a LEB, the VID header is written
	to the PEB.</LI>
</UL>

<P>When the EC header is written to a PEB, UBI does not yet know the volume ID
and LEB number this PEB will be associated with. This is why UBI needs to do
two write operations and to have two headers.</P>



<A NAME="L_why_no_oob">
<H2>Why UBI does not use OOB area of NAND flashes?</H2>
</A>

<P>Because many flashes (e.g., NOR) do not have OOB and UBI was designed to be
a <I>generic</I> wear-leveling layer. Also, modern MLC NAND flashes use whole
OOB area for ECC checksum, so there is no room for application data.</P>



<A NAME="L_hdrsize">
<H2>How much flash space do UBI headers consume?</H2>
</A>

<P>This depends on the flash type you are using. Both EC and VID headers
take 64 bytes, so in case of NOR flash UBI headers consume 128 bytes,
and the logical eraseblock size is equivalent to the physical eraseblock
size minus 128 bytes. But the situation may be different in case of
other flash types (e.g., NAND)</P>

<P>As it is noted <A HREF="ubi.html#L_why_2_hdrs">here</A>, UBI writes
twice to PEBs, not just both UBI headers in one go. But many flashes
have a notion of the "minimal Input/Output unit size". For example, in case
of NAND flash it may be equivalent to the NAND page size, which is
either 512 bytes or 2KiB. In this case. In this case the EC header would be
placed at the first NAND page, the VID header - at the second NAND page, and
both headers would take two NAND pages (1KiB or 4KiB). Similar to other flash
types.</P>

<P>Implementation-wise, UBI just looks at the <CODE>writesize</CODE> field
of the <CODE>struct mtd_info</CODE> MTD device description object
and uses it as the minimal I/O unit when calculating sizes and positions of
UBI headers.</P>

<P>Fortunately, many NAND flashes (at least SLC ones) allow several
(typically 4) write operations to one NAND page. Thus, say, in case of a
Samsung flash with 2KiB NAND pages one may fit UBI headers at the first two
512-byte chunks of the NAND page. But this must be supported by the MTD flash
driver (<CODE>writesize</CODE> has to be 512 bytes, not 2KiB).</P>

<P>Also, UBI provides two module parameters: <CODE>data_offsets</CODE> and
<CODE>vid_hdr_offsets</CODE>, which may be used to manually specify EC and VID
header positions when the default layout is not appropriate for some
reasons.</P>



<A NAME="L_volume_table">
<H2>What is volume table?</H2>
</A>

<P><B>Volume table</B> is an on-flash data structure containing information
about each user volume on this UBI device (e.g., volume size, name,
type, etc.). Each time a volume is created, removed or re-sized, or
updated, the volume table is altered. UBI maintains two copies of the volume
table for better reliability.</P>



<A NAME="L_crash_safe">
<H2>Is UBI tolerant of power failures?</H2>
</A>

<P>Yes, UBI is designed to be tolerant of power failures and unclean
reboots.</P>



<A NAME="L_how_debug">
<H2>How to debug UBI?</H2>
</A>

<H3>Use fake MTD device</H3>

<P>When debugging UBI you don't have to use a real embedded platform and real
flash. You may use a PC with an MTD device emulator and run UBI on top of this
emulated MTD device.</P>

<P>There are 3 MTD device emulators in Linux kernel available:</P>
<UL>
	<LI><B>mtdram</B> which simulates NOR flash in RAM;</LI>
	<LI><B>nandsim</B> which simulates NAND flash in RAM;</LI>
	<LI><B>block2mtd</B> which simulates NOR flash on top of a block device;</LI>
</UL>

<P>For example, to get a 32MiB fake NOR flash, run
"<CODE>modprobe mtdram total_size=32768</CODE>"
or if you need a 64MiB fake NAND flash, run
"<CODE>modprobe nandsim second_id_byte=0x36</CODE>".</P>

<P>See <A HREF="nand.html#L_nand_nandsim">here</A> for more information about
the NAND simulator.</P>

<P>To ensure that you have fake MTD devices, run "<CODE>cat /prof/mtd</CODE>".
You have to see something like</P>
<PRE>
dev:    size   erasesize  name
mtd0: 02000000 00020000 "mtdram test device"
mtd1: 04000000 00004000 "NAND simulator partition"
</PRE>

<P>Now you should load the UBI module: "<CODE>modprobe ubi mtd_devs=0,1</CODE>",
will attach both mtd0 and mtd1 devices to UBI, and you'll end up with 2
UBI devices.</P>

<P>Should all go smoothly, you have to see corresponding UBI entries in your
sysfs:</P>
<PRE>
# ls /sys/class/ubi/
ubi0  ubi1  version
</PRE>

<H3>Enable debugging</H3>

<P>Enable UBI debugging support in the configuration menu
(the "<B>UBI debugging</B>" check-box). When UBI debugging is enabled, UBI
prints more information about errors, and adds extra assertions in the code
which may help to catch bugs. You may also enable debugging prints and extra
self-checks (makes UBI much slower but very helpful).</P>

<P>Note, when UBI debugging messages are enabled, UBI will print really a lot
of them. You may use serial console to capture all of them, but it is quite
slow. Also you may just enlarge the kernel printk buffer size - for example,
make it 64MiB (a small hack in <CODE>lib/Kconfig.debug</CODE> is needed, or
boot with <CODE>log_buf_len=64M</CODE> kernel option).</P>



<A NAME="L_how_send_bugreport">
<H2>How to send an UBI bugreport?</H2>
</A>

<P>Before sending a bug report:</P>
<UL>
	<LI>make sure you have compiled kernel symbols in
	(<CODE>CONFIG_KALLSYMS_ALL=y</CODE> in <CODE>.config</CODE>);</LI>

	<LI>enable UBI debugging;</LI>

	<LI>enable UBI debugging messages;</LI>

	<LI>try to enable UBI paranoid checks
	(see <A HREF="ubi.html#L_paranoid_checks">here</A>); but if it makes
	the bug not reproducible or makes UBI dramatically slower, do not
	enable them or try to disable I/O unit's paranoid checks, or may be
	have an idea of the bug's nature and may enable paranoid checks in the
	related UBI unit;</LI>
</UL>

<P>When sending the bugreport, please include the bug-related messages and
UBI debugging output.</P>

<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
