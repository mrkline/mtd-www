<PAGE>
<VAR match="VAR_ORIGIN" replace="../" />
<VAR match="VAR_CVSID" replace="Last updated: 19 May 2008, dedekind"/>
<INCLUDE file="../inc/header.tmpl" />

<VAR match="VAR_SEL_FAQ" replace="selected" />
<VAR match="VAR_SEL_UBI" replace="selected" />
<PARSE file="../menu1.xml" />

<INCLUDE file="../inc/content.tmpl" />

<h1>UBI FAQ and HOWTO</h1>

<h2>Table of contents</h2>
<ol>
	<li><a href="ubi.html#L_enable_ubi">How to enable UBI?</a></li>
	<li><a href="ubi.html#L_attachmtd">How to attach an MTD device?</a></li>
	<li><a href="ubi.html#L_mkvol">How to create/delete UBI volumes?</a></li>
	<li><a href="ubi.html#L_run_jffs2">How to run JFFS2 on top of an UBI volume?</a></li>
	<li><a href="ubi.html#L_ext2_over_ubi">Can I run ext2 on top of UBI?</a></li>
	<li><a href="ubi.html#L_format_mtd">Do I have to format my empty flash before running UBI on top of it?</a></li>
	<li><a href="ubi.html#L_ubierase">How to erase flash and preserve erase counters?</a></li>
	<li><a href="ubi.html#L_ubi_mkimg">How to create UBI images?</a></li>
	<li><a href="ubi.html#L_find_min_io_size">How to find out min. I/O unit size, sub-page size, etc?</a></li>
	<li><a href="ubi.html#L_flash_img">How to flash UBI images and preserve erase counters?</a></li>
	<li><a href="ubi.html#L_restrict">Can UBI logical eraseblocks be written randomly?</a></li>
	<li><a href="ubi.html#L_why_headers">What for does UBI need headers in physical eraseblocks?</a></li>
	<li><a href="ubi.html#L_why_2_hdrs">Why does UBI need two headers, not just one?</a></li>
	<li><a href="ubi.html#L_why_no_oob">Why UBI does not use OOB area of NAND flashes?</a></li>
	<li><a href="ubi.html#L_volume_table">What is volume table?</a></li>
	<li><a href="ubi.html#L_crash_safe">Is UBI tolerant of power failures?</a></li>
	<li><a href="ubi.html#L_mlc">May UBI be used on MLC flash?</a></li>
	<li><a href="ubi.html#L_how_debug">How to debug UBI?</a></li>
</ol>



<h2><a name="L_enable_ubi">How to enable UBI?</a></h2>

<p>In the Linux configuration menu, go to "<b>Device Drivers</b>" ->
"<b>Memory Technology Devices (MTD)</b>" -> "<b>UBI - Unsorted block images</b>",
and mark the "<b>Enable UBI</b>" check-box. UBI may be either compiled into the
kernel or built as a kernel module.</p>



<h2><a name="L_attachmtd">How to attach an MTD device?</a></h2>

<p>If UBI is compiled as a kernel module, it is enough to specify the MTD
device to attach in the module arguments, e.g.</p>

<pre>
$ modprobe ubi mtd=3
</pre>

<p>loads the UBI kernel module and attaches <code>mtd3</code>. And</p>

<pre>
$ modprobe ubi mtd=3 mtd=5
</pre>

<p>command loads UBI kernel module and attaches <code>mtd3</code>
and <code>mtd5</code>.</p>

<p>If UBI is compiled into the kernel, the mtd device to attach may be
specified in the kernel boot parameters, e.g.,</p>

<pre>
ubi.mtd=3
</pre>

<p>command makes UBI attach <code>mtd3</code> when the kernel is booting,
and</p>

<pre>
ubi.mtd=3 ubi.mtd=3
</pre>

<p>command makes UBI attach <code>mtd3</code> and <code>mtd6</code>.</p>

<p>And finally, MTD devices may be attached or detached at any time with the
<code>ubiattach</code> and <code>ubidetach</code> utilities
(see <a href="../doc/ubi.html#L_usptools">here</a>); For example,</p>

<pre>
$ ubiattach /dev/ubi_ctrl -m 3
</pre>

<p>attaches <code>mtd3</code>. But this "run-time attach" UBI capability was
added recently and it is in the main-line kernels starting from version
2.6.25. Note, it is anyway recommended to back-port UBI patches from the latest
kernel or even better from the <a href="ubi.html#L_source">UBI git tree</a>.</p>



<h2><a name="L_mkvol">How to create/delete UBI volumes?</a></h2>

<p>Use <code>ubimkvol</code> and <code>ubirmvol</code> tools (see
<a href="../doc/ubi.html#L_usptools">here</a>). For example, the below command
creates a 128MiB volume on UBI device 0:</p>

<pre>
$ ubimkvol /dev/ubi0 -N rootfs -s 128MiB
</pre>

<p>and the following command removes it:</p>

<pre>
$ ubirmvol /dev/ubi0 -n 0
</pre>

<p>For additional information, use <code>ubimkvol -h</code> and
<code>ubirmvol -h</code>.</p>



<h2><a name="L_run_jffs2">How to run JFFS2 on top of an UBI volume?</a></h2>

<p>Although it may sound weird, UBI can emulate MTD devices for UBI volumes and
JFFS2 can be mounted on these emulated MTD devices. Enable the
"Emulate MTD devices" UBI configuration menu check-box to make UBI create one
MTD device for each UBI volume. One of the reasons to do this might be using of
MLC NAND flash (see <a href="ubi.html#L_mlc">this</a> section) or legacy
software.</p>



<h2><a name="L_ext2_over_ubi">Can I run ext2 on top of UBI?</a></h2>

<p>UBI is not a block device emulation layer, it is not an FTL. Neither ext2
nor other "traditional" file systems can be run on top of an UBI device.
Please, read the <a href="../doc/ubi.html#L_rednote">big red note</a>
and <a href="../doc/ubi.html#L_overview">overview</a> documentation sections to
realize why.</p>

<p>But it is much easier to implement FTL on top of UBI then on top of MTD,
because UBI takes care about many flash complexities and makes it
possible to concentrate on on upper-level issues rather then solving flash
media problems like wear-leveling, bit-flips, bad-blocks, etc.</p>

<p><a
href="http://lists.infradead.org/pipermail/linux-mtd/2008-January/020381.html">
This</a> e-mail describes an idea of a simple FTL layer on top of UBI.</p>



<h2><a name="L_format_mtd">
	Do I have to format my empty flash before running UBI on top of it?
</a></h2>

<p>Generally speaking, the flash should be formatted into UBI format before
using it. This means, each eraseblock should be erased and the erase counter
header should be written to it. This is an ideal situation for UBI. However,
it is not always possible because most embedded platforms may only wipe out
the flash and flash images to it. This is we toughed UBI to deal with empty
flash or empty eraseblocks perfectly well - it puts zero EC header to them
automatically.</p>

<p>So the answer is no, you do not have to. For example, if you wipe out the
flash and try to attach it to UBI - it will work. UBI will just automatically
format the flash (which however, will take some time). Or it is perfectly fine
if you wipe out your flash, and write an UBI image to it (which will probably
be shorter than the flash). In this case UBI will just format the empty
physical eraseblocks at the end of the flash.</p>

<p>However, it is not recommended to do this often, because when erasing you
loose erase counters, so you loose wearing information. Doing this over and
over again may wear out some eraseblocks. This is especially dangerous on MLC
NAND flashes which have very low eraseblock life-cycle. The proper way to deal
with flash which is used for UBI is to preserve the erase-counters. Please, use
the <a href="../doc/ubi.html#L_usptools"><code>ubiformat</code></a> utility
for these purposes. This utility may wipe out the flash and preserve erase
counters as well as properly write UBI images. Or refer
<a href="../doc/ubi.html#L_format">this</a> section for some hints what
the flasher should do to be UBI-aware.</p>



<h2><a name="L_ubierase">
	How to erase flash and preserve erase counters?
</a></h2>

<p>Use the <a href="../doc/ubi.html#L_usptools"><code>ubiformat</code></a>
utility. Example:</p>

<pre>
$ ubiformat /dev/mtd0
ubiformat: mtd0 (NAND), size 536870912 bytes (512.0 MiB), 131072 eraseblocks of
131072 bytes (128.0 KiB), min. I/O size 2048 bytes
libscan: scanning eraseblock 4095 -- 100 % complete
ubiformat: 4094 eraseblocks have valid erase counter, mean value is 104
ubiformat: bad eraseblocks: 13, 666
ubiformat: formatting eraseblock 4095 -- 100 % complete
</pre>

<p>Note, <a href="../doc/ubi.html#L_format">this</a> has some hints for those
who implement a flasher program.</p>



<h2><a name="L_ubi_mkimg">How to create UBI images?</a></h2>

<p>UBI images may be created using the <code>ubinize</code> utility
(see <a	href="../doc/ubi.html#L_usptools">here</a>). This utility takes the
configuration file on input and generates an UBI image. The input configuration
file describes all UBI volumes which the resulting UBI image have to contain.
The configuration file has <code>ini</code>-file syntax. Here is an example:</p>

<pre>
$ cat config.ini
[configuration-data-volume]
mode=ubi
image=config_data.img
vol_id=0
vol_size=512KiB
vol_type=static
vol_name=configuration

[rootfs-volume]
mode=ubi
image=rootfs.img
vol_id=1
vol_size=220MiB
vol_type=dynamic
vol_name=rootfs
vol_flags=autoresize

$ ./ubinize -o ubi.img -p 128KiB -m 512 -s 256 config.ini
</pre>

<p>The <code>config.ini</code> file tells UBIFS to create 2 volumes:</p>
<ul>
	<li>static configuration volume of 512KiB in size, assign it ID 0 and
	name "configuration"; the contents of the volume should be taken from
	the <code>config_data.img</code> file;</li>
	<li>dynamic root file-system volume of 220MiB in size, assign it ID 1
	and name "rootfs"; the contents of the volume should be taken from
	the <code>rootfs.img</code> file; this volume should also have
	"auto-resize" flag which means the size of this volume will be amended
	when UBI runs for the first time; namely, UBI will make this volume
	larger by giving available eraseblocks; this may be very useful in case
	of NAND flash (see <a href="../doc/ubi.html#L_autoresize">here</a> for
	more details).</li>
</ul>

<p>So in the above example, <code>ubinize</code> basically reads 3 input
files:</p>
<ul>
	<li>The <code>config.ini</code> file which describes how many volumes
	should the resulting <code>ubi.img</code> file contain, their sizes,
	names, and so on; it also refers the files containing the data which
	should be put to the volumes; note, if the volume is supposed to be
	empty, just do not specify the image file;</li>
	<li>the <code>config_data.img</code> image file for the first
	volume;</li>
	<li>the <code>rootfs.img</code> image file for the second volume.</li>
</ul>

<p>Users often wonder why <code>ubinize</code> needs a configuration file. The
answer is that one UBI image may contain many UBI volumes with different
characteristics and it is difficult to invent a nice command-line interface for
specifying all those characteristics. Thus a configuration file is used.</p>

<p>Note, UBI reserves <i>physical</i> flash space for volumes. Namely, UBI
reserves a physical eraseblock for each logical eraseblock. The size if LEB
130560 bytes in our example (found out by running <code>ubinize</code>
with <code>-v</code> option), which means the configuration volume will have 5
LEBs ([512 * 1024] / 130560 rounded up) and the root file-system
volume will have at least 1767 LEBs (or more because of the auto-resize flag).
This means that the MTD device have to have at least 1772
physical eraseblocks, which is about 221MiB. But because of the UBI overhead
(see <a href="../doc/ubi.html#L_overhead">this</a> section), the MTD device
has to be at least 225MiB in size. Of course it may be larger, in which
case the "rootfs" volume will be re-sized and take the rest of the flash space
(because of the auto-resize flag).</p>

<p>Also, the <code>config_data.img</code> and <code>rootfs.img</code> input
files do not have to be 512KiB and 220MiB respectively, but may be smaller if
needed. And the resulting <code>ubi.img</code> file may be smaller than 221MiB.
All <code>ubinize</code> is doing is it takes the image files, splits them to
LEB-sized chunks, forms PEB data by adding UBI headers to these LEB chunks, and
writes the result to the output file. It also writes the volume table (2
physical eraseblocks). Thus, <code>ubi.img</code> file size will be small if
the input volume images are small. And <code>ubinize</code> does not do any
further padding.</p>

<p>Before flashing the <code>ubi.img</code> file, the flash has to
be erased, so that the physical eraseblocks which are not covered by
<code>ubi.img</code> would be empty. And it is good idea to preserve erase
counters if they exist. The
<a href="../doc/ubi.html#L_usptools"><code>ubiformat</code></a> utility may be
used for this.</p>



<h2><a name="L_find_min_io_size">
	How to find out min. I/O unit size, sub-page size, etc?
</a></h2>

<p>When creating UBI images it is necessary to know:</p>
<ul>
	<li>physical eraseblock size;</li>
	<li>minimum input/output unit size;</li>
	<li>sub-page size.</li>
</ul>

<p>Physical eraseblock (PEB) size should probably be found out in the flash
manual.</p>

<p>Minimum I/O unit size is NAND page size in case of NAND flash and should
also be found out in the flash manual (it is usually 512, 2048 or even 4096 at
some modern NANDs). For NOR flashes it is 1, unless you have a (rare) ECC-NOR
flash which may have 8 or 16 byte minimal I/O unit size.</p>

<p>Sub-page size is relevant only for some NAND flashes which allow several
(usually 2 or 4) writes to the same NAND page. For example, many SLC NAND
flashes have this. UBI utilizes this feature if it is available to waste less
flash space. Typically, sub-page size if 256 in case of 512 bytes NAND page and
512 in case of 2048 bytes NAND pages. MLC NAND flashes typically have no
sub-pages. SLC OneNAND chips with 2048 bytes NAND page size support 512 byte
sub-pages.</p>

<p>Note, sub-page is an MTD term, but this is also referred to as "NOP" which
stands for "number of partial programs". So NOP1 NAND flashes have no sub-pages
(or you may treat this as sub-page size is equivalent to NAND page size),
NOP 2 NAND flashes have 2 sub-pages (half a NAND page each), NOP 4 flashes
have 4 sub-pages (quarter of a NAND page each).</p>

<p>Unfortunately, MTD does not expose information via sysfs and it is a bit
tricky to find the above characteristics out for an existing MTD device (one
would need to use an <code>ioctl</code>). Moreover, the sub-page size is not
exposed to the user-space at all (just because nobody implemented this).</p>

<p>The easiest way to find this out is to attach your MTD device to UBI and
glance to the syslog/dmesg output (erase the MTD device before doing this -
see <a href="ubi.html#L_ubierase">this</a> section). The newest UBI prints
something like this:</p>

<pre>
UBI: physical eraseblock size:   131072 bytes (128 KiB)
UBI: logical eraseblock size:    129024 bytes
UBI: smallest flash I/O unit:    2048
UBI: sub-page size:              512
</pre>

<p>Note, if sup-page size was not printed, it does not exist. Older UBI
implementation do not print sub-page size, but they print VID header
offset, which is by default equivalent to sub-page size:</p>

<pre>
UBI: VID header offset:          512 (aligned 512)
</pre>



<h2><a name="L_flash_img">
	How to flash UBI images and preserve erase counters?
</a></h2>

<p>Use the <a href="../doc/ubi.html#L_usptools"><code>ubiformat</code></a>
utility. Example:</p>

<pre>
$ ubiformat /dev/mtd0 -f ubi.img
ubiformat: mtd0 (NAND), size 536870912 bytes (512.0 MiB), 131072 eraseblocks of 131072 bytes (128.0 KiB), min. I/O size 2048 bytes
libscan: scanning eraseblock 4095 -- 100 % complete
ubiformat: 4094 eraseblocks have valid erase counter, mean value is 105
ubiformat: bad eraseblocks: 13, 666
ubiformat: flashing eraseblock 50 -- 100 % complete
ubiformat: formatting eraseblock 4095 -- 100 % complete
</pre>

<p>Note, <a href="../doc/ubi.html#L_format">this</a> has some hints for those
who implement a flasher program.</p>



<h2><a name="L_restrict">
	Can UBI logical eraseblocks be written randomly?
</a></h2>

<p>No, the flash chip restrictions have to be taken into account. This is
because UBI logical eraseblocks (LEB) are mapped to physical eraseblocks (PEB),
and an LEB write operation is essentially a write to the corresponding PEB
plus a small offset, because there are erase counter and volume ID headers at
the beginning of the PEB (see <a href="../doc/ubi.html#L_overhead">here</a>
for few more details). The important flash restrictions are:</p>

<ol>
	<li>many flashes have minimal input-output unit size larger then 1 byte,
	so write offsets and lengths have to be aligned to the minimum I/O unit
	size; for example, in case of a NAND flash with 2KiB NAND page it is
	possible to write only 2, 4, 8, etc KiB chunks and only to 0, 2, 4, 8,
	etc KiB offsets;</li>

	<li>it is prohibited to write more then once to the same PEB
	offset;</li>

	<li>many NAND flashes (specifically, MLC NAND flashes) require NAND
	pages to be written sequentially from the beginning of the physical
	eraseblock, to the end of the physical eraseblock; for example, it is
	prohibited to write first to offset 2048, then to offset 0; once offset
	2048 has been written to, it is possible to write only to further
	offsets.</li>
</ol>

<p>Even if the flash chip is devoid of the last restriction, UBI anyway
requires logical eraseblocks to be written sequentially from the beginning
to the end; this is needed because UBI calculates data CRC when moving logical
eraseblocks to other physical eraseblocks (see
<a href="../doc/ubi.html#L_lebchange_det">here</a> to realize why),
so a write operation to before the furthest data offset causes a CRC error;</p>



<h2><a name="L_why_headers">
	What for does UBI need headers in physical eraseblocks?
</a></h2>

<p>The headers are needed to keep track of erase counters and
physical-to-logical eraseblock associations. There are two UBI headers stored
in each PEB:</p>
<ul>
	<li><b>erase counter header</b> (or <b>EC header</b>) which is mostly
	needed to store the erase counter of the PEB;</li>

	<li><b>volume identifier header</b> (or <b>VID header</b>) which stores
	volume ID and LEB number this PEB belongs to.</li>
</ul>

<p>Note, there are also some other data stored in EC and VID headers, see
<code>ubi-media.h</code> for more details.</p>



<h2><a name="L_why_2_hdrs">Why does UBI need two headers, not just one?</a></h2>

<p>UBI maintains two per-eraseblock headers because it needs to write different
information on flash at different moments of time:</p>
<ul>
	<li>after a PEB is erased, the EC header is written straight away,
	which minimizes the probability of losing the erase counter due to an
	unclean reboot;</li>

	<li>when UBI associates a PEB with a LEB, the VID header is written
	to the PEB.</li>
</ul>

<p>When the EC header is written to a PEB, UBI does not yet know the volume ID
and LEB number this PEB will be associated with. This is why UBI needs to do
two separate write operations and to have two separate headers.</p>



<h2><a name="L_why_no_oob">
	Why UBI does not use OOB area of NAND flashes?
</a></h2>

<p>Because many flashes (e.g., NOR) do not have OOB and UBI was designed to be
a <i>generic</i> wear-leveling layer. Also, modern MLC NAND flashes use whole
OOB area for the ECC checksum, so there is no room for application data.</p>



<h2><a name="L_volume_table">What is volume table?</a></h2>

<p><b>Volume table</b> is an on-flash internal UBI data structure containing
information about each volume on this UBI device (e.g., volume size, name,
type, etc.). Each time a volume is created, removed or re-sized, or
updated, the volume table is altered. UBI maintains two copies of the volume
table for reliability and power-off tolerance reasons.</p>



<h2><a name="L_crash_safe">Is UBI tolerant of power failures?</a></h2>

<p>Yes, UBI is designed to be tolerant of power failures and unclean
reboots.</p>



<h2><a name="L_mlc">May UBI be used on MLC flash?</a></h2>

<p>Yes, it may, as long as the flash is supported by the MTD layer. UBI does
not use OOB and it requires data to be written sequentially (see
<a href="ubi.html#L_mlc">here</a>). UBI guarantees that the difference
between maximum and minimum erase-counters is withing certain threshold,
which is 4096 by default. Since MLC flashes have quite low eraseblock
life-cycle (about 1000-10000, unlike 100000-1000000 for SLC NAND and NOR
flashes), the threshold has to be set to a lower value (e.g., 256). This may be
done via the Linux kernel configuration menu.</p>

<p>Note, unlike UBI, JFFS2 uses random wear-leveling algorithm, which is in
fact not completely random, because JFFS2 makes it more probable to
garbage collect eraseblocks with more dirty data. This means that JFFS2 is not
really appropriate for MLC flashes. However, it is possible to use JFFS2
file-system on top of UBI (see <a href="ubi.html#L_run_jffs2">this</a>
section) to improve wear-leveling.</p>



<h2><a name="L_how_debug">How to debug UBI?</a></h2>

<h3>Use fake MTD device</h3>

<p>When debugging UBI one doesn't have to use a real embedded platform with real
flash. In many cases, it is easier to use a PC with an MTD device emulator and
run UBI on top of this emulated MTD device. In fact, this is how most of the
UBI development was done.</p>

<p>There are 3 MTD device emulators in Linux kernel available:</p>
<ul>
	<li><b>mtdram</b> which simulates NOR flash in RAM;</li>
	<li><b>nandsim</b> which simulates NAND flash in RAM;</li>
	<li><b>block2mtd</b> which simulates NOR flash on top of a block
	device;</li>
</ul>

<p>For example, to get a 32MiB fake NOR flash, run</p>

<pre>
$ modprobe mtdram total_size=32768
</pre>

<p>or to get a 64MiB fake NAND flash, run</p>

<pre>
$ modprobe nandsim second_id_byte=0x36
</pre>

<p>See <a href="nand.html#L_nand_nandsim">here</a> for more information about
the NAND simulator.</p>

<p>To ensure that you have fake MTD devices, run "<code>cat /prof/mtd</code>".
It should print something like</p>

<pre>
dev:    size   erasesize  name
mtd0: 02000000 00020000 "mtdram test device"
mtd1: 04000000 00004000 "NAND simulator partition"
</pre>

<p>The fake MTD devices may further be attached to UBI (see
<a href="ubi.html#L_attachmtd">here</a>).</p>


<h3>Enable debugging</h3>

<p>Enable UBI debugging support in the configuration menu
(the "<b>UBI debugging</b>" check-box). When debugging is enabled, UBI
prints more information about errors, and adds extra assertions in the code
which may help to catch bugs.</p>

<p>In many cases, it is enough to just enable debugging. But sometimes it is
also useful to enable extra-self checks, which make sure internal data
structures are consistent and may catch the problem much earlier then it would
have been noticed otherwise. But the checks make UBI much slower.</p>

<h3>Debugging messages</h3>

<p>Sometimes it is necessary to make UBI print about what it is doing. This is
where UBI messages may be enabled. When they are enabled, UBI prints a lot and
the kernel ring buffer and this makes it slower. This section describes few
tricks and techniques which might be useful when debugging using the
messages.</p>

<p>The Linux kernel has internal ring buffer where all the debugging prints go.
User-space applications like <code>syslogd</code> usually read data from the
ring buffer, do further processing and the prints usually end up in the system
log file. When the UBI debugging messages are enabled, it prints huge amount of
messages. What happens is that the user-space processes are unable to fetch
them from the ring buffer with this pace so most of the messages are just lost.
Namely, they are just over-written with newer message (the buffer is a "ring").
There are 2 ways to gather all the messages:</p>

<ol>
	<li>use serial console;</li>
	<li>use very large ring buffer.</li>
</ol>

<p>The first method is usually appropriate when debugging on an small embedded
platform connected to a PC via serial line. What you have to be aware of is
that the messages are printed to the serial console synchronously, which means
that the system is blocked and waiting for the print operation to be finished.
So if there are many prints, the system speed becomes limited to the serial
console baud rate. And obviously, it is recommended to use higher baud rates,
e.g. 115200.</p>

<p>The UBI debugging messages have "debugging" level 7 and they are usually not
printed to the console. You may use <code>dmesg -n8</code> command to make all
kernel messages to go to the console. One useful trick is to boot the kernel
with <code>ignore_loglevel</code> option, in which case it will print all
messages to the console unconditionally.</p>

<p>The second method is more appropriate when debugging on a machine with a lot
of RAM, for example on a desktop PC with a flash emulator. Just make your ring
buffer large, e.g. 64MiB by booting the kernel with <code>log_buf_len=64M</code>
option. This will make the ring buffer fit enough messages to identify the
problem. And because the messages are printed to RAM, this is way quicker than
the first method.</p>

<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
