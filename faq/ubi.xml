<PAGE>
<VAR match="VAR_ORIGIN" replace="../" />
<VAR match="VAR_CVSID" replace="Last updated: 21 Apr 2008, dedekind"/>
<INCLUDE file="../inc/header.tmpl" />

<VAR match="VAR_SEL_FAQ" replace="selected" />
<VAR match="VAR_SEL_UBI" replace="selected" />
<PARSE file="../menu1.xml" />

<INCLUDE file="../inc/content.tmpl" />

<h1>UBI FAQ and HOWTO</h1>

<h2>Table of contents</h2>
<ol>
	<li><a href="ubi.html#L_enable_ubi">How to enable UBI?</a></li>
	<li><a href="ubi.html#L_attachmtd">How to attach an MTD device?</a></li>
	<li><a href="ubi.html#L_mkvol">How to create/delete UBI volumes?</a></li>
	<li><a href="ubi.html#L_run_jffs2">How to run JFFS2 on top of an UBI volume?</a></li>
	<li><a href="ubi.html#L_ext2_over_ubi">Can I run ext2 on top of UBI?</a></li>
	<li><a href="ubi.html#L_format_mtd">Do I have to format my empty flash before running UBI on top of it?</a></li>
	<li><a href="ubi.html#L_restrict">Can UBI logical eraseblocks be written randomly?</a></li>
	<li><a href="ubi.html#L_why_headers">What for does UBI need headers in physical eraseblocks?</a></li>
	<li><a href="ubi.html#L_why_2_hdrs">Why does UBI need two headers, not just one?</a></li>
	<li><a href="ubi.html#L_why_no_oob">Why UBI does not use OOB area of NAND flashes?</a></li>
	<li><a href="ubi.html#L_volume_table">What is volume table?</a></li>
	<li><a href="ubi.html#L_crash_safe">Is UBI tolerant of power failures?</a></li>
	<li><a href="ubi.html#L_mlc">May UBI be used on MLC flash?</a></li>
	<li><a href="ubi.html#L_how_debug">How to debug UBI?</a></li>
</ol>



<h2><a name="L_enable_ubi">How to enable UBI?</a></h2>

<p>In the Linux configuration menu, go to "<b>Device Drivers</b>" ->
"<b>Memory Technology Devices (MTD)</b>" -> "<b>UBI - Unsorted block images</b>",
and mark the "<b>Enable UBI</b>" check-box. UBI may be either compiled into the
kernel or built as a kernel module.</p>



<h2><a name="L_attachmtd">How to attach an MTD device?</a></h2>

<p>If UBI is compiled as a kernel module, it is enough to specify the MTD
device to attach in the module arguments, e.g.</p>

<pre>
$ modprobe ubi mtd=3
</pre>

<p>loads the UBI kernel module and attaches <code>mtd3</code>. And</p>

<pre>
$ modprobe ubi mtd=3 mtd=5
</pre>

<p>command loads UBI kernel module and attaches <code>mtd3</code>
and <code>mtd5</code>.</p>

<p>If UBI is compiled into the kernel, the mtd device to attach may be
specified in the kernel boot parameters, e.g.,</p>

<pre>
ubi.mtd=3
</pre>

<p>command makes UBI attach <code>mtd3</code> when the kernel is booting,
and</p>

<pre>
ubi.mtd=3 ubi.mtd=3
</pre>

<p>command makes UBI attach <code>mtd3</code> and <code>mtd6</code>.</p>

<p>And finally, MTD devices may be attached or detached at any time with the
<code>ubiattach</code> and <code>ubidetach</code> utilities
(see <a href="../doc/ubi.html#L_usptools">here</a>); For example,</p>

<pre>
$ ubiattach /dev/ubi_ctrl -m 3
</pre>

<p>attaches <code>mtd3</code>. But this "run-time attach" UBI capability was
added recently and it is in the main-line kernels starting from version
2.6.25. Note, it is anyway recommended to back-port UBI patches from the latest
kernel or even better from the <a href="ubi.html#L_source">UBI git tree</a>.</p>



<h2><a name="L_mkvol">How to create/delete UBI volumes?</a></h2>

<p>Use <code>ubimkvol</code> and <code>ubirmvol</code> tools (see
<a href="../doc/ubi.html#L_usptools">here</a>). For example, the below command
creates a 128MiB volume on UBI device 0:</p>

<pre>
$ ubimkvol /dev/ubi0 -N rootfs -s 128MiB
</pre>

<p>and the following command removes it:</p>

<pre>
$ ubirmvol /dev/ubi0 -n 0
</pre>

<p>For additional information, use <code>ubimkvol -h</code> and
<code>ubirmvol -h</code>.</p>



<h2><a name="L_run_jffs2">How to run JFFS2 on top of an UBI volume?</a></h2>

<p>Although it may sound weird, UBI can emulate MTD devices for UBI volumes and
JFFS2 can be mounted on these emulated MTD devices. Enable the
"Emulate MTD devices" UBI configuration menu check-box to make UBI create one
MTD device for each UBI volume. One of the reasons to do this might be using of
MLC NAND flash (see <a href="ubi.html#L_mlc">this</a> section) or legacy
software.</p>



<h2><a name="L_ext2_over_ubi">Can I run ext2 on top of UBI?</a></h2>

<p>UBI is not a block device emulation layer, it is not an FTL. Neither ext2
nor other "traditional" file systems can be run on top of an UBI device.
Please, read the <a href="../doc/ubi.html#L_rednote">big red note</a>
and <a href="../doc/ubi.html#L_overview">overview</a> documentation sections to
realize why.</p>

<p>But it is much easier to implement FTL on top of UBI then on top of MTD,
because UBI takes care about many flash complexities and makes it
possible to concentrate on on upper-level issues rather then solving flash
media problems like wear-leveling, bit-flips, bad-blocks, etc.</p>

<p><a
href="http://lists.infradead.org/pipermail/linux-mtd/2008-January/020381.html">
This</a> e-mail describes an idea of a simple FTL layer on top of UBI.</p>



<h2><a name="L_format_mtd">
	Do I have to format my empty flash before running UBI on top of it?
</a></h2>

<p>No, you don't have to. Although UBI stores some internal information,
you may feed it an empty MTD device and UBI will format it automatically.
The resulting MTD device will have all the internal data in place and no
user volumes.</p>

<p>"Empty flash" means that it has to contain only <code>0xFF</code>
bytes, i.e., to be fully erased. You may use the <code>flash_eraseall</code>
MTD utility to wipe out MTD devices.</p>

<p>TODO: skazat' ob ubiformat</p>


<h2><a name="L_restrict">
	Can UBI logical eraseblocks be written randomly?
</a></h2>

<p>No, the flash chip restrictions have to be taken into account. This is
because UBI logical eraseblocks (LEB) are mapped to physical eraseblocks (PEB),
and an LEB write operation is essentially a write to the corresponding PEB
plus a small offset, because there are erase counter and volume ID headers at
the beginning of the PEB (see <a href="../doc/ubi.html#L_overhead">here</a>
for few more details). The important flash restrictions are:</p>

<ol>
	<li>many flashes have minimal input-output unit size larger then 1 byte,
	so write offsets and lengths have to be aligned to the minimum I/O unit
	size; for example, in case of a NAND flash with 2KiB NAND page it is
	possible to write only 2, 4, 8, etc KiB chunks and only to 0, 2, 4, 8,
	etc KiB offsets;</li>

	<li>it is prohibited to write more then once to the same PEB
	offset;</li>

	<li>many NAND flashes (specifically, MLC NAND flashes) require NAND
	pages to be written sequentially from the beginning of the physical
	eraseblock, to the end of the physical eraseblock; for example, it is
	prohibited to write first to offset 2048, then to offset 0; once offset
	2048 has been written to, it is possible to write only to further
	offsets.</li>
</ol>

<p>Even if the flash chip is devoid of the last restriction, UBI anyway
requires logical eraseblocks to be written sequentially from the beginning
to the end; this is needed because UBI calculates data CRC when moving logical
eraseblocks to other physical eraseblocks (see
<a href="../doc/ubi.html#L_lebchange_det">here</a> to realize why),
so a write operation to before the furthest data offset causes a CRC error;</p>



<h2><a name="L_why_headers">
	What for does UBI need headers in physical eraseblocks?
</a></h2>

<p>The headers are needed to keep track of erase counters and
physical-to-logical eraseblock associations. There are two UBI headers stored
in each PEB:</p>
<ul>
	<li><b>erase counter header</b> (or <b>EC header</b>) which is mostly
	needed to store the erase counter of the PEB;</li>

	<li><b>volume identifier header</b> (or <b>VID header</b>) which stores
	volume ID and LEB number this PEB belongs to.</li>
</ul>

<p>Note, there are also some other data stored in EC and VID headers, see
<code>ubi-media.h</code> for more details.</p>



<h2><a name="L_why_2_hdrs">Why does UBI need two headers, not just one?</a></h2>

<p>UBI maintains two per-eraseblock headers because it needs to write different
information on flash at different moments of time:</p>
<ul>
	<li>after a PEB is erased, the EC header is written straight away,
	which minimizes the probability of losing the erase counter due to an
	unclean reboot;</li>

	<li>when UBI associates a PEB with a LEB, the VID header is written
	to the PEB.</li>
</ul>

<p>When the EC header is written to a PEB, UBI does not yet know the volume ID
and LEB number this PEB will be associated with. This is why UBI needs to do
two separate write operations and to have two separate headers.</p>



<h2><a name="L_why_no_oob">
	Why UBI does not use OOB area of NAND flashes?
</a></h2>

<p>Because many flashes (e.g., NOR) do not have OOB and UBI was designed to be
a <i>generic</i> wear-leveling layer. Also, modern MLC NAND flashes use whole
OOB area for the ECC checksum, so there is no room for application data.</p>



<h2><a name="L_volume_table">What is volume table?</a></h2>

<p><b>Volume table</b> is an on-flash internal UBI data structure containing
information about each volume on this UBI device (e.g., volume size, name,
type, etc.). Each time a volume is created, removed or re-sized, or
updated, the volume table is altered. UBI maintains two copies of the volume
table for reliability and power-off tolerance reasons.</p>



<h2><a name="L_crash_safe">Is UBI tolerant of power failures?</a></h2>

<p>Yes, UBI is designed to be tolerant of power failures and unclean
reboots.</p>



<h2><a name="L_mlc">May UBI be used on MLC flash?</a></h2>

<p>Yes, it may, as long as the flash is supported by the MTD layer. UBI does
not use OOB and it requires data to be written sequentially (see
<a href="ubi.html#L_mlc">here</a>). UBI guarantees that the difference
between maximum and minimum erase-counters is withing certain threshold,
which is 4096 by default. Since MLC flashes have quite low eraseblock
life-cycle (about 1000-10000, unlike 100000-1000000 for SLC NAND and NOR
flashes), the threshold has to be set to a lower value (e.g., 256). This may be
done via the Linux kernel configuration menu.</p>

<p>Note, unlike UBI, JFFS2 uses random wear-leveling algorithm, which is in
fact not completely random, because JFFS2 makes it more probable to
garbage collect eraseblocks with more dirty data. This means that JFFS2 is not
really appropriate for MLC flashes. However, it is possible to use JFFS2
file-system on top of UBI (see <a href="ubi.html#L_run_jffs2">this</a>
section) to improve wear-leveling.</p>



<h2><a name="L_how_debug">How to debug UBI?</a></h2>

<h3>Use fake MTD device</h3>

<p>When debugging UBI one doesn't have to use a real embedded platform with real
flash. In many cases, it is easier to use a PC with an MTD device emulator and
run UBI on top of this emulated MTD device. In fact, this is how most of the
UBI development was done.</p>

<p>There are 3 MTD device emulators in Linux kernel available:</p>
<ul>
	<li><b>mtdram</b> which simulates NOR flash in RAM;</li>
	<li><b>nandsim</b> which simulates NAND flash in RAM;</li>
	<li><b>block2mtd</b> which simulates NOR flash on top of a block
	device;</li>
</ul>

<p>For example, to get a 32MiB fake NOR flash, run</p>

<pre>
$ modprobe mtdram total_size=32768
</pre>

<p>or to get a 64MiB fake NAND flash, run</p>

<pre>
$ modprobe nandsim second_id_byte=0x36
</pre>

<p>See <a href="nand.html#L_nand_nandsim">here</a> for more information about
the NAND simulator.</p>

<p>To ensure that you have fake MTD devices, run "<code>cat /prof/mtd</code>".
It should print something like</p>

<pre>
dev:    size   erasesize  name
mtd0: 02000000 00020000 "mtdram test device"
mtd1: 04000000 00004000 "NAND simulator partition"
</pre>

<p>The fake MTD devices may further be attached to UBI (see
<a href="ubi.html#L_attachmtd">here</a>).</p>


<h3>Enable debugging</h3>

<p>Enable UBI debugging support in the configuration menu
(the "<b>UBI debugging</b>" check-box). When debugging is enabled, UBI
prints more information about errors, and adds extra assertions in the code
which may help to catch bugs.</p>

<p>In many cases, it is enough to just enable debugging. But sometimes it is
also useful to enable extra-self checks, which make sure internal data
structures are consistent and may catch the problem much earlier then it would
have been noticed otherwise. But the checks make UBI much slower.</p>

<h3>Debugging messages</h3>

<p>Sometimes it is necessary to make UBI print about what it is doing. This is
where UBI messages may be enabled. When they are enabled, UBI prints a lot and
the kernel ring buffer and this makes it slower. This section describes few
tricks and techniques which might be useful when debugging using the
messages.</p>

<p>The Linux kernel has internal ring buffer where all the debugging prints go.
User-space applications like <code>syslogd</code> usually read data from the
ring buffer, do further processing and the prints usually end up in the system
log file. When the UBI debugging messages are enabled, it prints huge amount of
messages. What happens is that the user-space processes are unable to fetch
them from the ring buffer with this pace so most of the messages are just lost.
Namely, they are just over-written with newer message (the buffer is a "ring").
There are 2 ways to gather all the messages:</p>

<ol>
	<li>use serial console;</li>
	<li>use very large ring buffer.</li>
</ol>

<p>The first method is usually appropriate when debugging on an small embedded
platform connected to a PC via serial line. What you have to be aware of is
that the messages are printed to the serial console synchronously, which means
that the system is blocked and waiting for the print operation to be finished.
So if there are many prints, the system speed becomes limited to the serial
console baud rate. And obviously, it is recommended to use higher baud rates,
e.g. 115200.</p>

<p>The UBI debugging messages have "debugging" level 7 and they are usually not
printed to the console. You may use <code>dmesg -n8</code> command to make all
kernel messages to go to the console. One useful trick is to boot the kernel
with <code>ignore_loglevel</code> option, in which case it will print all
messages to the console unconditionally.</p>

<p>The second method is more appropriate when debugging on a machine with a lot
of RAM, for example on a desktop PC with a flash emulator. Just make your ring
buffer large, e.g. 64MiB by booting the kernel with <code>log_buf_len=64M</code>
option. This will make the ring buffer fit enough messages to identify the
problem. And because the messages are printed to RAM, this is way quicker than
the first method.</p>

<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
