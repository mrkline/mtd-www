<PAGE>
<VAR match="VAR_ORIGIN" replace="../" />
<VAR match="VAR_CVSID" replace="Last updated: 6 Feb 2008, dedekind"/>
<INCLUDE file="../inc/header.tmpl" />

<VAR match="VAR_SEL_DOC" replace="selected" />
<VAR match="VAR_SEL_UBIFS" replace="selected" />
<PARSE file="../menu1.xml" />

<INCLUDE file="../inc/content.tmpl" />

<H1>UBIFS - UBI File-System</H1>

<H2>Table of contents</H2>
<OL>
	<LI><A HREF="ubifs.html#L_rednote">Big red note</A></LI>
	<LI><A HREF="ubifs.html#L_overview">Overview</A></LI>
	<LI><A HREF="ubifs.html#L_status">Current status</A></LI>
	<LI><A HREF="ubifs.html#L_source">Source code</A></LI>
	<LI><A HREF="ubifs.html#L_ml">Mailing list</A></LI>
	<LI><A HREF="ubifs.html#L_usptools">User-space tools</A></LI>
	<LI><A HREF="ubifs.html#L_scalability">Scalability</A></LI>
	<LI><A HREF="ubifs.html#L_todo">TODO and known problems</A></LI>
</OL>



<A NAME="L_rednote">
<H2><FONT COLOR="RED">Big red note</FONT></H2>
</A>

<P>One thing people have to understand when dealing with UBIFS is that UBIFS is
very different to any traditional file-system - it <B>does not</B> work on top
of block devices (like hard drive, an SD card, an USB stick, etc). It was
designed to work on top of UBI volumes, which have nothing to do with block
devices. This is why UBIFS does not work on MMC cards or USB flash sticks -
they look like block devices to the outside world because they implement
FTL (Flash Translation Layer) support in hardware, which simply speaking
emulates a block device on top of the built-in flash chip.
<A HREF="../faq/general.html#L_mtd_vs_hdd">This</A> FAQ entry describes the
difference between block devices and flash chips.</P>



<A NAME="L_overview"><H2>Overview</H2></A>

<P>UBIFS is a new flash file system which is designed to work on top
of UBI. The file system is developed by Nokia engineers with help of
<A href="http://www.inf.u-szeged.hu/tanszekek/szoftverfejlesztes/starten.xml">
the University of Szeged</A>.</P>

<P>UBIFS works on top of UBI volumes, it cannot operate on top of MTD
devices. In other words, there are 3 subsystems involved:</P>

<UL>
	<LI><I>MTD subsystem</I>, which provides a uniform interface to access
	flash chips. MTD provides a notion of MTD devices (e.g.,
	<CODE>/dev/mtd0</CODE>) which basically provide access to the raw
	flash;</LI>
	<LI><I>UBI subsystem</I>, which is a volume management system for flash
	devices; UBI works on top of MTD devices and provides a notion of
	UBI volumes; UBI volumes are more "high level" entities than MTD
	devices and they are devoid of many unpleasant issues MTD devices have
	(e.g., wearing and bad blocks); See <A HREF="ubi.html">here</A> for more
	information;</LI>
	<LI><I>UBIFS file-system</I>, which works on top of UBI volumes.</LI>
</UL>

<P>In contrast, JFFS2 file-system works on top of raw MTD devices.</P>

<P>The main objectives of UBIFS are:</P>

<OL>
	<LI>better scalability comparing to what JFFS2 provides, which is achieved
	by storing and maintaining the indexing data structures of the file-system
	on the flash media;</LI>
	<LI>write-back support;</LI>
	<LI>support of on-the-flight compression.</LI>
</OL>

<P>Please, find more comments to each of the above points in the following
sections.</P>

<P>Here is a short and unsorted list of some of UBIFS features:</P>

<UL>
	<LI>write-back support - this dramatically improves the throughput of
	the file-system comparing to JFFS2, which is write-through;</LI>

	<LI>fast mount time - unlike JFFS2, UBIFS does not have to scan whole
	media when mounting, it takes few milliseconds for UBIFS to mount
	the media, and this does not depend on flash size; the reason is that
	however, UBI
	initialization time depends on flash size and has to be taken into
	account (see
	<A HREF="ubi.html#L_scalability">here</A> for more details);</LI>

	<LI>tolerance to unclean reboots - UBIFS is a journaling file system
	and it tolerates sudden crashes and unclean reboots; UBIFS just replays
	the journal and recovers from the unclean reboot automatically; mount
	time is a little bit slower in this case, because of the need to read
	the journal, but UBIFS does not need to scan whole media, so it anyway
	takes fractions of second;</LI>

	<LI>fast I/O - even with write-back disabled (e.g., if UBIFS is mounted
	with <CODE>-o sync</CODE> mount flag UBIFS shows good performance
	which is close to JFFS2 performance; bear in mind, it is extremely
	difficult to compete with JFFS2 in synchronous I/O, because JFFS2 does
	not maintain indexing data structures on flash, so it does not have the
	maintenance overhead, while UBIFS does have it; the main UBIFS write
	speed booster is the write-back support; the other one is the way UBIFS
	commits the journal - it does not move the data physically from one
	place to another but instead, it just adds corresponding information to
	the file-system index and picks different eraseblocks for the new
	journal (i.e., UBIFS has sort of "wandering" journal);</LI>

	<LI>on-the-flight compression - the data is stored in compressed form
	on the flash media, which makes it possible to put considerably more
	data to the flash as if the data would not be compressed; this is
	similar to what JFFS2 has; UBIFS also allows to switch the
	compression on/off on per-inode basis, which very flexible; for
	example, one may switch the compression off by default and enable it
	only for certain files which are supposed to compress well; or one may
	switch compression on by default but disable it for supposedly
	uncompressible data like multimedia files; at the moment UBIFS supports
	only Zlib and LZO compressors and it is not difficult to add more;</LI>
</UL>



<A NAME="L_status"><H2>Current status</H2></A>

<P>UBIFS has proved to be fairly stable, however it needs more testing. It
needs some features like extended attributes support to be implemented. It
needs tuning, e.g., finding optimal journal size and fan-out of the indexing
tree. It also needs some profiling and bottleneck hunting.</P>

<P>UBIFS is not in the main-line kernel, but the authors a planning to start
the submission soon. But before can be done, UBIFS needs:</P>

<UL>
	<LI>code review - there are places in the source code which
	have to be fixed or cleaned-up;</LI>

	<LI>binary format has to be stabilized - it is difficult to change it
	once the FS in the main-line; on the other hand, UBIFS is a file-system
	for embedded device, and it is unlikely the flash chip is moved ever
	somewhere else from the original device, so the portability issues
	are not that important for UBIFS as, say, for ext2; this means, it is
	probably OK to do forward-compatible, but backward-incompatible binary
	format changes for UBIFS;</LI>

	<LI>UBIFS needs more users - the community does not usually accept stuff
	which has no or few users; people want to be sure that the piece of
	code is used, thus, maintained in the long term; on the other hand,
	users are reluctant to use software before it gets to main-line, which
	does not help getting there.</LI>
</UL>



<A NAME="L_source"><H2>Source code</H2></A>

<P>The UBIFS development git tree is:</P>

<CODE>git://git.infradead.org/~dedekind/ubifs-2.6.git</CODE>

<P>The git tree is usually based on top of the latest main-line Linux kernel
release candidate and it is re-based often. But there are also 2.6.22, 2.6.23,
and 2.6.24 back-ports, although they are not always up-to-date and one may want
to pick up additional patches from the main development tree to utilize the
latest UBIFS version. The back-ports may be found at the following git-trees:</P>

<CODE>git://git.infradead.org/~dedekind/ubifs-v2.6.24.git</CODE><BR/>
<CODE>git://git.infradead.org/~dedekind/ubifs-v2.6.23.git</CODE><BR/>
<CODE>git://git.infradead.org/~dedekind/ubifs-v2.6.22.git</CODE>

<P>Note, since it is impossible to register memory shrinker in kernel version
2.6.22, the UBIFS shrinker does not work there, which means the UBIFS TNC cache
never gets shrinked and the system may run out of memory if the file-system is
large enough.</P>



<A NAME="L_ml"><H2>Mailing list</H2></A>

<P>You are welcome to send feed-back, bug-reports, patches, etc to the
<A HREF="../mail.html">MTD mailing list</A>. There is no good UBIFS
documentation so far, so feel free to ask any questions.</P>



<A NAME="L_usptools"><H2>User-space tools</H2></A>

<P>There is only one UBIFS user-space tool at the moment -
<B>mkfs.ubifs</B>, which creates UBIFS images. The tool may be found at</P>

<CODE>git://git.infradead.org/~dedekind/mkfs.ubifs.git</CODE>

<P>The images produced by <CODE>mkfs.ubifs</CODE> may be written to
UBI volumes using <A HREF="ubi.html#L_usptools"><CODE>ubiupdate</CODE></A>
or may be further fed to the
<A HREF="ubi.html#L_usptools"><CODE>ubinize</CODE></A>
tool to create an UBI image which may be put to the MTD device.</P>



<A NAME="L_scalability"><H2>Scalability</H2></A>

<P>All the data structures UBIFS is using are trees, so it scales
logarithmically in terms of flash size. However, UBI scales linearly
(see <A HREF="ubi.html#L_scalability">here</A>) which makes
overall UBI/UBIFS stack scalability linear. But the UBIFS authors believe it is
always possible to create logarithmically scalable UBI2 and to improve the
situation. Current UBI should be OK for 2-16GiB flashes, depending on the
I/O speed and requirements.</P>



<A NAME="L_todo"><H2>TODO and known problems</H2></A>

<P>Here is a list of known UBIFS issues and the things which have to be
done:</P>

<OL>
	<LI>NOR support - UBIFS should support anything which is supported by
	UBI, but we never tested NOR support and there might be bugs; it makes
	sense to test this on <CODE>mtdram</CODE> and fix if needed;</LI>

	<LI>There is no interface to select compressor type (zlib or LZO) for
	an inode.</LI>
</OL>


<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
