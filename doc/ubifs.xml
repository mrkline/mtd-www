<PAGE>
<VAR match="VAR_ORIGIN" replace="../" />
<VAR match="VAR_CVSID" replace="Last updated: 27 March 2008, dedekind"/>
<INCLUDE file="../inc/header.tmpl" />

<VAR match="VAR_SEL_DOC" replace="selected" />
<VAR match="VAR_SEL_UBIFS" replace="selected" />
<PARSE file="../menu1.xml" />

<INCLUDE file="../inc/content.tmpl" />

<H1>UBIFS - UBI File-System</H1>

<H2>Table of contents</H2>
<OL>
	<LI><A HREF="ubifs.html#L_rednote">Big red note</A></LI>
	<LI><A HREF="ubifs.html#L_overview">Overview</A></LI>
	<LI><A HREF="ubifs.html#L_status">Current status</A></LI>
	<LI><A HREF="ubifs.html#L_source">Source code</A></LI>
	<LI><A HREF="ubifs.html#L_ml">Mailing list</A></LI>
	<LI><A HREF="ubifs.html#L_usptools">User-space tools</A></LI>
	<LI><A HREF="ubifs.html#L_scalability">Scalability</A></LI>
	<LI><A HREF="ubifs.html#L_xattr">Extended attributes</A></LI>
	<LI><A HREF="ubifs.html#L_documentation">Documentation</A></LI>
</OL>



<A NAME="L_rednote">
<H2><FONT COLOR="RED">Big red note</FONT></H2>
</A>

<P>One thing people have to understand when dealing with UBIFS is that UBIFS is
very different to any traditional file-system - it <B>does not</B> work on top
of block devices (like hard drive, an SD card, an USB stick, etc). It was
designed to work on top of UBI volumes, which have nothing to do with block
devices. This is why UBIFS does not work on MMC cards or USB flash sticks -
they look like block devices to the outside world because they implement
FTL (Flash Translation Layer) support in hardware, which simply speaking
emulates a block device on top of the built-in flash chip.
<A HREF="../faq/general.html#L_mtd_vs_hdd">This</A> FAQ entry describes the
difference between block devices and flash chips.</P>



<A NAME="L_overview"><H2>Overview</H2></A>

<P>UBIFS is a new flash file system which is designed to work on top
of UBI. The file system is developed by Nokia engineers with help of
<A href="http://www.inf.u-szeged.hu/tanszekek/szoftverfejlesztes/starten.xml">
the University of Szeged</A>.</P>

<P>UBIFS works on top of UBI volumes, it cannot operate on top of MTD
devices. In other words, there are 3 subsystems involved:</P>

<UL>
	<LI><I>MTD subsystem</I>, which provides a uniform interface to access
	flash chips. MTD provides a notion of MTD devices (e.g.,
	<CODE>/dev/mtd0</CODE>) which basically provide access to the raw
	flash;</LI>
	<LI><I>UBI subsystem</I>, which is a volume management system for flash
	devices; UBI works on top of MTD devices and provides a notion of
	UBI volumes; UBI volumes are more "high level" entities than MTD
	devices and they are devoid of many unpleasant issues MTD devices have
	(e.g., wearing and bad blocks); See <A HREF="ubi.html">here</A> for more
	information;</LI>
	<LI><I>UBIFS file-system</I>, which works on top of UBI volumes.</LI>
</UL>

<P>In contrast, JFFS2 file-system works on top of raw MTD devices.</P>

<P>The main objectives of UBIFS are:</P>

<OL>
	<LI>better scalability comparing to what JFFS2 provides, which is achieved
	by storing and maintaining the indexing data structures of the file-system
	on the flash media;</LI>
	<LI>write-back support;</LI>
	<LI>support of on-the-flight compression.</LI>
</OL>

<P>Please, find more comments to each of the above points in the following
sections.</P>

<P>Here is a short and unsorted list of some of UBIFS features:</P>

<UL>
	<LI>write-back support - this dramatically improves the throughput of
	the file-system comparing to JFFS2, which is write-through;</LI>

	<LI>fast mount time - unlike JFFS2, UBIFS does not have to scan whole
	media when mounting, it takes few milliseconds for UBIFS to mount
	the media, and this does not depend on flash size; the reason is that
	however, UBI
	initialization time depends on flash size and has to be taken into
	account (see
	<A HREF="ubi.html#L_scalability">here</A> for more details);</LI>

	<LI>tolerance to unclean reboots - UBIFS is a journaling file system
	and it tolerates sudden crashes and unclean reboots; UBIFS just replays
	the journal and recovers from the unclean reboot automatically; mount
	time is a little bit slower in this case, because of the need to read
	the journal, but UBIFS does not need to scan whole media, so it anyway
	takes fractions of second;</LI>

	<LI>fast I/O - even with write-back disabled (e.g., if UBIFS is mounted
	with <CODE>-o sync</CODE> mount flag UBIFS shows good performance
	which is close to JFFS2 performance; bear in mind, it is extremely
	difficult to compete with JFFS2 in synchronous I/O, because JFFS2 does
	not maintain indexing data structures on flash, so it does not have the
	maintenance overhead, while UBIFS does have it; the main UBIFS write
	speed booster is the write-back support; the other one is the way UBIFS
	commits the journal - it does not move the data physically from one
	place to another but instead, it just adds corresponding information to
	the file-system index and picks different eraseblocks for the new
	journal (i.e., UBIFS has sort of "wandering" journal);</LI>

	<LI>on-the-flight compression - the data is stored in compressed form
	on the flash media, which makes it possible to put considerably more
	data to the flash as if the data would not be compressed; this is
	similar to what JFFS2 has; UBIFS also allows to switch the
	compression on/off on per-inode basis, which very flexible; for
	example, one may switch the compression off by default and enable it
	only for certain files which are supposed to compress well; or one may
	switch compression on by default but disable it for supposedly
	uncompressible data like multimedia files; at the moment UBIFS supports
	only Zlib and LZO compressors and it is not difficult to add more;</LI>
</UL>



<A NAME="L_status"><H2>Current status</H2></A>

<P>UBIFS has proved to be fairly stable, however it needs more testing, review,
and tuning (e.g., finding optimal journal size, etc).  It also needs some
profiling and bottleneck hunting.</P>



<A NAME="L_source"><H2>Source code</H2></A>

<P>The UBIFS development git tree is:</P>

<CODE>git://git.infradead.org/~dedekind/ubifs-2.6.git</CODE>

<P>The git tree is usually based on top of the latest main-line Linux kernel
release candidate and it is re-based often. But there are also 2.6.21, 2.6.22,
2.6.23, and 2.6.24 back-ports, although they are not always up-to-date and one
may want to pick up additional patches from the main development tree to utilize
the latest UBIFS version. The back-ports may be found at the following
git-trees:</P>

<CODE>git://git.infradead.org/~dedekind/ubifs-v2.6.24.git</CODE><BR/>
<CODE>git://git.infradead.org/~dedekind/ubifs-v2.6.23.git</CODE><BR/>
<CODE>git://git.infradead.org/~dedekind/ubifs-v2.6.22.git</CODE><BR/>
<CODE>git://git.infradead.org/~dedekind/ubifs-v2.6.21.git</CODE>

<P>Note, since it is impossible to register memory shrinker in kernel versions
2.6.21/2.6.22, the UBIFS shrinker does not work there, which means the UBIFS TNC
cache never gets shrinked and the system may run out of memory if the
file-system is large enough.</P>



<A NAME="L_ml"><H2>Mailing list</H2></A>

<P>You are welcome to send feed-back, bug-reports, patches, etc to the
<A HREF="../mail.html">MTD mailing list</A>. There is no good UBIFS
documentation so far, so feel free to ask any questions.</P>



<A NAME="L_usptools"><H2>User-space tools</H2></A>

<P>There is only one UBIFS user-space tool at the moment -
<B>mkfs.ubifs</B>, which creates UBIFS images. The tool may be found at</P>

<CODE>git://git.infradead.org/~dedekind/mkfs.ubifs.git</CODE>

<P>The images produced by <CODE>mkfs.ubifs</CODE> may be written to
UBI volumes using <A HREF="ubi.html#L_usptools"><CODE>ubiupdatevol</CODE></A>
or may be further fed to the
<A HREF="ubi.html#L_usptools"><CODE>ubinize</CODE></A>
tool to create an UBI image which may be put to the MTD device.</P>



<A NAME="L_scalability"><H2>Scalability</H2></A>

<P>All the data structures UBIFS is using are trees, so it scales
logarithmically in terms of flash size. However, UBI scales linearly
(see <A HREF="ubi.html#L_scalability">here</A>) which makes
overall UBI/UBIFS stack scalability linear. But the UBIFS authors believe it is
always possible to create logarithmically scalable UBI2 and to improve the
situation. Current UBI should be OK for 2-16GiB flashes, depending on the
I/O speed and requirements.</P>

<P>Note, although the UBI scalability is linear, it anyway scales better
then JFFS2, which was originally designed for small ~32MiB NOR flashes. JFFS2
has scalability issues on the "file-system level", while UBI/UBIFS stack has
scalability issues only on lower "raw flash level". The following table
describes the issues in more details.</P>

<TABLE BORDER="2" CELLPADDING="4" CELLSPACING="0">
<TR>
	<TD><B>Scalability issue</B></TD>
	<TD><B>JFFS2</B></TD><TD><B>UBIFS</B></TD>
</TR>

<TR>
	<TD>Mount time linearly depends on the flash size</TD>
	<TD>True, the dependency is linear, because JFFS2 has to scan whole
	    flash media when mounting.</TD>
	<TD>UBIFS mount time does not depend on the flash size. But UBI needs
	    to scan the flash media, which is actually quicker than JFFS2
	    scanning. So overall, UBI/UBIFS has the linear dependency.</TD>
</TR>

<TR>
	<TD>Memory consumption linearly depends on the flash size</TD>
	<TD>True, the dependency is linear.</TD>
	<TD>UBIFS memory does depend on the flash size in the current implementation,
	    because the LPT shrinker is not implemented. But it is not
	    difficult to implement the LPT shrinker and get rid of the
	    dependency. It is not implemented only because the memory
	    consumption is too small to make the coding work worth it. UBI
	    memory consumption linearly depends on flash size. Thus, overall
	    UBI/UBIFS stack has the linear dependency.</TD>
</TR>

<TR>
	<TD>Mount time linearly depends on the file-system contents</TD>
	<TD>True, the more data is stored on the file-system, the longer it
	    takes to mount it, because JFFS2 has to do more scanning work.</TD>
	<TD>False, mount time does not depend on the file-system contents. At
	    the worst case (if there was an unclean reboot), UBIFS has to scan
	    and replay the journal which has fixed and configurable size.</TD>
</TR>

<TR>
	<TD>Full file-system checking is required after each mount</TD>
	<TD>True. JFFS2 has to check whole file system just after it has been
	    mounted in case of NAND flash. The checking involves reading all
	    nodes for each inode and checking their CRC checksums, which
	    consumes a lot of CPU. For example, this may be seen by running the
	    <CODE>top</CODE> utility just after JFFS2 has been mounted. This
	    slows down overall system boot-up time. Fundamentally, this is
	    needed because JFFS2 does not store space accounting information
	    (i.e., free/dirty space) on the flash media but instead, gathers
	    this information by scanning the flash media.</TD>
	<TD>False. UBIFS does not scan/check whole file-system because it stores
	    the space accounting information on the flash media in the so-called
	    LPT (Logical eraseblock Properties Tree) tree.</TD>
</TR>

<TR>
	<TD>Memory consumption linearly depends on file-system contents</TD>
	<TD>True. JFFS2 keeps a small data structure in RAM for each node on
	    flash, so the more data is stored on the flash media, the more
	    memory JFFS2 consumes.</TD>
	<TD>False. UBIFS memory consumption does not depend on how much data is
	    stored on the flash media.</TD>
</TR>

<TR>
	<TD>The first file access time linearly depends on its size</TD>
	<TD>True. JFFS2 has to keep in RAM so-called "fragment tree" for each
	    inode corresponding to an opened file. The fragment tree is an
	    in-memory RB-tree which is indexed by file offset and refers
	    on-flash nodes corresponding to this offset. The fragment tree is
	    <I>not</I> stored on the flash media. Instead, it is built
	    on-the-flight when the file is opened for the first time. To build
	    the fragment tree, JFFS2 has to read each data node corresponding
	    to this inode from the flash. This means, the larger is the file,
	    the longer it takes to open it for the first time. And the larger
	    is the file the more memory it takes when it is opened. Depending
	    on the system, JFFS2 becomes nearly unusable starting from certain
	    file size.</TD>
	<TD>False. UBIFS stores all the indexing information on the media in
	    the indexing B-tree. Whenever a piece of data has to be read from
	    the file-system, the B-tree is looked-up and the corresponding
	    flash address to read is found. There is a TNC cache which caches
	    the B-tree nodes whin the B-tree is looked-up, and the cache is
	    shrinkable, which means it might be shrunk when the kernel needs
	    more memory.</TD>
</TR>

<TR>
	<TD>File-system performance depends on I/O history</TD>
	<TD>True. Since JFFS2 is fully synchronous, it writes data to the flash
	    media as soon as the data arrives. If one changes few bytes in the
	    middle of a file, JFFS2 writes a data node which contains those
	    bytes to the flash. If there are many random small writes all
	    over the place, the file-system becomes fragmented. JFFS2 merges
	    small fragments to 4KiB chunks, which involves re-compression and
	    re-writing the data. But this "de-fragmentation" is happening
	    during garbage collection and at random time, because JFFS2
	    wear-leveling algorithm is based on random eraseblock selection. So
	    if there were a lot of small writes, JFFS2 becomes slower some time
	    later - the performance just drops out of the blue which makes the
	    system less predictable.</TD>
	<TD>False. UBIFS always writes in 4KiB chunks. This does not hurt the
	    performance because of write-back support: the data changes do not
	    go to the flash straight away - they are instead deferred and are
	    done later, when (hopefully) more data is changed at the same data
	    page and usually in background.</TD>
</TR>
</TABLE>



<A NAME="L_xattr"><H2>Extended attributes</H2></A>

<P>UBIFS supports extended attributes if the corresponding configuration option
is enabled (no additional mount options are required). It supports
<CODE>user</CODE>, <CODE>trusted</CODE>, and <CODE>security</CODE> name-spaces.
Access control list (ACL) support is not implemented.</P>



<A NAME="L_documentation"><H2>Documentation</H2></A>

<P>The UBIFS white-paper which briefly describes main UBIFS design aspects is
available here: <A HREF="ubifs_whitepaper.pdf">ubifs_whitepaper.pdf</A>. There is
<A HREF="../faq/ubifs.html">UBIFS FAQ</A> which might be useful. Also, there is
<A HREF="http://osl.sed.hu/wiki/ubifs/index.php/Main_Page">a wiki page</A>, but
it has a lot of out-of-date information.</P>


<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
