<PAGE>
<VAR match="VAR_ORIGIN" replace="../" />
<VAR match="VAR_CVSID" replace="Last updated: 29 May 2008, dedekind"/>
<INCLUDE file="../inc/header.tmpl" />

<VAR match="VAR_SEL_DOC" replace="selected" />
<VAR match="VAR_SEL_UBIFS" replace="selected" />
<PARSE file="../menu1.xml" />

<INCLUDE file="../inc/content.tmpl" />

<h1>UBIFS - UBI File-System</h1>

<h2>Table of contents</h2>
<ol>
	<li><a href="ubifs.html#L_rednote">Big red note</a></li>
	<li><a href="ubifs.html#L_overview">Overview</a></li>
	<li><a href="ubifs.html#L_status">Current status</a></li>
	<li><a href="ubifs.html#L_source">Source code</a></li>
	<li><a href="ubifs.html#L_ml">Mailing list</a></li>
	<li><a href="ubifs.html#L_usptools">User-space tools</a></li>
	<li><a href="ubifs.html#L_scalability">Scalability</a></li>
	<li><a href="ubifs.html#L_writeback">Write-back support</a></li>
	<li><a href="ubifs.html#L_xattr">Extended attributes</a></li>
	<li><a href="ubifs.html#L_mountopts">Mount options</a></li>
	<li><a href="ubifs.html#L_documentation">Documentation</a></li>
	<li><a href="ubifs.html#L_how_send_bugreport">How to send an UBIFS bugreport?</a></li>
</ol>



<h2><a name="L_rednote"><font color="red">Big red note</font></a></h2>

<p>One thing people have to understand when dealing with UBIFS is that UBIFS is
very different to any traditional file-system - it <b>does not</b> work on top
of block devices (like hard drive, an SD card, an USB stick, etc). It was
designed to work on top of UBI volumes, which have nothing to do with block
devices. This is why UBIFS does not work on MMC cards or USB flash sticks -
they look like block devices to the outside world because they implement
FTL (Flash Translation Layer) support in hardware, which simply speaking
emulates a block device on top of the built-in flash chip.
<a href="../faq/general.html#L_mtd_vs_hdd">This</a> FAQ entry describes the
difference between block devices and flash chips.</p>



<h2><a name="L_overview">Overview</a></h2>

<p>UBIFS is a new flash file system which is designed to work on top
of UBI. The file system is developed by Nokia engineers with help of
<a href="http://www.inf.u-szeged.hu/tanszekek/szoftverfejlesztes/starten.xml">
the University of Szeged</a>.</p>

<p>UBIFS works on top of UBI volumes, it cannot operate on top of MTD
devices. In other words, there are 3 subsystems involved:</p>

<ul>
	<li><i>MTD subsystem</i>, which provides a uniform interface to access
	flash chips. MTD provides a notion of MTD devices (e.g.,
	<code>/dev/mtd0</code>) which basically provides access to the raw
	flash;</li>
	<li><i>UBI subsystem</i>, which is a volume management system for flash
	devices; UBI works on top of MTD devices and provides a notion of
	UBI volumes; UBI volumes are higher level entities than MTD
	devices and they are devoid of many unpleasant issues MTD devices have
	(e.g., wearing and bad blocks); see <a href="ubi.html">here</a> for more
	information;</li>
	<li><i>UBIFS file-system</i>, which works on top of UBI volumes.</li>
</ul>

<p>In contrast, JFFS2 file-system works on top of raw MTD devices.</p>

<p>The main objectives of UBIFS are:</p>

<ol>
	<li>better scalability comparing to what JFFS2 provides, which is achieved
	by storing and maintaining the indexing data structures of the file-system
	on the flash media;</li>
	<li>write-back support;</li>
	<li>support of on-the-flight compression.</li>
</ol>

<p>Please, find more comments to each of the above points in the following
sections.</p>

<p>Here is a short and unsorted list of some of UBIFS features:</p>

<ul>
	<li>write-back support - this dramatically improves the throughput of
	the file-system comparing to JFFS2, which is write-through;</li>

	<li>fast mount time - unlike JFFS2, UBIFS does not have to scan whole
	media when mounting, it takes milliseconds for UBIFS to mount the
	media, and this does not depend on flash size; however, UBI
	initialization time depends on flash size and has to be taken into
	account (see <a href="ubi.html#L_scalability">here</a> for more
	details);</li>

	<li>tolerance to unclean reboots - UBIFS is a journaling file system
	and it tolerates sudden crashes and unclean reboots; UBIFS just replays
	the journal and recovers from the unclean reboot; mount time is a
	little bit slower in this case, because of the need to replay the
	journal, but UBIFS does not need to scan whole media, so it anyway
	takes fractions of a second;</li>

	<li>fast I/O - even with write-back disabled (e.g., if UBIFS is mounted
	with <code>-o sync</code> mount flag) UBIFS shows good performance
	which is close to JFFS2 performance; bear in mind, it is extremely
	difficult to compete with JFFS2 in synchronous I/O, because JFFS2 does
	not maintain indexing data structures on flash, so it does not have the
	maintenance overhead, while UBIFS does have it; this is because of the
	way UBIFS commits the journal - it does not move the data physically
	from one place to another but instead, it just adds corresponding
	information to the file-system index and picks different eraseblocks
	for the new journal (i.e., UBIFS has sort of "wandering"
	journal);</li>

	<li>on-the-flight compression - the data is stored in compressed form
	on the flash media, which makes it possible to put considerably more
	data to the flash than if the data was not compressed; this is very
	similar to what JFFS2 has; UBIFS also allows to switch the compression
	on/off on per-inode basis, which is very flexible; for example, one may
	switch the compression off by default and enable it only for certain
	files which are supposed to compress well; or one may switch
	compression on by default but disable it for supposedly uncompressible
	data like multimedia files; at the moment UBIFS supports only Zlib and
	LZO compressors and it is not difficult to add more;</li>
</ul>



<h2><a name="L_status">Current status</a></h2>

<p>UBIFS has proved to be fairly stable, however it needs more testing, review,
and tuning (e.g., finding optimal journal size, etc). It also needs some
profiling and bottleneck hunting.</p>



<h2><a name="L_source">Source code</a></h2>

<p>The UBIFS development git tree is:</p>

<code>git://git.infradead.org/~dedekind/ubifs-2.6.git</code>

<p>The git tree is usually based on top of the latest main-line Linux kernel
release candidate and it is re-based often. But there are also 2.6.21, 2.6.22,
2.6.23, 2.6.24, and 2.6.25 back-ports, although they are not always up-to-date
and one may want to pick up additional patches from the main development tree
to utilize the latest UBIFS version. The back-ports may be found at the
following git-trees:</p>

<code>git://git.infradead.org/~dedekind/ubifs-v2.6.25.git</code><br/>
<code>git://git.infradead.org/~dedekind/ubifs-v2.6.24.git</code><br/>
<code>git://git.infradead.org/~dedekind/ubifs-v2.6.23.git</code><br/>
<code>git://git.infradead.org/~dedekind/ubifs-v2.6.22.git</code><br/>
<code>git://git.infradead.org/~dedekind/ubifs-v2.6.21.git</code>

<p>Since it is impossible to register memory shrinker in kernel versions 2.6.21
and 2.6.22, the UBIFS shrinker does not work there, which means the UBIFS TNC
cache never gets shrinked and the system may run out of memory if the
file-system is large enough.</p>

<p>The 2.6.21 back-port will not support writable (shared) memory maps,
just like JFFS2. So some applications like apt-get won't always work. However,
it should not be very difficult to back-port this from newer kernel if it is
really needed.</p>

<p>All the back-port trees also have many MTD patches back-ported, and they
have all the UBI changes back-ported as well.</p>



<h2><a name="L_ml">Mailing list</a></h2>

<p>You are welcome to send feed-back, bug-reports, patches, etc to the
<a href="../mail.html">MTD mailing list</a>. Feel free to ask questions.</p>



<h2><a name="L_usptools">User-space tools</a></h2>

<p>There is only one UBIFS user-space tool at the moment -
<b>mkfs.ubifs</b>, which creates UBIFS images. The tool may be found at</p>

<code>git://git.infradead.org/~dedekind/mkfs.ubifs.git</code>

<p>The images produced by <code>mkfs.ubifs</code> may be written to
UBI volumes using <a href="ubi.html#L_usptools"><code>ubiupdatevol</code></a>
or may be further fed to the
<a href="ubi.html#L_usptools"><code>ubinize</code></a>
tool to create an UBI image which may be put to the MTD device.</p>



<h2><a name="L_scalability">Scalability</a></h2>

<p>All the data structures UBIFS is using are trees, so it scales
logarithmically in terms of flash size. However, UBI scales linearly
(see <a href="ubi.html#L_scalability">here</a>) which makes
overall UBI/UBIFS stack scalability linear. But the UBIFS authors believe it is
always possible to create logarithmically scalable UBI2 and to improve the
situation. Current UBI should be OK for 2-16GiB flashes, depending on the
I/O speed and requirements.</p>

<p>Note, although the UBI scalability is linear, it anyway scales better much
than JFFS2, which was originally designed for small ~32MiB NOR flashes. JFFS2
has scalability issues on the "file-system level", while UBI/UBIFS stack has
scalability issues only on lower "raw flash level". The following table
describes the issues in more details.</p>

<table border="2" cellpadding="4" cellspacing="0">
<tr>
	<td><b>Scalability issue</b></td>
	<td><b>JFFS2</b></td><td><b>UBIFS</b></td>
</tr>

<tr>
	<td>Mount time linearly depends on the flash size</td>
	<td>True, the dependency is linear, because JFFS2 has to scan whole
	    flash media when mounting.</td>
	<td>UBIFS mount time does not depend on the flash size. But UBI needs
	    to scan the flash media, which is actually quicker than JFFS2
	    scanning. So overall, UBI/UBIFS has this linear dependency.</td>
</tr>

<tr>
	<td>Memory consumption linearly depends on the flash size</td>
	<td>True, the dependency is linear.</td>
	<td>UBIFS memory does depend on the flash size in the current
	    implementation, because the LPT shrinker is not implemented. But it
	    is not difficult to implement the LPT shrinker and get rid of the
	    dependency. It is not implemented only because the memory
	    consumption is too small to make the coding work worth it. UBI
	    memory consumption linearly depends on flash size. Thus, overall
	    UBI/UBIFS stack has the linear dependency.</td>
</tr>

<tr>
	<td>Mount time linearly depends on the file-system contents</td>
	<td>True, the more data is stored on the file-system, the longer it
	    takes to mount it, because JFFS2 has to do more scanning work.</td>
	<td>False, mount time does not depend on the file-system contents. At
	    the worst case (if there was an unclean reboot), UBIFS has to scan
	    and replay the journal which has fixed and configurable size.</td>
</tr>

<tr>
	<td>Full file-system checking is required after each mount</td>
	<td>True. JFFS2 has to check whole file system just after it has been
	    mounted in case of NAND flash. The checking involves reading all
	    nodes for each inode and checking their CRC checksums, which
	    consumes a lot of CPU. For example, this may be seen by running the
	    <code>top</code> utility just after JFFS2 has been mounted. This
	    slows down overall system boot-up time. Fundamentally, this is
	    needed because JFFS2 does not store space accounting information
	    (i.e., free/dirty space) on the flash media but instead, gathers
	    this information by scanning the flash media.</td>
	<td>False. UBIFS does not scan/check whole file-system because it stores
	    the space accounting information on the flash media in the so-called
	    LPT (Logical eraseblock Properties Tree) tree.</td>
</tr>

<tr>
	<td>Memory consumption linearly depends on file-system contents</td>
	<td>True. JFFS2 keeps a small data structure in RAM for each node on
	    flash, so the more data is stored on the flash media, the more
	    memory JFFS2 consumes.</td>
	<td>False. UBIFS memory consumption does not depend on how much data is
	    stored on the flash media.</td>
</tr>

<tr>
	<td>The first file access time linearly depends on its size</td>
	<td>True. JFFS2 has to keep in RAM so-called "fragment tree" for each
	    inode corresponding to an opened file. The fragment tree is an
	    in-memory RB-tree which is indexed by file offset and refers
	    on-flash nodes corresponding to this offset. The fragment tree is
	    <i>not</i> stored on the flash media. Instead, it is built
	    on-the-flight when the file is opened for the first time. To build
	    the fragment tree, JFFS2 has to read each data node corresponding
	    to this inode from the flash. This means, the larger is the file,
	    the longer it takes to open it for the first time. And the larger
	    is the file the more memory it takes when it is opened. Depending
	    on the system, JFFS2 becomes nearly unusable starting from certain
	    file size.</td>
	<td>False. UBIFS stores all the indexing information on the media in
	    the indexing B-tree. Whenever a piece of data has to be read from
	    the file-system, the B-tree is looked-up and the corresponding
	    flash address to read is found. There is a TNC cache which caches
	    the B-tree nodes when the B-tree is looked-up, and the cache is
	    shrinkable, which means it might be shrunk when the kernel needs
	    more memory.</td>
</tr>

<tr>
	<td>File-system performance depends on I/O history</td>
	<td>True. Since JFFS2 is fully synchronous, it writes data to the flash
	    media as soon as the data arrives. If one changes few bytes in the
	    middle of a file, JFFS2 writes a data node which contains those
	    bytes to the flash. If there are many random small writes all
	    over the place, the file-system becomes fragmented. JFFS2 merges
	    small fragments to 4KiB chunks, which involves re-compression and
	    re-writing the data. But this "de-fragmentation" is happening
	    during garbage collection and at random time, because JFFS2
	    wear-leveling algorithm is based on random eraseblock selection. So
	    if there were a lot of small writes, JFFS2 becomes slower some time
	    later - the performance just goes down out of the blue which makes
	    the system less predictable.</td>
	<td>False. UBIFS always writes in 4KiB chunks. This does not hurt the
	    performance much because of the write-back support: the data
	    changes do not go to the flash straight away - they are instead
	    deferred and are done later, when (hopefully) more data is changed
	    at the same data page and usually in background.</td>
</tr>
</table>



<h2><a name="L_writeback">Write-back support</a></h2>

<p>UBIFS supports write-back, which means that file changes do not go to the
flash media straight away, but they are cached and go to the flash later, when
it is absolutely necessary. This helps to greatly reduce the amount of I/O
which results in better performance. Write-back caching is standard technique
which exists in many modern file-systems like <code>ext3</code> or
<code>XFS</code>.</p>

<p>In contrast, <code>JFFS2</code> does not have write-back support and all the
JFFS2 file-system changes go the flash synchronously. Well, this is not
completely true and JFFS2 does have a small buffer of a NAND page size, but it
is small and we may treat JFFS2 as completely synchronous.</p>

<p>Write-back support requires the application programmers to take extra care
about synchronizing important files in time. Otherwise the file contents and
meta-data may corrupt or disappear in case of power-cuts, which happen very
often in many embedded devices. Let's look at what Linux manual pages say:</p>

<pre>
$ man 2 write
....
NOTES
       A  successful return from write() does not make any guarantee that data
       has been committed to disk.  In fact, on some buggy implementations, it
       does  not  even guarantee that space has successfully been reserved for
       the data.  The only way to be sure is to call fsync(2)  after  you  are
       done writing all your data.
...
</pre>

<p>This is true for UBIFS (except of the "some buggy implementations" part,
because UBIFS does reserves space for cached dirty data). Very often, people
who are accustomed to JFFS2 do not take this aspect into account and got
confused when unclean reboots corrupt their files. The following is a list
of useful hints and advices.</p>

<ul>
	<li>If you want to switch into "JFFS2 mode" and have a synchronous
	file-system, use <code>-o sync</code> option when mounting UBIFS;
	however, the file-system performance will drop, so this is not
	recommended unless you absolutely have to have a synchronous FS;</li>

	<li>Always keep in mind the above statement from the manual pages and
	run <code>fsync()</code> for all the important files you change; of
	course, there is no need to synchronize "throw-away" temporary files;
	Just think how important is the file data and decide;</li>

	<li>If you want to be more accurate, you may use
	<code>fdatasync()</code>, in which cases only data changes will be
	flushed, but not inode meta-data changes (e.g., "<i>mtime</i>"
	or permissions); this might be more optimal than using
	<code>fsync()</code> if the synchronization is done often, e.g., in
	a loop; otherwise just stick with  <code>fsync()</code>;</li>

	<li>In shell, the <code>sync</code> command may be used, but it
	synchronizes whole file-system which might be not very optimal; and
	there is a similar <i>libc</i> <code>sync()</code> function;</li>

	<li>Alternatively to <code>fdatasync()</code> you may use
	<code>O_SYNC</code> flag of the <code>open()</code> call; this will
	make sure all the data (but not meta-data) changes go to the media
	before the <code>write()</code> operation returns;</li>

	<li>It is possible to make certain inodes to be synchronous by
	default by setting the "<i>sync</i>" flag; in a shell, the
	<code>chattr +S</code> command may be used; in <i>C</i> programs,
	use the <code>FS_IOC_SETFLAGS</code> <code>ioctl</code> command;
	Note, the <a href="ubifs.html#L_usptools"><code>mkfs.ubifs</code></a>
	tool checks for the "<i>sync</i>" flag in the original FS tree, so
	the synchronous files in the original FS tree will be synchronous in
	the resulting UBIFS image.</li>
</ul>

<p>The above items are actually true for other file systems like
<code>ext3</code>, and may even be applied to <code>JFFS2</code>.</p>

<p><code>fsync()</code> may be called for directories - it synchronizes
the directory inode meta-data. The "<i>sync</i>" flag may also be set for
directories to make the directory inode synchronous. But the flag is inherited,
which means all new children of this directory will also have this flag. New
sub-directories of this directory will also be synchronous, and their children,
and so forth. This feature is very useful if one needs to create a whole
sub-tree of synchronous files and directories, or to make all new children
of some directory to be synchronous by default (e.g., <code>/etc</code>).</p>

<p>The <code>fdatasync()</code> call for directories is "no-op" in UBIFS and
all UBIFS operations which change directory entries are synchronous.
However, it might be a good idea not to assume this for better portability
(e.g., this is not true for <code>ext2</code>). Similarly, the "<i>dirsync</i>"
inode flag has no effect in UBIFS.</p>

<p>The functions mentioned above work on file-descriptors, not on streams
(<code>FILE *</code>). To synchronize a stream, you should first get its file
descriptor using the <code>fileno()</code> <i>libc</i> function, then flush the
stream using <code>fflush()</code>, and then synchronize the file using
<code>fsync()</code> or <code>fdatasync()</code>. You may use different
synchronization methods, but remember to flush the stream before synchronizing.
The <code>fflush()</code> function flushes the <i>libc</i>-level buffers, while
<code>sync()</code>, <code>fsync()</code>, etc flush <i>kernel</i>-level
buffers.</p>



<h2><a name="L_xattr">Extended attributes</a></h2>

<p>UBIFS supports extended attributes if the corresponding configuration option
is enabled (no additional mount options are required). It supports
<code>user</code>, <code>trusted</code>, and <code>security</code> name-spaces.
However, access control lists (ACL) support is not implemented.</p>



<h2><a name="L_mountopts">Mount options</a></h2>

<p>The following are UBIFS-specific mount options.</p>

<ul>
	<li><code>norm_unmount</code> (default) - commit on unmount; the
	journal is committed when the file-system is unmounted so that the next
	mount does not have to replay the journal and it becomes very
	fast;</li>

	<li><code>fast_umount</code> - do not commit on unmount; this option
	makes unmount faster, but the next mount slower because of the need to
	replay the journal.</li>
</ul>

<p>Besides, UBIFS supports the standard <code>sync</code> mount option which
may be used to disable UBIFS write-back and write-buffer caching and make it
fully synchronous. Note, UBIFS does not support "<i>atime</i>", so the
<code>atime</code> mount option has no effect.</p>



<h2><a name="L_documentation">Documentation</a></h2>

<p>The UBIFS white-paper which briefly describes main UBIFS design aspects is
available here: <a href="ubifs_whitepaper.pdf">ubifs_whitepaper.pdf</a>. There is
<a href="../faq/ubifs.html">UBIFS FAQ</a> which might be useful. Also, there is
<a href="http://osl.sed.hu/wiki/ubifs/index.php/Main_Page">a wiki page</a>, but
it has a lot of out-of-date information.</p>



<h2><a name="L_how_send_bugreport">How to send an UBIFS bugreport?</a></h2>

<p>Before sending a bug report:</p>
<ul>
	<li>make sure you have compiled kernel symbols in
	(<code>CONFIG_KALLSYMS_ALL=y</code> in <code>.config</code>);</li>

	<li>enable UBIFS debugging (<code>CONFIG_UBIFS_FS_DEBUG=y</code>
	in <code>.config</code>).</li>
</ul>

<p>Please, attach all the bug-related messages including the UBIFS messages from
the kernel ring buffer, which may be collected using the <code>dmesg</code>
utility or using <code>minicom</code> with serial console capturing. And of
course, it is wise to describe how the problem can be reproduced. The bugreport
should be sent to the <a href="../mail.html">MTD mailing list</a>.</p>


<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
