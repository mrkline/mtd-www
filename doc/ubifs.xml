<PAGE>
	<VAR match="VAR_ORIGIN" replace="../" />
	<VAR match="VAR_CVSID" replace="$Id: ubifs.xml,v 1.3 2005/11/02 12:27:23 dedekind Exp $"/>
	<INCLUDE file="../inc/header.tmpl" />

	<VAR match="VAR_SEL_DOC" replace="selected" />
	<VAR match="VAR_SEL_UBIFS" replace="selected" />
	<PARSE file="../menu1.xml" />

	<INCLUDE file="../inc/content.tmpl" />

	<H2>UBIFS - new flash file system</H2>

	<P>UBIFS is a new flash file system which is designed to work on top
	of UBI. At the moment the file system is developed by Nokia engineers
	and the <A href="http://www.inf.u-szeged.hu/tanszekek/szoftverfejlesztes/starten.xml">
	University of Szeged</A>.</P>

	<P>UBIFS is the new name for the old JFFS3 project. We already have
	working code which may be found at
	<CODE>git://git.infradead.org/~dedekind/ubifs-2.6.git</CODE>. The
	file-system works more or less stably, although it needs clean-ups
	and some features to be added. Nevertheless, major things are already
	implemented and work:</P>
	<UL>
		<LI>write-back (JFFS2 is write-through for example);</LI>
		<LI>on-flash LPT - per-logical eraseblock information which is
		needed when looking for an empty LEB or a target LEB to do
		garbage-collection is stored on flash in form of LPT
		(LEB Properties Tree);</LI>
		<LI>garbage collection of data nodes an indexing nodes;</LI>
		<LI>multi-headed journal (GC has its own write head, nodes
		which are expected to be changed soon have their own write
		head;</LI>
		<LI>srinker - TNC (Tree Node Cache) which caches indexing nodes
		may be shrink if Linux VM needs more memory;</LI>
		<LI>compression - for now we only support LZO, although other
		compressors will be added later;</LI>
		<LI>orphan files are supported and handled;</LI>
	</UL>

	<P>There are many less crucial features to add though, e.g., xattr
	support.</P>

	<P>We do not have any decent documentation so far, but some documentation
	may be found at
	<A href="http://osl.sed.hu/wiki/ubifs">UBIFS Wiki page</A>. Better
	documentation will be written over time when we have more or less
	ready-to-use code.</P>

	<P>Using UBI was our design decision. The following is an explanation of
	why.</P>

	<P>First off, we have realized that creating a scalable flash file
	system on top of bare flash is a difficult task, just because the
	flash media is so problematic (wear-leveling, bad eraseblocks). We
	have tried this way, and it turned out to be that we solved media problems,
	instead of concentrating on file system issues. So we decided to split
	one big and complex tasks into 2 sub-tasks: UBI solves the media problems,
	like bad eraseblocks and wear-leveling, and UBIFS implements the file
	system on top. And now finally, we may concentrate on file-system
	issues: implementing write-back caching, multi-headed journal, garbage
	collector, indexing information management and so on. There are <B>a
	lot</B> of FS problems to solve - orphaned files, deletions,
	recoverability after unclean reboots and so on.</P>

	<P>Of course, one of the main objectives of UBIFS is to provide better
	scalability then JFFS2 has. But UBI itself is not scalable at the
	moment, because it needs to scan the flash when attached. But our argument
	is that UBI is <I>reasonably</I> scalable at the moment because it needs
	to read only the first few bytes of each eraseblock. So it has to be fairly
	fast for even 32GiB flashes. We also argue that UBI may be improved in
	the future and be made more scalable. After all, it is even possible to
	implement a scalable UBI2 in the future. UBIFS itself will not contain
	any linearly scalable component and will scale logarithmically.</P>

	<P><A href="../tech/JFFS3design.pdf">Here</A> is the old JFFS3 design
	document which is totally outdated, but still contains descriptions of
	the basic ideas used in UBIFS.</P>

	<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
