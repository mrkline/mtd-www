<PAGE>
<VAR match="VAR_ORIGIN" replace="../" />
<VAR match="VAR_CVSID" replace="$Id:$"/>
<INCLUDE file="../inc/header.tmpl" />

<VAR match="VAR_SEL_DOC" replace="selected" />
<VAR match="VAR_SEL_UBI" replace="selected" />
<PARSE file="../menu1.xml" />

<INCLUDE file="../inc/content.tmpl" />

<H1>UBI - Unsorted Block Images</H1>

<H2>Table of contents</H2>
<OL>
	<LI><A HREF="ubi.html#L_rednote">Big red note</A></LI>
	<LI><A HREF="ubi.html#L_overview">UBI overview</A></LI>
	<LI><A HREF="ubi.html#L_source">UBI source code</A></LI>
	<LI><A HREF="ubi.html#L_ml">Mailing list</A></LI>
	<LI><A HREF="ubi.html#L_ubiutils">UBI utilities</A></LI>
	<LI><A HREF="ubi.html#L_scalability">UBI scalability</A></LI>
	<OL><LI><A HREF="ubi.html#L_scalability_det">Implementation details</A></LI></OL>
	<LI><A HREF="ubi.html#L_unmap">LEB un-map operation</A></LI>
	<OL><LI><A HREF="ubi.html#L_unmap_det">Implementation details</A></LI></OL>
	<LI><A HREF="ubi.html#L_volupdate">Volume update operation</A></LI>
	<OL><LI><A HREF="ubi.html#L_volupdate_det">Implementation details</A></LI></OL>
	<LI><A HREF="ubi.html#L_lebchange">Atomic LEB change operation</A></LI>
	<OL><LI><A HREF="ubi.html#L_lebchange_det">Implementation details</A></LI></OL>
	<LI><A HREF="ubi.html#L_ubidoc">UBI documentation</A></LI>
</OL>



<A NAME="L_rednote">
<H2><FONT COLOR="RED">Big red note</FONT></H2>
</A>

<P>People are often confused and treat UBI as a block device emulation layer
(also known as FTL - flash translation layer). But this is not true - <B>UBI
is not an FTL.</B> Read the following documentation or see
<A HREF="../faq/ubi.html#L_ext2_over_ubi">this</A> FAQ entry.</P>

<P>Also, sometimes people think that UBI is a flash file-sytstem. This is
incorrect, <B>UBI is not a flash file-system</B>.</P>



<A NAME="L_overview"><H3>UBI overview</H3></A>

<P>UBI (Latin: "where?") stands for "Unsorted Block Images". It is a
volume management system for flash devices which manages multiple logical
volumes on a single physical flash device and spreads the I/O load (i.e,
wear-leveling) across the whole flash chip.</P>

<P>In a sense, UBI may be compared to the Logical Volume Manager
(<A HREF="http://sources.redhat.com/lvm2/">LVM</A>).
Whereas LVM maps logical sectors to physical sectors, UBI maps logical
eraseblocks to physical eraseblocks. But besides the mapping, UBI implements
global wear-leveling and I/O errors handling.</P>

<P>An UBI volume is a set of consecutive <I>logical eraseblocks</I>. Each
logical eraseblock may be mapped to any physical eraseblock. This mapping is
managed by UBI, it is hidden from users and it is the base mechanism to provide
global wear-leveling (along with per-physical eraseblock erase counters and
the ability to transparently move data from less worn-out physical eraseblocks
to more worn-out ones).</P>

<P>UBI volume size is specified when the volume is created a may later be
changed (volumes are dynamically re-sizable). UBI supports <I>dynamic</I>
volumes and <I>static</I> volumes. Static volumes are read-only and their
contents are protected by CRC check sums, while dynamic volumes are read-write
and the upper layer (e.g., a file-system) is responsible for data integrity.</P>

<P>UBI is aware of bad eraseblocks (e.g., NAND flash may have them) and
frees the upper layer from any bad block handling. UBI has a pool of reserved
physical eraseblocks, and when a physical eraseblock becomes bad, it
transparently substitutes it by a good physical eraseblock. UBI moves good data
from the newly appeared bad physical eraseblock to the good one as well. The
result is that users of UBI volumes do not notice I/O errors as UBI takes care
of them.</P>

<P>NAND flashes may have bit-flips which occur on read and write operations.
Bit-flips are corrected by ECC checksums, but they may accumulate over
time and cause data loss. UBI handles this by moving data from physical
eraseblocks with bit-flips to other physical eraseblocks, thus doing active
scrubbing. This is done transparently in background and is hidden from upper
layers.</P>

<P>Here is a short list of the main UBI features:</P>
<UL>
	<LI>UBI provides volumes which may be dynamically created, removed, or
	re-sized;</LI>
	<LI>UBI implements wear-leveling across whole flash device (i.e., one
	may continuously write/erase only the first logical eraseblock
	of an UBI volume, but UBI will spread this to all physical
	eraseblocks of the flash chip);</LI>
	<LI>UBI transparently handles bad physical eraseblocks;</LI>
	<LI>minimizes chances to loose data by means of "scrubbing".</LI>
</UL>

<P>Here is a comparison of MTD partitions and UBI volumes. UBI volumes are
rather similar to MTD partitions because:</P>
<UL>
	<LI>both consist of eraseblocks - logical eraseblocks in case of UBI
	volumes, and physical eraseblocks in case of static partitions;</LI>
	<LI>both support three basic operations - read, write, erase.</LI>
</UL>

<P>But UBI volumes have the following advantages over traditional MTD
partitions:</P>
<UL>
	<LI>there are no eraseblock wear-leveling constraints in case of UBI
	volumes, so users do not have to care about this at all, which means
	the upper-level software may be simpler;</LI>
	<LI>there are no bad eraseblocks in case of UBI volumes, which also leads
	to simpler upper-level software;</LI>
	<LI>UBI handles bit-flips;</LI>
	<LI>UBI also provides an <A HREF="ubi.html#L_lebchange">atomic logical
	eraseblock change</A> operation which allows to change the contents of
	a logical eraseblock and do not loose data if an unclean reboot happens
	during the operation; this is might be very useful for the upper-level
	software (e.g., for a file-system);</LI>
	<LI>UBI has an <A HREF="ubi.html#L_unmap">un-map</A> operation, which
	just un-maps a logical eraseblock from the physical eraseblock,
	schedules the physical eraseblock for erasure and returns; this is very
	quick and frees upper level software from implementing their own
	mechanisms to defer erasures (e.g., JFFS2 has to implements such
	mechanisms).</LI>
</UL>

<P>So, existing software may still work on top of UBI volumes, while new
software may benefit from the UBI features and let UBI solve many issues
which the flash technology imposes.</P>



<A NAME="L_source"><H3>UBI source code</H3></A>

<P>UBI is in the main-line Linux kernel starting from version 2.6.22. But it is
recommended to use the latest UBI which can be found in the UBI git tree:</P>

<CODE>git://git.infradead.org/home/dedekind/ubi-2.6.git</CODE>

<P>The UBI git tree is usually based on top of the lates release of the linux
kernel and it should not be too difficult to fetch all UBI patches from the UBI
git tree and to apply them to your tree.</P>



<A NAME="L_ml"><H3>Mailing list</H3></A>

<P>You are welcome to send feed-back, bug-reports, patches, etc to the
<A HREF="../mail.html">MTD mailing list</A>.</P>



<A NAME="L_ubiutils"><H3>UBI utilities</H3></A>

<P>UBI utilities are available from the the
<CODE>git://git.infradead.org/mtd-utils.git</CODE>
repository (<CODE>ubi-utils</CODE> sub-directory). One should download the
source codes and compile them. Please, download the latest version of the
utilities as they were recently changed quite a lot:</P>

<CODE>git-clone git://git.infradead.org/mtd-utils.git</CODE>

<P>The repository contains the following UBI utilities:</P>
<UL>
	<LI><B>ubinfo</B> - provides information about UBI installed in the
	system, about all UBI devices and volumes;</LI>
	<LI><B>ubiattach</B> - an utility to attach MTD devices (which describe
	raw flash) to UBI, which creates an UBI device sitting on top of the
	MTD device; this is an alternative method to specifying MTD devices on
	module load or in kernel boot command line;</LI>
	<LI><B>ubidetach</B> - an utility to detach MTD devices from UBI
	devices, which deletes the UBI device; in other words, this utility
	does the opposite to what <B>ubiattach</B> does;</LI>
	<LI><B>ubimkvol</B> - an utility to create UBI volumes on UBI
	devices;</LI>
	<LI><B>ubirmvol</B> - an utility to remove UBI volumes on UBI
	devices;</LI>
	<LI><B>ubiupdate</B> - an utility to update UBI volumes, which means to
	write new volume contents; this utility uses the
	<A HREF="ubi.html#L_volupdate">UBI volume update feature</A> which
	leaves the volume in "corrupted" state if it is interrupted;
	additionally, this utility may be used to wipe out UBI volumes;</LI>
	<LI><B>ubicrc32</B> - calculate CRC32 checksum of a file with the same
	initial seed as UBI would use;</LI>
	<LI><B>ubinize</B> - an utility to generate UBI images.</LI>
</UL>

<P>All UBI utilities support "-h" option and print sufficient usage
information.</P>

<P>Note, <CODE>ubiattach</CODE> and <CODE>ubidettach</CODE> won't work unless
one has ported UBI patches from the
<A HREF="ubi.html#L_source">UBI git tree</A>, because the dynamic
UBI devices support was implemented quite recently. It should be in the
main-line kernel starting from version 2.6.25.</P>

<P>Also note, there is an <CODE>old-tools</CODE> sub-directory which contains
some old UBI tools which might be useful (e.g., <B>unubi</B>). But they need
some fixes/clean-ups/documentation etc.</P>

<A NAME="L_scalability"><H3>UBI scalability</H3></A>

<P>Unfortunately, UBI scales linearly in terms of flash size. UBI
initialization time linearly depends on the number of physical eraseblocks on
the flash. This means that the larger is the flash, the more time it takes for
UBI to initialize (i.e., to attach the MTD device). The initialization time
depends on the flash I/O speed and (slightly) on the CPU speed, because:</P>

<UL>
	<LI>UBI scans flash when it is attaching an MTD device - it reads the
	erase counter (EC) and the volume ID (VID) headers from every single
	physical eraseblock of the MTD device; the headers are quite small (64
	bytes each), so this means reading 128 bytes from each PEB on NOR flash
	or one or two NAND pages in case of NAND page (this depends on whether
	the flash supports sub-page writes or not); this is anyway much less
	then JFFS2 needs to read when it mounts MTD devices, so UBI attaches
	MTD devices many times faster then JFFS2 would mount a file system on
	the same MTD device;</LI>
	<LI>UBI calculates CRC32 checksum of each EC and VID header, which
	consumes CPU, although this is usually minor comparing to the
	I/O overhead.</LI>
</UL>

<P>Here are some figures:</P>
<UL>
	<LI>a 256MiB OneNAND flash found in Nokia N800 devices is attached for
	less then 1 sec; the flash does support sub-pages so UBI has to read
	the first 2KiB NAND page of each PEB while scanning;</LI>
	<LI>a 1GiB NAND flash found in OLPC devices is attached for about 2
	seconds; the flash is an SLC and supports sub-pages, but the Cafe
	controller which is used in the laptop does not allow sub-page writes,
	so UBI has to read two 2KiB NAND pages from each PEB.</LI>
</UL>

<P>Unfortunately we do not have more data and the reader is welcome to send it
to us via the <A HREF="../mail.html">MTD mailing list</A>.</P>

<P>UBI allocates few small memory objects for each PEB, which makes its memory
consumption to be linearly dependent on the size of the flash. E.g., it
consumes about 144KiB of RAM in case of a 256MiB flash (2048x128KiB PEBs).</P>

<A NAME="L_scalability_det"><H3>Implementation details</H3></A>

<P>In general, UBI needs three tables for operation:</P>

<UL>
	<LI><B>volume table</B> which contains per-volume information,
	like volume size, type, etc;</LI>
	<LI><B>eraseblock association (EBA) table</B> which contains the
	logical-to-physical eraseblock mapping information; for example, when
	reading an LEB, UBI first looks up the table to find the corresponding
	PEB number, then reads from this PEB;</LI>
	<LI><B>erase counters (EC) table</B> which contains the erase counter
	value for each physical eraseblock; UBI wear-leveling sub-system uses
	this table when it needs to find, for example, a highly worn-out
	LEB;</LI>
</UL>

<P>The volume table is maintained on flash. It changes only when UBI volumes are
created, deleted and re-sized, which are rare and not time-critical operations,
and UBI can afford a slow and simple method of the volume table management.</P>

<P>The EBA and EC tables are changed every time an LEB is mapped to a PEB or a
PEB is erased, which happens quite often and means that the table
management methods would have to be fast and efficient if the table
was maintained on flash. And this would inevitably involve journaling, journal
replay, journal commit, etc. UBI could be logarithmically scalable if it
maintained the latter 2 tables on the flash media, but it does not do this.</P>

<P>One of the UBI requirements was simplicity of on-flash format, because the
original UBI designers had to read UBI volumes from the boot-loader and they
had very tough constraints on the boot-loader code size. It was basically
impossible to add complex journal scanning and replay code to the
boot-loader.</P>

<P>UBI does not maintain the EBA and EC tables on flash, but instead, it builds
them in RAM each time it attaches an MTD device. Instead of maintaining
separate tables, UBI maintains erase counter and LEB mapping of each
physical eraseblock in the physical eraseblock itself. This means, that:</P>

<UL>
	<LI>the erase counter of a PEB is stored at the beginning of the PEB in
	the EC header; when a PEB is erased, UBI increases its erase
	counter and writes the EC header just after the erasure;</LI>
	<LI>the LEB-to-PEB mapping information is stored at the VID header which
	is placed after the EC header; the VID header is written only when the
	PEB gets mapped to an LEB, which happens only when an LEB which was
	previously erased (un-mapped) is written to for the first time; this
	explains why UBI has to write the EC and VID headers separately, which
	requires 2 NAND pages in case of NAND flash (unless the flash allows to
	write 2 or more	times to the same NAND page which is referred to as
	<I>sub-page</I> write).</LI>
</UL>

<P>So, UBI has to scan the flash and read the EC and VID header from each PEB in
order to build in-RAM EC and EBA tables.</P>

<P>The drawbacks of this design are poor scalability and relatively high
overhead on NAND flashes (e.g., the overhead is 1.5%-3% of flash space in case
of a NAND flash with 2KiB NAND page and 128KiB eraseblock). The advantages are
simple binary format and robustness, as the result of symplicity.</P>

<P>Nonetheless, it is always possible to create UBI2 which would maintain the
tables in separate flash areas. UBI2 would not be compatible with UBI because
of completely different on-flash format, but the user interfaces would stay the
same, which would guarantee compatibility of all the software built on top of
UBI.</P>



<A NAME="L_unmap"><H3>LEB un-map operation</H3></A>

<P>The LEB un-map operation is available via the <CODE>ubi_leb_unmap()</CODE>
call of the UBI kernel API. The operation is not available via the
user-space interfaces. The LEB un-map operation:</P>

<UL>
	<LI>first un-maps the LEB from the corresponding PEB;</LI>
	<LI>then schedules the PEB for erasure and returns; it does not wait
	for the erasure of the PEB to be finished; the PEB is instead erased
	in context of the UBI background thread;</LI>
</UL>

<P>UBI returns all <CODE>0xFF</CODE> bytes when an un-mapped LEB is read, so
the un-map operation is very similar to the erase operation (a very fast erase
operation). But there is a difference UBI programmers have to be well aware
of.</P>

<P>Suppose one un-maps LEB <I>L</I> which is mapped to PEB <I>P</I>. Since
<I>P</I> is not synchronously erased, but just scheduled for erasure, there
might be "surprises" in case of unclean reboots: if the reboot happens before
<I>P</I> has been physically erased, <I>L</I> will be mapped to <I>P</I> again
when UBI attaches the MTD device after the unclean reboot. Indeed, UBI will
scan the MTD device and find <I>P</I> which refers <I>L</I>, and it will
add this mapping information to the EBA table.</P>

<P>But once one writes any data to <I>L</I>, it gets mapped to a new empty PEB,
and the old contents goes forever, because even in case of an unclean reboot UBI
would pick the newer mapping for <I>L</I>.</P>

<P>One may use the <CODE>ubi_leb_map()</CODE> call which maps the LEB to an
empty PEB, so the LEB would always contain only 0xFF bytes, even in case of
an unclea reboot. But do not use this unless it is really needed, because this
puts additional overhead on the UBI wear-leveling sub-system, comparing to
an un-mapped LEB. Indeed, if an LEB is un-mapped, there is no PEB which
contains LEB's data, and the wear-leveling sub-system does not have to move any
data to maintain wear-leveling. Conversely, if the LEB is mapped to a PEB,
there is one more PEB for the wear-leveling sub-system to care about, and one
more LEB to re-map to another PEB if the erase counter of the current PEB
becomes too low (then the LEB is re-mapped to a PEB with higher erase counter
and the old PEB is used for other operations).</P>

<A NAME="L_unmap_det"><H3>Implementation details</H3></A>

<P>This section describes how UBI distinguishes between older and newer
versions of an LEB in case of an unclean reboot. Suppose one un-maps LEB
<I>L</I> which is mapped to PEB <I>P<SUB>1</SUB></I>, which means UBI schedules
<I>P<SUB>1</SUB></I> for erasure. Then one writes some data to <I>L</I>, which
means that UBI finds another PEB <I>P<SUB>2</SUB></I>, maps <I>L</I> to
<I>P<SUB>2</SUB></I>, and writes the data to <I>P<SUB>2</SUB></I>. If an
unclean reboot happens before <I>P<SUB>1</SUB></I> is physically erased, but
after the write operation, we end up with 2 PEBs (<I>P<SUB>1</SUB></I> and
<I>P<SUB>2</SUB></I>) mapped to the same LEB <I>L</I>.</P>

<P>To handle situations like this, UBI maintains a global 64-bit <I>sequence
number</I> variable. The sequence number variable is increased each time a PEB
is mapped to a LEB and its value is stored in the VID header of the PEB. So each
VID header has a unique sequence number, and the larger is the sequence number,
the "younger" is the VID header. When UBI attaches an MTD device, it
initializes the global sequence number variable to the highest value found
in existing VID headers plus one.</P>

<P>In the above situation, UBI just selects a PEB with higher sequence number
(<I>P<SUB>2</SUB></I>) and drops the PEB with lower sequence number
(<I>P<SUB>1</SUB></I>).</P>

<P>Note, the situation is more difficult if an unclean reboot happens when UBI
moves the contents of one PEB to another for a wear-leveling purposes, or when
it happens during the <A HREF="ubi.html#L_lebchange">atomic LEB change</A>
operation. In this case it is not enough to just pick the newer PEB, it is also
necessary to make sure all the date was written, not just part of it.</P>



<A NAME="L_volupdate"><H3>Volume update operation</H3></A>

<P>Unlike raw MTD devices, UBI devices support the volume update operation
which may be useful to implement software updates in end-user devices. The
operation changes the contents of whole UBI volume with new contents. Of
course, one could do this with raw MTD devices by means of just erasing the
device and putting the new image on it. But the advantage of the UBI volume
update operation is that if it gets interrupted, the volume goes into
"corrupted" state and further I/O on the volume ends up with an
<CODE>EBADF</CODE> error. And the only way to get the volume back to the normal
state is to start a new volume update operation and to finish it.</P>

<P>The volume update operation allows to detect interrupted updates and to
re-start it with help of, for example, a "mirror" volume which would have the
same contents or by showing a dialog window which would inform the end user
about the problem and request flashing. In contrast, it is difficult to
detect interrupted updates in case of raw MTD devices.</P>

<P>The volume update operation is available only via the user-space UBI
interface and it is not available via the UBI kernel API. To update a
volume, one first has to call the <CODE>UBI_IOCVOLUP</CODE> ioctl of the
corresponding volume character device and to pass a pointer to a 64-bit value
containing the length of the new volume contents in bytes. Then this amount of
bytes has to be written to the volume character device. Once the last byte has
been send to the character device, the update operation is finished.
Schematically, the sequence is:</P>

<PRE>
fd = open("/dev/my_volume");
ioctl(fd, UBI_IOCVOLUP, &amp;image_size);
write(fd, buf, image_size);
close(fd);
</PRE>

<P>See <CODE>include/mtd/ubi-user.h</CODE> for more details. Bear in mind, the
old contents of the volume is not preserved in case of an interrupted update.
Also, it is not necessary to write all new data at one go. It is OK to call
the <CODE>write()</CODE> function arbitrary number of times and pass arbitrary
amount of data each time. The operation will be finished only after all the
data have been written. If the last write operation contains more bytes then
UBI expects, the extra data is just ignored.</P>

<P>Special case of volume update is what we call "volume truncation", which
may be done by specifying zero length of the new contents. In this case the
volume is just wiped out and will contain all <CODE>0xFF</CODE> bytes.</P>

<P>Note, the <CODE>/sys/class/ubi/ubiX_X/corrupted</CODE> sysfs file reflects
the "corrupted" state of the volume: it contains ASCII "0\n" if the volume is OK
and is not corrupted and "1\n" if it is corrupted (because volume update had
started but not finished.</P>

<P>Technically, it is possible to implement an "atomic" volume update
operation, which would mean that the contents of the volume would stay
unchanged in case of interrupted updates. But this would require to have as
much free space as the size of the volume to be updated. This is not currently
implemented.</P>

<A NAME="L_volupdate_det"><H4>Implementation details</H4></A>

<P>The volume update is implemented with help of so-called "update marker". Once
the user has issued the <CODE>UBI_IOCVOLUP</CODE> ioctl, UBI sets the update
marker flag for the volume in the correspoding record of the UBI volume table.
Then the volume is wiped out and UBI waits for the the user to pass the data.
Once all the data arrived and has been written to the flash, the update marker
is cleaned. But in case of an interruption (e.g., unclean reboot, crash of the
update application, etc.), the update marker is not cleaned and the volume is
treated as "corrupted". Only a new successful update operation may clean the
update marker.</P>



<A NAME="L_lebchange"><H3>Atomic LEB change operation</H3></A>

<P>UBI also has an atomic LEB change operation which means that the contents of
the LEB stays unchanged if the operation gets interrupted. In other words, the
result of the operation is that the LEB either has the old contents or the new
contents.</P>

<P>The operation is available via the <CODE>ubi_leb_change()</CODE> kernel API
call. The user-space interface for this operation does not exist in the
mainline kernel so far, but it was recently implemented and may be found in the
<A HREF="ubi.html#L_source">UBI git tree</A>. It should be
available in the main-line kernels starting from version 2.6.25.</P>

<P>The user-space atomic LEB change operation is run via the
<CODE>UBI_IOCEBCH</CODE> ioctl command. One has to pass a pointer to a properly
filled request object of <CODE>struct ubi_leb_change_req</CODE> type. The
object stores the LEB number to change and the length of the new contents. Then
the user has to write the specified amount of bytes to the volume character
device. Notice some similarity to the user-space interface of the volume update
operation. Schematically, the sequence is:</P>

<PRE>
struct ubi_leb_change_req req;

req.lnum = lnum_to_change;
req.len = data_len;
req.dtype = UBI_LONGTERM;  /* data persistency (may also be UBI_SHORTTERM
                              and UBI_UNKNOWN) */
fd = open("/dev/my_volume");
ioctl(fd, UBI_IOCEBCH, &amp;req);
write(fd, data_buf, data_len);
close(fd);
</PRE>

<P>If for some reason the user does not write the declared amount of bytes
and closes the file, the operation is canceled and the old contents of the LEB
is preserved.</P>

<P>Similarly tho the volume update operation it does not matter how many times
the <CODE>write()</CODE> function is called and how much data it passes to the
UBI volume each time. The atomic LEB change operation finishes once the last
data byte arrives.</P>

<P>The atomic LEB change operation might be very useful for file-systems, for
example <A HREF="ubifs.html#">UBIFS</A> uses this operation as a last resort
when it commits the file-system index. This operation may also be exploited
to create an FTL layer on top of UBI (see <A
HREF="http://lists.infradead.org/pipermail/linux-mtd/2008-January/020381.html">
here</A> for the description of the idea).</P>

<P>Keep in mind that the atomic LEB change operation calculates CRC32 checksum
of the new data, so it has some overhead comparing to the LEB erase plus LEB
write sequence. The volume update operation does not calculate data CRC, so it
is faster to update the volume then to atomically change all its eraseblocks.
This additional overhead has to be remembered about and the operation should
not be used if the atomicity is not really needed.</P>

<A NAME="L_lebchange_det"><H4>Implementation details</H4></A>

<P>Suppose UBI has to change a logical eraseblock <I>L</I> which is mapped to a
physical eraseblock <I>P<SUB>1</SUB></I>. First of all, UBI always has one free
PEB reserved for the atomic LEB change operation, let it be
<I>P<SUB>2</SUB></I>. Before the operation, <I>P<SUB>1</SUB></I> stores the
contents of the LEB <I>L</I> and <I>P<SUB>2</SUB></I> is free (it contains only
the EC header and <CODE>OxFF</CODE> bytes). The new data is written to
<I>P<SUB>2</SUB></I>, not to <I>P<SUB>1</SUB></I>, so should anything go wrong,
the old contents of the LEB is always there.</P>

<P>When the operation finishes, UBI un-maps <I>L</I> from <I>P<SUB>1</SUB></I>,
maps in to <I>P<SUB>2</SUB></I>, and schedules <I>P<SUB>1</SUB></I> for erasure.
If the operation is interrupted, <I>L</I> stays being mapped to
<I>P<SUB>1</SUB></I> and <I>P<SUB>2</SUB></I> is scheduled for erasure.</P>

<P>If an unclean reboot happens half way through the atomic LEB change
operation, it is obvious that UBI has to preserve the
<I>L -> P<SUB>1</SUB></I> mapping and erase <I>P<SUB>2</SUB></I> when it is
attaches the MTD device next time. But if the unclean reboot happens just after
the atomic LEB change operation finishes, but before <I>P<SUB>1</SUB></I> is
physically erased, it is obvious that UBI has to preserve
<I>L -> P<SUB>2</SUB></I> mapping and erase <I>P<SUB>1</SUB></I>.</P>

<P>To resolve situations like that, UBI calculates CRC checksum of the new
contents of the LEB before it is written to flash, and stores it in the VID
header (together with data length). When UBI finds 2 PEBs <I>P<SUB>1</SUB></I>
and <I>P<SUB>2</SUB></I> mapped to the same LEB <I>L</I> during the
initialization, it selects the one with higher sequence number
(<I>P<SUB>2</SUB></I>) only if the data CRC is correct (which means all that
the data has been written to the flash media), otherwise it selects the PEB
with lower sequence number(<I>P<SUB>1</SUB></I>). Of course, UBI has to read
the LEB contents in order to check the CRC checksum.</P>



<A NAME="L_ubidoc"><H3>UBI documentation</H3></A>

<P>Unfortunately, there is no nice and shiny UBI documents. But there is an
old UBI design document which has some out-of-date information:
<A HREF="ubidesign/ubidesign.pdf">ubidesign.pdf</A>.</P>

<P>There is also a PowerPoint UBI presentation available:
<A HREF="ubi.ppt">ubi.ppt</A>. Note, this document has to be looked at
in Windows, because it contains a lot of animation and Open Office cannot
properly show it. Use slide show (<CODE>F5</CODE> key) when you look, because
otherwise the animation is not shown. The same slide may change to demonstrate
UBI work once a key is pressed.</P>

<P>Many useful information may be found at the
<A HREF="../faq/ubi.html">FAQ</A> section.</P>

<P>And of course just reading the UBI interface C header files which contains
quite a few commentaries may help: <CODE>include/mtd/ubi-user.h</CODE>
contains the user-space interface definition (namely, it defines UBI ioctl
commands and the involved data structures),
<CODE>include/linux/mtd/ubi.h</CODE> defines the kernel API and the
<CODE>drivers/mtd/ubi/kapi.c</CODE> file contains comments for each kernel API
function (just above the body of the function).</P>

<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
