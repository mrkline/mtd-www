<PAGE>
<VAR match="VAR_ORIGIN" replace="../" />
<VAR match="VAR_CVSID" replace="$Id:$"/>
<INCLUDE file="../inc/header.tmpl" />

<VAR match="VAR_SEL_DOC" replace="selected" />
<VAR match="VAR_SEL_UBI" replace="selected" />
<PARSE file="../menu1.xml" />

<INCLUDE file="../inc/content.tmpl" />


<H2>Table of contents</H2>
<OL>
	<LI><A HREF="ubi.html#L_rednote">Big red note</A></LI>
	<LI><A HREF="ubi.html#L_overview">UBI overview</A></LI>
	<LI><A HREF="ubi.html#L_ubiutils">UBI utilities</A></LI>
	<LI><A HREF="ubi.html#L_scalability">UBI scalability</A></LI>
	<OL><LI><A HREF="ubi.html#L_scalability_det">Implementation details</A></LI></OL>
	<LI><A HREF="ubi.html#L_unmap">LEB un-map operation</A></LI>
	<OL><LI><A HREF="ubi.html#L_unmap_det">Implementation details</A></LI></OL>
	<LI><A HREF="ubi.html#L_volupdate">Volume update operation</A></LI>
	<OL><LI><A HREF="ubi.html#L_volupdate_det">Implementation details</A></LI></OL>
	<LI><A HREF="ubi.html#L_lebchange">Atomic LEB change operation</A></LI>
	<OL><LI><A HREF="ubi.html#L_lebchange_det">Implementation details</A></LI></OL>
	<LI><A HREF="ubi.html#L_ubidoc">UBI documentation</A></LI>
</OL>



<A NAME="L_rednote">
<H2><FONT COLOR="RED">Big red note</FONT></H2>
</A>

<P>People are often confused and treat UBI as a block device emulation layer
(also known as FTL - flash translation layer). But this is not true - <B>UBI
is not an FTL.</B> Read the following documentation or see
<A HREF="../faq/ubi.html#L_ext2_over_ubi">this</A> FAQ entry.</P>



<A NAME="L_overview"><H3>UBI overview</H3></A>

<P>UBI (Latin: "where?") stands for "Unsorted Block Images". It is a
volume management system for flash devices which manages multiple logical
volumes on a single physical flash device and spreads the I/O load (i.e,
wear-leveling) across the whole flash chip.</P>

<P>In a sense, UBI may be compared to the Logical Volume Manager
(<A HREF="http://sources.redhat.com/lvm2/">LVM</A>).
Whereas LVM maps logical sectors to physical sectors, UBI maps logical
eraseblocks to physical eraseblocks. But besides the mapping, UBI implements
global wear-leveling and I/O errors handling.</P>

<P>An UBI volume is a set of consecutive <I>logical eraseblocks</I>. Each
logical eraseblock may be mapped to any physical eraseblock. This mapping is
managed by UBI, it is hidden from users and it is the base mechanism to provide
global wear-leveling (along with per-physical eraseblock erase counters and
the ability to transparently move data from less worn-out physical eraseblocks
to more worn-out ones).</P>

<P>UBI volume size is specified when the volume is created a may later be
changed (volumes are dynamically re-sizable). UBI supports <I>dynamic</I>
volumes and <I>static</I> volumes. Static volumes are read-only and their
contents are protected by CRC check sums, while dynamic volumes are read-write
and the upper layer (e.g., a file-system) is responsible for data integrity.</P>

<P>UBI is aware of bad eraseblocks (e.g., NAND flash may have them) and
frees the upper layer from any bad block handling. UBI has a pool of reserved
physical eraseblocks, and when a physical eraseblock becomes bad, it
transparently substitutes it by a good physical eraseblock. UBI moves good data
from the newly appeared bad physical eraseblock to the good one as well. The
result is that users of UBI volumes do not notice I/O errors as UBI takes care
of them.</P>

<P>NAND flashes may have bit-flips which occur on read and write operations.
Bit-flips are corrected by ECC checksums, but they may accumulate over
time and cause data loss. UBI handles this by moving data from physical
eraseblocks with bit-flips to other physical eraseblocks, thus doing active
scrubbing. This is done transparently in background and is hidden from upper
layers.</P>

<P>Here is a short list of the main UBI features:</P>
<UL>
	<LI>provides volumes which may be dynamically created, removed, or
	re-sized;</LI>
	<LI>implements wear-leveling across whole flash device (i.e., one may
	continuously write/erase only the first logical eraseblock of an UBI
	volume, but UBI will spread this to all physical eraseblocks of the
	flash chip);</LI>
	<LI>transparently handles bad physical eraseblocks;</LI>
	<LI>minimizes chances to loose data by means of "scrubbing".</LI>
</UL>

<P>Here is a comparison of MTD partitions and UBI volumes. UBI volumes are
rather similar to MTD partitions because:</P>
<UL>
	<LI>both consist of eraseblocks - logical eraseblocks in case of UBI
	volumes, and physical eraseblocks in case of static partitions;</LI>
	<LI>both support three basic operations - read, write, erase, although
	UBI have a better "un-map" operation which implements background
	erasure, instead of synchronous.</LI>
</UL>

<P>But UBI volumes have the following advantages over traditional MTD
partitions:</P>
<UL>
	<LI>there are no eraseblock wear-leveling constraints in case of UBI
	volumes, so the user should not care about this at all, which means
	upper-level software may be simpler;</LI>
	<LI>there are no bad eraseblocks in case of UBI volumes, which also leads
	to simpler upper-level software;</LI>
	<LI>UBI handles bit-flips;</LI>
	<LI>UBI also provides an "atomic logical eraseblock change" operation
	which allows to change the contents of a logical eraseblock and do not
	loose data if an unclean reboot happens during the operation; this is
	might be very useful for upper-level software (e.g., for a
	file-system);</LI>
	<LI>UBI has an "un-map" operation, which just un-maps a logical
	eraseblock from the physical eraseblock, schedules the physical
	eraseblock for erasure and returns; this is very quick and frees upper
	level software from implementing their own mechanisms to defer erasure
	(e.g., JFFS2 implements such mechanisms).</LI>
</UL>

<P>So, existing software may still work on top of UBI volumes, while new
software may benefit from the UBI features and let UBI solve many issues
which the flash technology imposes.</P>



<A NAME="L_ubiutils"><H3>UBI utilities</H3></A>

<P>UBI utilities are available from the the
<CODE>git://git.infradead.org/mtd-utils.git</CODE>
repository (<CODE>ubi-utils</CODE> sub-directory). One should download the
source codes and compile them. Please, download the latest version of the
utilities as they were recently changed quite a lot:</P>

<CODE>git-clone git://git.infradead.org/mtd-utils.git</CODE>

<P>The repository contains the following UBI utilities:</P>
<UL>
	<LI><B>ubinfo</B> - provides information about UBI installed in the
	system, about all UBI devices and volumes;</LI>
	<LI><B>ubiattach</B> - an utility to attach MTD devices (which describe
	raw flash) to UBI, which creates an UBI device sitting on top of the
	MTD device; this is an alternative method to specifying MTD devices on
	module load or in kernel boot command line;</LI>
	<LI><B>ubidetach</B> - an utility to detach MTD devices from UBI
	devices, which deletes the UBI device; in other words, this utility
	does the opposite to what <B>ubiattach</B> does;</LI>
	<LI><B>ubimkvol</B> - an utility to create UBI volumes on UBI
	devices;</LI>
	<LI><B>ubirmvol</B> - an utility to remove UBI volumes on UBI
	devices;</LI>
	<LI><B>ubiupdate</B> - an utility to update UBI volumes, which means to
	write new volume contents; this utility uses the UBI volume update
	feature which leaves the volume in "corrupted" state if interrupted;
	additionally, this utility may be used to wipe out UBI volumes;</LI>
	<LI><B>ubicrc32</B> - calculate CRC32 checksum of a file with the same
	initial seed as UBI would use;</LI>
	<LI><B>ubinize</B> - an utility to generate UBI images.</LI>
</UL>

<P>All UBI utilities support "-h" option and print sufficient usage
information.</P>
<P>Also note, there is an <CODE>old-tools</CODE> sub-directory which contains
some old UBI tools which might be useful (e.g., <B>unubi</B>). But they need
some fixes/clean-ups/documentation etc.</P>



<A NAME="L_scalability"><H3>UBI scalability</H3></A>

<P>Unfortunately, UBI scales linearly in terms of flash size. UBI
initialization time linearly depends on the number of physical eraseblocks on
the flash. This means that the larger is the flash, the more time it takes for
UBI to initialize (i.e., to attach the MTD device). This means that UBI is OK
for relatively small flashes, but it is not OK for large flashes. The
initialization time depends on flash I/O speed and CPU speed, because:</P>

<UL>
	<LI>UBI scans flash when it is attaching an MTD device - it reads the
	erase counter (EC) and the volume ID (VID) headers from every single
	physical eraseblock of the MTD device; the headers are quite small (64
	bytes each), so this means reading 128 bytes from each PEB on NOR flash
	or one or two NAND pages in case of NAND page (this depends on whether
	the flash supports sub-page writes or not); this is anyway much less
	then JFFS2 needs to read when it mounts MTD devices, so UBI attaches
	MTD devices many times faster then JFFS2 would mount a file system on
	the same MTD device;</LI>
	<LI>UBI calculates CRC32 checksum of each EC and VID header, which
	consumes CPU, although this is usually minor comparing to the
	I/O time.</LI>
</UL>

<P>Here are some figures:</P>
<UL>
	<LI>a 256MiB OneNAND flash found in Nokia N800 devices is attached for
	less then 1 sec; the flash does support sub-pages so UBI has to read
	the first 2KiB NAND page of each PEB while scanning;</LI>
	<LI>a 1GiB flash found in OLPC devices is attached for about 2 seconds;
	the flash is an SLC and supports sub-pages, but the Cafe controller
	which is used in the laptop does not allow sub-page writes, so UBI has
	to read two 2KiB NAND pages from each PEB.</LI>
</UL>

<P>Unfortunately we do not have more data and the reader is welcome to send it
to us via the <A HREF="../mail.html">MTD mailing list</A>.</P>

<P>UBI allocates few small memory objects for each PEB, which makes its memory
consumption to be linearly dependent on the size of the flash. E.g., it
consumes about 144KiB of RAM in case of a 256MiB flash (2048x128KiB PEBs).</P>

<A NAME="L_scalability_det"><H3>Implementation details</H3></A>

<P>In general, UBI needs three tables for operation:</P>

<UL>
	<LI><B>volume table</B> which contains per-volume information,
	like volume size, type, etc;</LI>
	<LI><B>eraseblock association (EBA) table</B> which contains
	logical-to-physical eraseblock mapping information; for example, when
	reading an LEB, UBI first looks up the table to find the corresponding
	PEB number, then reads from this PEB;</LI>
	<LI><B>erase counters (EC) table</B> which contains the erase counter
	value for each physical eraseblock; UBI wear-leveling sub-system uses
	this table when it needs to find, for example, a highly worn-out
	LEB;</LI>
</UL>

<P>The volume table is maintained on flash. It changes only when volumes are
created, deleted and re-sized, which are rare and not time-critical operations,
and UBI can afford a slow and simple method of the volume table management.</P>

<P>The EBA and EC tables are changed every time an LEB is mapped to a PEB or a
PEB is erased, which happens quite often and which means that the table
management methods would have to be fast and efficient if the table
was maintained on flash. And this would inevitably involve Journaling, journal
replay, journal commit, etc. UBI could be logarithmically scalable if it
maintained the latter 2 tables on the flash media, but it does not do this.</P>

<P>One of the UBI requirements was simplicity of on-flash format, because the
original UBI designers had to read UBI volumes from the boot-loader and they
had very tough constraints on the boot-loader code size. It was basically
impossible to add complex journal scanning and replay code to the
boot-loader.</P>

<P>UBI does not maintain the EBA and EC tables on flash, but instead, it builds
them in RAM each time it attaches an MTD device. Instead of maintaining
separate tables, UBI maintains erase counter and LEB mapping of each
physical eraseblock in the physical eraseblock itself. This means, that:</P>

<UL>
	<LI>the erase counter of a PEB is stored at the beginning of the PEB in
	the EC header; when a PEB is erased, UBI increases its erase
	counter and writes the EC header just after the erasure;</LI>
	<LI>the LEB-to-PEB mapping information is stored at the VID header which
	is placed after the EC header; the VID header is written only when the
	PEB gets mapped to an LEB, which happens only when an LEB which was
	previously erased (un-mapped) is written to for the first time; this
	explains why UBI have to write EC and VID headers separately which
	require 2 NAND pages in case of NAND flash (unless the flash allows to
	write 2 or more	times to the same NAND page which is referred to as
	<I>sub-page</I> write).</LI>
</UL>

<P>So, UBI has to scan the flash and read EC and VID headers from each PEB in
order to build in-RAM EC and EBA tables.</P>

<P>The drawbacks of this design are poor scalability and relatively high
overhead on NAND flashes (e.g., the overhead is 1.5%-3% of flash space in case
of 2KiB NAND page and 128KiB eraseblock). The advantages are simple binary
format and robustness, as the result of symplicity.</P>

<P>Nonetheless, it is always possible to create UBI2 which would maintain the
tables in separate flash areas. UBI2 would not be compatible with UBI because
of completely different on-flash format, but the user interfaces would stay the
same, which would guarantee compatibility of all the software built on top of
UBI.</P>



<A NAME="L_unmap"><H3>LEB un-map operation</H3></A>

<P>The LEB un-map operation is available via the <CODE>ubi_leb_unmap()</CODE>
call of the UBI kernel API. The operation is not available via the
user-space interfaces. The LEB un-map operation includes:</P>

<UL>
	<LI>un-mapping the LEB from the corresponding PEB;</LI>
	<LI>scheduling the PEB for erasure and the function returns; the LEB
	un-map operation does not wait for the erasure to be finished; the PEB
	is instead erased in the context of the UBI background thread;</LI>
</UL>

<P>UBI returns all <CODE>0xFF</CODE> bytes when an un-mapped LEB is read, so
the un-map operation is very similar to the erase operation (a very fast erase
operation). But there is a difference UBI programmers have to be well aware
of.</P>

<P>Suppose one un-maps LEB <I>L</I> which is mapped to PEB <I>P</I>. Since
<I>P</I> is not synchronously erased, but just scheduled for erasure, there
might be "surprises" in case of unclean reboots: if the reboot happens before
<I>P</I> has been physically erased, <I>L</I> will be mapped to <I>P</I> again
when UBI attaches the MTD device after the unclean reboot. Indeed, UBI will
scan the MTD device and find the <I>P</I> which refers <I>L</I>, and it will
add this mapping information to the EBA table.</P>

<P>But once one writes any data to <I>L</I>, it gets mapped to a new empty PEB,
and the old contents goes forever, because even in case of an unclean reboot UBI
would pick the newer mapping for <I>L</I>.</P>

<P>One may use the <CODE>ubi_leb_map()</CODE> call which maps the LEB to an
empty PEB, so the LEB would always contain only 0xFF bytes, even in case of
unclean reboots. But do not use this unless it is really needed, because this
puts additional overhead on the UBI wear-leveling sub-system, comparing to
an un-mapped LEB. Indeed, if an LEB is un-mapped, there is no PEB which
contains LEB's data, and the wear-leveling sub-system does not have to move any
data to maintain wear-leveling. Conversely, if the LEB is mapped to a PEB,
there is one more PEB for the wear-leveling sub-system to care about, and one
more LEB to re-map to another PEB if the erase counter of the current PEB
becomes too low (then the LEB is re-mapped to a PEB with higher erase counter
and the old PEB is used for other operations).</P>

<A NAME="L_unmap_det"><H3>Implementation details</H3></A>

<P>This section describes how UBI distinguishes between older and newer
versions of an LEB in case of an unclean reboot. Suppose one un-maps LEB
<I>L</I> which is mapped to PEB <I>P<SUB>1</SUB></I>, which means UBI schedules
<I>P<SUB>1</SUB></I> for erasure. Then one writes some date to <I>L</I>, which
means that UBI finds another PEB <I>P<SUB>2</SUB></I>, maps <I>L</I> to
<I>P<SUB>2</SUB></I>, and writes the data to <I>P<SUB>2</SUB></I>. If an
unclean reboot happens before <I>P<SUB>1</SUB></I> is physically erased, we end
up with 2 PEBs (<I>P<SUB>1</SUB></I> and <I>P<SUB>2</SUB></I>) mapped to the
same LEB <I>L</I>.</P>

<P>To handle situations like this, UBI maintains global 64-bit <I>sequence
number</I> variable. The sequence number variable is increased each time a PEB
is mapped to a LEB its value is stored in the VID header of the PEB. So each
VID header has a unique sequence number, and the larger is the sequence number,
the, the "younger" the VID header is. When UBI attaches an MTD device, it
initializes the global sequence number variable to the highest value plus
one.</P>

<P>In the above situation, UBI just selects an PEB with higher sequence number
(<I>P<SUB>2</SUB></I>) and drops the PEB with lower sequence number
(<I>P<SUB>1</SUB></I>).</P>

<P>Note, the situation is more difficult if an unclean reboot happens when UBI
moves the contents of one PEB to another for a wear-leveling purposes, or when
it happens during the "atomic LEB change" operation. In this case it is not
enough to just pick the newer PEB, it is also necessary to make sure all the
date was written, not just part of it.</P>



<A NAME="L_volupdate"><H3>Volume update operation</H3></A>

<P>Unlike raw MTD devices, UBI devices support the volume update operation
which may be useful to implement software updates in end-user devices. The
operation changes the contents of a whole UBI volume with a new contents. Of
course, one could do this with raw MTD devices by means of just erasing the
device and putting the new image on it. But the advantage of the UBI volume
update operation is that if it gets interrupted, the volume goes into
"corrupted" state, so that any further I/O on the volume ends up with an
<CODE>EBADF</CODE> error. And the only way to get the volume back to the normal
state is to start a new volume update operation and to finish it.</P>

<P>The volume update operation allows to detect a interrupted update and to
re-start it with help of, for example, a "mirror" volume which would have the
same contents or by showing a dialog window which would inform the end user
about the problem and request for flashing. In contrast, it is difficult to
detect an interrupted update in case of a raw MTD device.</P>

<P>The volume update operation is available only via UBI user-space interface
and it is not available via UBI kernel API. To update a volume, one first has
to call the <CODE>UBI_IOCVOLUP</CODE> ioctl of the corresponding volume
character device and to pass a pointer to a 64-bit value containing the
length of the new volume contents in bytes. Then this amount of bytes has to be
written to the volume character device. Once the last byte has been written,
the update operation is finished. Schematically, the sequence is:</P>

<PRE>
fd = open("/dev/my_volume");
ioctl(fd, UBI_IOCVOLUP, &amp;image_size);
write(fd, buf, image_size);
close(fd);
</PRE>

<P>See <CODE>include/mtd/ubi-user.h</CODE> for more details. Bear in mind, the
old contents of the volume is not preserved in case of an interrupted update.
And one does not have to write whole new data at one go. It is OK to call
<CODE>write()</CODE> arbitrary number of times and pass arbitrary amount of
data each time. The operation will be finished only after all the data have
been written. If the last write operation contains more bytes then UBI expects,
the extra data is just ignored.</P>

<P>The special case of volume update is what we call volume truncation, which
may be done by specifying zero length of the new contents. In this case the
volume is just wiped out and will contain all <CODE>0xFF</CODE> bytes.</P>

<P>Note, the <CODE>/sys/class/ubi/ubiX_X/corrupted</CODE> file reflects the
"corrupted" state of the volume: it contains ASCII "0\n" if the volume is OK
and not corrupted and "1\n" if it is corrupted (because volume update had
started but not finished.</P>

<P>Technically, it is possible to implement "atomic" volume update
operation, which would mean that the contents of the volume would stay
unchanged in case of an interrupted update. But this would require to have as
much free space as the size of the volume under update. This is not currently
implemented.</P>

<A NAME="L_volupdate_det"><H4>Implementation details</H4></A>

<P>The volume update is implemented with help of so-called "update marker". Once
he user has issued the <CODE>UBI_IOCVOLUP</CODE> ioctl, UBI sets the update
marker flag for the volume in its record in the UBI volume table. Then the
volume is wiped out and UBI waits for the new contents. Once all the data has
arrived and has been written to the flash, the update marker is flag is
cleaned. But in case of an interruption (e.g., unclean reboot, crash of the
update application, etc.), the update marker is not cleaned and the volume is
treated as "corrupted". Only a new successful update operation may clean the
update marker.</P>



<A NAME="L_lebchange"><H3>Atomic LEB change operation</H3></A>

<P>UBI also has an atomic LEB change operation which means that the contents of
the LEB stays unchanged if the operation gets interrupted. In other words, the
result of the operation is that the LEB either have the old contents or the new
contents.</P>

<P>The operation is available via the <CODE>ubi_leb_change()</CODE> kernel API
call. The user-space interface does not exist in the mainline kernel so far,
but it was recently implemented and may be found in the
<A HREF="../faq/ubi.html#L_find_ubi_src">UBI git tree</A>. It should be
available in the mainline kernels starting from kernel version 2.6.25.</P>

<P>The user-space atomic LEB change operation is run via the
<CODE>UBI_IOCEBCH</CODE> ioctl command. One has to pass a pointer to a properly
filled request object of <CODE>struct ubi_leb_change_req</CODE> type. The
object stores LEB number and the length of the new contents. Then the user has
to write the specified amount of bytes to the volume character device and which
finishes the operation. Note some similarity to the user-space interface of the
volume update operation. Schematically, the sequence is:</P>

<PRE>
struct ubi_leb_change_req req;

req.lnum = lnum_to_change;
req.len = data_len;
req.dtype = UBI_LONGTERM;  /* data persistency (may also be UBI_SHORTTERM
                              and UBI_UNKNOWN) */
fd = open("/dev/my_volume");
ioctl(fd, UBI_IOCEBCH, &amp;req);
write(fd, data_buf, data_len);
close(fd);
</PRE>

<P>So if for some reason the user does not write the declared amount of bytes
and closes the file, the operation is canceled and the old contents of the LEB
is preserved.</P>

<P>Similarly tho the volume update operation, it does not matter how many times
<CODE>write()</CODE> is called and how much data it passes to the UBI volume
each time. The operation is finished once the last byte arrives.</P>

<P>The atomic LEB change operation might be very useful for file-systems, for
example UBIFS uses this operation as a last resort thing when it commits the
FS index. This operation may also be exploited to create an FTL layer on top of
UBI (see <A
HREF="http://lists.infradead.org/pipermail/linux-mtd/2008-January/020381.html">
here</A> for the description of the idea).</P>

<P>Keep in mind that the atomic LEB change operation calculates CRC32 checksum
of the new data, so it has some overhead comparing to a LEB erase plus LEB
write sequence. The volume update operation does not calculate data CRC, so it
is faster to update the volume then atomically change all its eraseblocks. This
additional overhead has to be remembered about and the operation should not be
used if the atomicity is not really needed. See the
<A HREF="ubi.html#L_lebchange_det">next</A> section for more details.</P>


<A NAME="L_lebchange_det"><H4>Implementation details</H4></A>

<P>Suppose UBI has to change a logical eraseblock <I>L</I> which is mapped to a
physical eraseblock <I>P<SUB>1</SUB></I>. First of all, UBI always has one free
PEB reserved for the "atomic LEB change" operation, let it be
<I>P<SUB>2</SUB></I>. So, before the operation, <I>P<SUB>1</SUB></I> stores the
contents of the LEB <I>L</I> and <I>P<SUB>2</SUB></I> is free (contains only
<CODE>OxFF</CODE> bytes). The new data is written to <I>P<SUB>2</SUB></I>, not
to <I>P<SUB>1</SUB></I>, so should anything go wrong, the old LEB contents is
always there.</P>

<P>When the operation finishes, UBI un-maps <I>L</I> from <I>P<SUB>1</SUB></I>,
maps in to <I>P<SUB>2</SUB></I>, and schedules <I>P<SUB>1</SUB></I> for erasure.
If the operation is interrupted, <I>L</I> stays being mapped to
<I>P<SUB>1</SUB></I> and <I>P<SUB>2</SUB></I> is scheduled for erasure.</P>

<P>If an unclean reboot happens half way through the atomic LEB change
operation, it is obvious that UBI has to preserve
<I>L -> P<SUB>1</SUB></I> mapping and erase <I>P<SUB>2</SUB></I> when it is
initialized next time. But if the unclean reboot happens just after the atomic
LEB change operation finishes, but before <I>P<SUB>1</SUB></I> is physically
erased, it is obvious that UBI has to preserve <I>L -> P<SUB>2</SUB></I> mapping
and erase <I>P<SUB>1</SUB></I>.</P>

<P>To resolve situations like this, UBI calculates CRC checksum of the new
contents of the LEB before it is written to flash, and stores it in the VID
header (together with data length). When UBI finds 2 PEBs <I>P<SUB>1</SUB></I>
and <I>P<SUB>2</SUB></I> mapped to the same LEB <I>L</I> during initialization,
it selects the one with higher sequence number (<I>P<SUB>2</SUB></I>) only if
the data CRC is correct (which means all that the data has been written to the
flash media), otherwise it selects the PEB with lower sequence number
(<I>P<SUB>1</SUB></I>). Of course, UBI has to read the LEB contents in order
to check the CRC checksum.</P>



<A NAME="L_ubidoc"><H3>UBI documentation</H3></A>

<P>Unfortunately, there is no nice and shiny UBI documents. But there is an
old UBI design document which has some out-of-date information:
<A HREF="ubidesign/ubidesign.pdf">ubidesign.pdf</A>.</P>

<P>There is also a PowerPoint UBI presentation available:
<A HREF="ubi.ppt">ubi.ppt</A>. Note, this document has to be looked at
in Windows, because it contains a lot of animation and Open Office cannot
properly show it. Use slide show (<CODE>F5</CODE> key) when you look, because
otherwise the animation is not shown. The same slide may change to demonstrate
UBI work once a key is pressed.</P>

<P>Many useful information may be found at the
<A HREF="../faq/ubi.html">FAQ</A> section.</P>

<P>And of course just reading the UBI interface C header files which contains
quite a few commentaries may help: <CODE>include/mtd/ubi-user.h</CODE>
contains the user-space interface definition (namely, it defines UBI ioctl
commands and the involved data structures),
<CODE>include/linux/mtd/ubi.h</CODE> defines the kernel API and the
<CODE>drivers/mtd/ubi/kapi.c</CODE> file contains comments for each kernel API
function (just above the body of the function).</P>

<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
