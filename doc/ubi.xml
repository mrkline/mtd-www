<PAGE>
<VAR match="VAR_ORIGIN" replace="../" />
<VAR match="VAR_CVSID" replace="$Id:$"/>
<INCLUDE file="../inc/header.tmpl" />

<VAR match="VAR_SEL_DOC" replace="selected" />
<VAR match="VAR_SEL_UBI" replace="selected" />
<PARSE file="../menu1.xml" />

<INCLUDE file="../inc/content.tmpl" />


<H2>Table of contents</H2>
<OL>
	<LI><A HREF="ubi.html#L_rednote">Big red note</A></LI>
	<LI><A HREF="ubi.html#L_overview">UBI overview</A></LI>
	<LI><A HREF="ubi.html#L_ubiutils">UBI utilities</A></LI>
	<LI><A HREF="ubi.html#L_ubidoc">UBI documentation</A></LI>
</OL>



<A NAME="L_rednote">
<H2><FONT COLOR="RED">Big red note</FONT></H2>
</A>

<P>People are often confused and treat UBI as a block device emulation layer
(also known as FTL - flash translation layer). But this is not true - <B>UBI
is not an FTL.</B> Read the following documentation or see
<A HREF="../faq/ubi.html#L_ext2_over_ubi">this</A> FAQ entry.</P>



<A NAME="L_overview"><H3>UBI overview</H3></A>

<P>UBI (Latin: "where?") stands for "Unsorted Block Images". It is a
volume management system for flash devices which manages multiple logical
volumes on a single physical flash device and spreads the I/O load (i.e,
wear-leveling) across the whole flash chip.</P>

<P>In a sense, UBI may be compared to the Logical Volume Manager
(<A HREF="http://sources.redhat.com/lvm2/">LVM</A>).
Whereas LVM maps logical sectors to physical sectors, UBI maps logical
eraseblocks to physical eraseblocks. But besides the mapping, UBI implements
global wear-leveling and I/O errors handling.</P>

<P>An UBI volume is a set of consecutive <I>logical eraseblocks</I>. Each
logical eraseblock may be mapped to any physical eraseblock. This mapping is
managed by UBI, it is hidden from users and it is the base mechanism to provide
global wear-leveling (along with per-physical eraseblock erase counters and
the ability to transparently move data from less worn-out physical eraseblocks
to more worn-out ones).</P>

<P>UBI volume size is specified when the volume is created a may later be
changed (volumes are dynamically re-sizable). UBI supports <I>dynamic</I>
volumes and <I>static</I> volumes. Static volumes are read-only and their
contents are protected by CRC check sums, while dynamic volumes are read-write
and the upper layer (e.g., a file-system) is responsible for data integrity.</P>

<P>UBI is aware of bad eraseblocks (e.g., NAND flash may have them) and
frees the upper layer from any bad block handling. UBI has a pool of reserved
physical eraseblocks, and when a physical eraseblock becomes bad, it
transparently substitutes it by a good physical eraseblock. UBI moves good data
from the newly appeared bad physical eraseblock to the good one as well. The
result is that users of UBI volumes do not notice I/O errors as UBI takes care
of them.</P>

<P>NAND flashes may have bit-flips which occur on read and write operations.
Bit-flips are corrected by ECC checksums, but they may accumulate over
time and cause data loss. UBI handles this by moving data from physical
eraseblocks with bit-flips to other physical eraseblocks, thus doing active
scrubbing. This is done transparently in background and is hidden from upper
layers.</P>

<P>Here is a short list of the main UBI features:</P>
<UL>
	<LI>provides volumes which may be dynamically created, removed, or
	re-sized;</LI>
	<LI>implements wear-leveling across whole flash device (i.e., one may
	continuously write/erase only the first logical eraseblock of an UBI
	volume, but UBI will spread this to all physical eraseblocks of the
	flash chip);</LI>
	<LI>transparently handles bad physical eraseblocks;</LI>
	<LI>minimizes chances to loose data by means of "scrubbing".</LI>
</UL>

<P>Here is a comparison of MTD partitions and UBI volumes. UBI volumes are
rather similar to MTD partitions because:</P>
<UL>
	<LI>both consist of eraseblocks - logical eraseblocks in case of UBI
	volumes, and physical eraseblocks in case of static partitions;</LI>
	<LI>both support three basic operations - read, write, erase, although
	UBI have a better "unmap" operation which implements background
	erasure, instead of synchronous.</LI>
</UL>

<P>But UBI volumes have the following advantages over traditional MTD
partitions:</P>
<UL>
	<LI>there are no eraseblock wear-leveling constraints in case of UBI
	volumes, so the user should not care about this at all, which means
	upper-level software may be simpler;</LI>
	<LI>there are no bad eraseblocks in case of UBI volumes, which also leads
	to simpler upper-level software;</LI>
	<LI>UBI handles bit-flips;</LI>
	<LI>UBI also provides an "atomic logical eraseblock change" operation
	which allows to change the contents of a logical eraseblock and do not
	loose data if an unclean reboot happens during the operation; this is
	might be very useful for upper-level software (e.g., for a
	file-system);</LI>
	<LI>UBI has an "unmap" operation, which just un-maps a logical
	eraseblock from the physical eraseblock, schedules the physical
	eraseblock for erasure and returns; this is very quick and frees upper
	level software from implementing their own mechanisms to defer erasure
	(e.g., JFFS2 implements such mechanisms).</LI>
</UL>

<P>So, existing software may still work on top of UBI volumes, while new
software may benefit from the UBI features and let UBI solve many issues
which the flash technology imposes.</P>



<A NAME="L_ubiutils"><H3>UBI utilities</H3></A>

<P>UBI utilities are available from the the
<CODE>git://git.infradead.org/mtd-utils.git</CODE>
repository (<CODE>ubi-utils</CODE> sub-directory). One should download the
source codes and compile them. Please, download the latest version of the
utilities as they were recently changed quite a lot:</P>

<CODE>git-clone git://git.infradead.org/mtd-utils.git</CODE>

<P>The repository contains the following UBI utilities:</P>
<UL>
	<LI><B>ubinfo</B> - provides information about UBI installed in the
	system, about all UBI devices and volumes;</LI>
	<LI><B>ubiattach</B> - an utility to attach MTD devices (which describe
	raw flash) to UBI, which creates an UBI device sitting on top of the
	MTD device; this is an alternative method to specifying MTD devices on
	module load or in kernel boot command line;</LI>
	<LI><B>ubidetach</B> - an utility to detach MTD devices from UBI
	devices, which deletes the UBI device; in other words, this utility
	does the opposite to what <B>ubiattach</B> does;</LI>
	<LI><B>ubimkvol</B> - an utility to create UBI volumes on UBI
	devices;</LI>
	<LI><B>ubirmvol</B> - an utility to remove UBI volumes on UBI
	devices;</LI>
	<LI><B>ubiupdate</B> - an utility to update UBI volumes, which means to
	write new volume contents; this utility uses the UBI volume update
	feature which leaves the volume in "corrupted" state if interrupted;
	additionally, this utility may be used to wipe out UBI volumes;</LI>
	<LI><B>ubicrc32</B> - calculate CRC32 checksum of a file with the same
	initial seed as UBI would use;</LI>
	<LI><B>ubinize</B> - an utility to generate UBI images.</LI>
</UL>

<P>All UBI utilities support "-h" option and print sufficient usage
information.</P>
<P>Also note, there is an <CODE>old-tools</CODE> sub-directory which contains
some old UBI tools which might be useful (e.g., <B>unubi</B>). But they need
some fixes/clean-ups/documentation etc.</P>



<A NAME="L_ubidoc"><H3>UBI documentation</H3></A>

<P>Unfortunately, there is no nice and shiny UBI documents. But there is an
old UBI design document which has some out-of-date information:
<A HREF="ubidesign/ubidesign.pdf">ubidesign.pdf</A>.</P>

<P>There is also a PowerPoint UBI presentation available:
<A HREF="ubi.ppt">ubi.ppt</A>. Note, this document has to be looked at
in Windows, because it contains a lot of animation and Open Office cannot
properly show it. Use slide show (<CODE>F5</CODE> key) when you look, because
otherwise the animation is not shown. The same slide may change to demonstrate
UBI work once a key is pressed.</P>

<P>Many useful information may be found at the
<A HREF="../faq/ubi.html">FAQ</A> section.</P>

<INCLUDE file="../inc/footer.tmpl" />
</PAGE>
